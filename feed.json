{"title":"哈哈，你不行","description":"my blog","language":"en","link":"https://augus-liuzhi.github.io","pubDate":"Wed, 14 Apr 2021 02:56:38 GMT","lastBuildDate":"Thu, 15 Apr 2021 11:53:38 GMT","generator":"hexo-generator-json-feed","webMaster":"哈哈，你不行","items":[{"title":"SpringSecurity","link":"https://augus-liuzhi.github.io/2021/04/14/SpringSecurity/","description":"1 整合Security1.1 导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 指定用户名密码1234security: user: name: 用户名 password: 密码 2 自定义登陆UserDetailsService接口123public interface UserDetailsService &#123; UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;&#125; UserDetails接口12345678910111213141516public interface UserDetails extends Serializable &#123; //获取所有权限 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); //获取密码 String getPassword(); //获取用户名 String getUsername(); //账户是否过期 boolean isAccountNonExpired(); //账户是否被锁定 boolean isAccountNonLocked(); //凭证是否过期 boolean isCredentialsNonExpired(); //是否可用 boolean isEnabled();&#125; 自定义认证逻辑需要实现UserDetailsService接口，该接口返回一个 UserDetails接口，则需要返回UserDetail接口的实现类User User类1234package org.springframework.security.core.userdetails;public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; username: 前端传来的username password: 密码是从数据库中查询出来的密码,此处只关心数据库中的密码，前端的密码框架会自动获取并且完成比较。 springSecurity会根据前端传来的密码，和数据库中的密码进行比较，如果相同认证成功，不过失败，则认证失败。 authorities:用户权限，不允许为null PasswordEncoder接口12345678910public interface PasswordEncoder &#123; //把参数按照特定的规则进行解析，加密 String encode(CharSequence var1); //验证从存储中获取到的密码与编码后的提交的原始密码是否一致，第一个参数为前段密码，第二个为存储密码 boolean matches(CharSequence var1, String var2); //解析的密码能够再次解析，达到更安全的结果则返回true,否则返回false default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125;&#125; BCryptPasswordEncoder类 passwordEncoder接口的实现类 BCryptPasswordgEncoder是基于Hash算法的实现的单向加密 12345678910111213@SpringBootTestpublic class Password &#123; @Test public void testPassword()&#123; PasswordEncoder passwordEncoder=new BCryptPasswordEncoder(); //对123进行加密 String encode = passwordEncoder.encode(\"123\"); System.out.println(encode); //判断1234是否和123加密后的匹配 boolean matches=passwordEncoder.matches(\"1234\",encode); System.out.println(matches); &#125;&#125; ValidateCodeFilter类12345678910111213141516171819202122232425262728293031323334@Componentpublic class ValidateCodeFilter extends OncePerRequestFilter &#123; @Autowired LoginFailHandle loginFailHandle; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //不是登陆请求不过滤 if (!\"/login\".equals(request.getServletPath())) &#123; filterChain.doFilter(request, response); return; &#125; try &#123; doValidateCode(request); filterChain.doFilter(request, response); &#125;catch (ValidateCodeException e)&#123; loginFailHandle.onAuthenticationFailure(request,response,e); throw new ValidateCodeException(\"校验验证码失败\"); &#125;finally &#123; request.getSession().removeAttribute(\"verify_code\"); &#125; &#125; public void doValidateCode(HttpServletRequest request)&#123; //获取表单中提交验证码的值 String FormVerifyCode=request.getParameter(\"imageCode\"); String captcha= (String) request.getSession().getAttribute(\"verify_code\"); if(FormVerifyCode==null)&#123; throw new ValidateCodeException(\"验证码输入为空\"); &#125; if(!FormVerifyCode.toLowerCase().equals(captcha.toLowerCase()))&#123; throw new ValidateCodeException(\"验证码输入错误\"); &#125; &#125;&#125; ValidateCodeException类12345public class ValidateCodeException extends AuthenticationException &#123; public ValidateCodeException(String msg) &#123; super(msg); &#125;&#125;","pubDate":"Wed, 14 Apr 2021 02:56:38 GMT","guid":"https://augus-liuzhi.github.io/2021/04/14/SpringSecurity/","category":""},{"title":"Docker","link":"https://augus-liuzhi.github.io/2021/03/31/Docker/","description":"Docker安装环境： Centos7 1. 设置仓库1234yum install -y yum-utilsyum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 2. 安装Docker引擎1yum install docker-ce docker-ce-cli containerd.io 默认安装最新版 如果安装指定版本 1234#查看docker的版本yum list docker-ce --showduplicates | sort -r#安装指定版本号的dockeryum install docker-ce-&lt;版本号&gt; docker-ce-cli-&lt;版本号&gt; containerd.io 3. 运行Docker1systemctl start docker 4. Hello-world1docker run hello-world 显示Hello from Docker!到这就安装成功了 5. docker镜像加速12345vim /etc/docker/deamon.json #编辑此文件，写deamon.json为阿里云镜像源，为镜像加速&#123; \"registry-mirrors\": [\"https://alzgoonw.mirror.aliyuncs.com\"] &#125; Docker使用1. 查看已有的镜像列表1docker images 2. 查找镜像1docker search 镜像名 3. 下载镜像1docker pull 镜像名 4. 删除镜像1docker rmi 镜像名 5. 运行容器1docker run -d 后台运行 --name 给容器起个名 -p 容器端口映射到外部端口 镜像:版本 6. 关闭容器1docker stop 容器id 7. 运行以后再次启动容器1docker start 容器id 8. 进入容器后台1docker exec -it 容器id /bin/bash 9. 退出交互模式1exit","pubDate":"Wed, 31 Mar 2021 08:34:09 GMT","guid":"https://augus-liuzhi.github.io/2021/03/31/Docker/","category":""},{"title":"SpringBoot数据访问","link":"https://augus-liuzhi.github.io/2021/03/31/springboot整合数据/","description":"SpringBoot数据访问数据访问jdbc1. 导入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 2. 配置文件 123456spring: datasource: url: jdbc:mysql://localhost:3306/ssm0306?useSSL=false&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 3. 原理 123456789101112131415org.springframework.boot.autoconfigure.jdbc.DataSourceConfigurationDataSourceConfiguration根据properties文件配置数据源信息，根据环境中有哪些类型，并自动选取类型，也可以自定义类型常见的数据源类型： oracle.ucp.jdbc.PoolDataSource org.apache.commons.dbcp2.BasicDataSource com.zaxxer.hikari.HikariDataSource org.apache.tomcat.jdbc.pool.DataSource自定义类型：protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) &#123; return properties.initializeDataSourceBuilder().type(type).build(); &#125;通过initializeDataSourceBuilder()创建自定义的数据源类型public DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123; return DataSourceBuilder.create(this.getClassLoader()).type(this.getType()).driverClassName(this.determineDriverClassName()).url(this.determineUrl()).username(this.determineUsername()).password(this.determinePassword()); &#125; 4. 启动执行SQL脚本 12345678910配置文件将schema-*.sql放到resource路径下，*代表任意名schema: classpath:schema-*.sql连接的是mysql数据库 platform: mysql 初始化数据源：alwaya全部数据源 initialization-mode: always 数据库脚本文件的分隔符 separator: $ 执行完第一次以后，将此配置删除，否则再次启动项目，会重现创建表格导致启动失败。 5. 操作数据库 123456789101112131415Spring提供的JdbcTemplate操作数据库 @Bean @Primary JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); Template template = properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) &#123; jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds()); &#125; return jdbcTemplate; &#125;只要有数据源，和数据源信息，就可以自动注入直接使用jdbcTemplate 123456789101112@Controllerpublic class HelloController &#123; @Autowired JdbcTemplate jdbcTemplate; @GetMapping(\"/dep\") @ResponseBody public Map get()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(\"select * from dep\"); return maps.get(0); &#125;&#125; 整合Druid1. 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; 2. 配置文件 1234567spring: datasource: url: jdbc:mysql://localhost:3306/ssm0306?useSSL=false&amp;serverTimezone=UTC username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource 3. 配置数据库监控 12345678910111213141516171819202122232425262728293031@Configurationpublic class DruidConfig &#123; @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean getStatViewServlet()&#123; ServletRegistrationBean statViewServlet = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); //配置监控页面登陆的用户名和密码 statViewServlet.addInitParameter(\"loginUsername\",\"admin\"); statViewServlet.addInitParameter(\"loginPassword\",\"admin\"); //配置登陆监控网站的黑白名单 statViewServlet.addInitParameter(\"allow\", \"127.0.0.1\"); statViewServlet.addInitParameter(\"deny\", \"192.168.43.179\"); //是否允许重置 statViewServlet.addInitParameter(\"resetEnable\",\"false\"); return statViewServlet; &#125; @Bean public FilterRegistrationBean getStatFilter()&#123; FilterRegistrationBean statFilter=new FilterRegistrationBean(new WebStatFilter()); //添加过滤地址 statFilter.addUrlPatterns(\"/*\"); //设置过滤规则 statFilter.addInitParameter(\"exclusions\",\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/ *,\"); return statFilter; &#125;&#125; 整合Mybatis1. 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 1.1 注解配置 123456@Mapper@Componentpublic interface DepartmentMapper &#123; @Select(\"select * from dep where depid=#&#123;id&#125;\") public Department selectById(Integer id);&#125; 123public interface DeparmentService &#123; public Department selectById(Integer id);&#125; 123456789@Servicepublic class DepartmentServiceImpl implements DeparmentService &#123; @Autowired DepartmentMapper departmentMapper; @Override public Department selectById(Integer id) &#123; return departmentMapper.selectById(id); &#125;&#125; 123456789@RestControllerpublic class DepController &#123; @Autowired DepartmentServiceImpl departmentService; @GetMapping(\"/deparment/&#123;id&#125;\") public Department getDepartment(@PathVariable(\"id\") Integer id)&#123; return departmentService.selectById(id); &#125;&#125; 1.2 xml配置 1234mybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml指定主配置文件和mapper的映射文件 12345&lt;mapper namespace=\"com.ccut.springboot06.springboot06data.Mapper.DepartmentMapper\"&gt;&lt;select id=\"selectById\" parameterType=\"int\" resultType=\"com.ccut.springboot06.springboot06data.Bean.Department\"&gt; select * from dep where depid=#&#123;id&#125;&lt;/select&gt;&lt;/mapper&gt; 注意： @Mapper 配置类为mapper类 @MapperScan(value = “扫描包名”) 整合JPA导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件 12345678910111213spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm0306?useSSL=false&amp;serverTimezone=Asia/Shanghai username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource jpa: hibernate: #自动生成表 ddl-auto: update #控制台显示Sql show-sql: true 实体类 12345678910111213141516@JsonIgnoreProperties(value = &#123; \"hibernateLazyInitializer\", \"handler\" &#125;)@Entity@Table@Datapublic class User &#123; //指定主键 @Id //主键自增长 @GeneratedValue(strategy= GenerationType.IDENTITY) private Integer id; //指定列 @Column private String username; @Column private String password;&#125; Dao 123public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; Service 1234public interface UserService &#123; public User SelectUserById(Integer id);&#125; 123456789@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserRepository userRepository; @Override public User SelectUserById(Integer id) &#123; return userRepository.getOne(id); &#125;&#125; Controller 12345678910@RestControllerpublic class MyController &#123; @Autowired UserServiceImpl userService; @GetMapping(\"/user/&#123;id&#125;\") public User getUser(@PathVariable(\"id\") Integer id)&#123; User one = userService.SelectUserById(id); return one; &#125;&#125; JPA导入Repository两种方式 123456789101112131415/** * 方式1 * 继承JpaRepository给出实体类，以及主键类型 */public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125;/** * 方式2 * 继承给出实体类，以及主键类型 */@RepositoryDefinition(domainClass = User.class,idClass = Integer.class)public interface UserRepository &#123;&#125;","pubDate":"Wed, 31 Mar 2021 07:57:18 GMT","guid":"https://augus-liuzhi.github.io/2021/03/31/springboot整合数据/","category":""},{"title":"SpringCloudAlibaba","link":"https://augus-liuzhi.github.io/2021/03/02/SpringCloudAlibaba/","description":"","pubDate":"Tue, 02 Mar 2021 06:44:59 GMT","guid":"https://augus-liuzhi.github.io/2021/03/02/SpringCloudAlibaba/","category":""},{"title":"Redis","link":"https://augus-liuzhi.github.io/2021/02/19/redis/","description":"RedisRedis简介基于内存运行，并支持持久化，高性能的NoSql数据库，redis中的数据大部分都是存储在内存中，适合存储频繁访问数据量比较少的数据。 Redis特点 支持数据持久化 支持多种数据结构 支持数据备份 安装 Centos7下安装redis-6.0.6 12345$ wget http://download.redis.io/releases/redis-6.0.6.tar.gz$ tar xzf redis-6.0.6.tar.gz$ cd redis-6.0.6$ make MALLOC=libc$ make install make install 将redis安装目录下src目录中生成的一列可执行文件拷贝到/usr/local/bin,类似于放到环境变量中，可以在任意目录使用redis命令 启动redis 前台启动：redis-server 后台启动：redis-server &amp; 指定配置文件启动：redis-server redis.conf &amp; 关闭redis kill -9 pid redic-cli shutdown 客户端链接Redisredis-cli redis-cli -h 127.0.0.1 -p 6379 退出客户端 exit quit 基本常识 测试Redis性能 1$ redis-benchmark 查看redis是否正常运行 1234$ redis-cli127.0.0.1:6379&gt; pingPONG显示PONG则为正常 查看redis服务器统计信息 12345$ redis-cli#查看所有信息127.0.0.1:6379&gt; info#查看指定信息127.0.0.1:6379&gt; info [信息段] redis的数据库实例 作用类似于mysql的数据库实例，redis中的数据库实例只能由redis服务来创建和维护，开发人员没有权限修改和创建数据库实例，默认情况下，redis会自动创建16个数据库实例，并且给这些数据库实例进行编号，从0开始，一直到15，通过使用编号来使用数据库，可以通过配置文件，指定redis自动创建数据库的个数，redis每个数据库实例本身占用的存储空间是很少的，所以也不会造成太多浪费。redis客户端默认使用0号库，可以使用select index切换数据库。 查询数据中有几条数据：dbsize 查询数据库中所有的key：key * 清空当前数据库：flushdb 清空所有数据库：flshall 查看redis中的配置信息：config get * 查看redis中指定信息：config get [port] 数据结构字符串 列表 集合 哈希 有序集合 操作命令 redis中有关key的操作命令 keys 通配符 ：查看数据库中key keys * 查看数据库中所有的key keys k* 查看数据库中所有k开头后面有0个或多个字符的key keys k? 查看数据库中K开头，后面仅有一个字符的key keys k[0-9] 查看数据库中k开头，后面仅有一个字符，包含0-9的字符 判断key是否存在数据库中 exists key 如果存在返回1，如果不存在返回0 移动k到指定数据库 move key index key 为指定key index为指定的数据库 查看key的剩余ttl时间 ttl keyname 返回值 -2 key不存在 返回值-1 当前key未设置ttl时间 设置最大生存ttl时间 EXPIRE keyname ttl时间 查看key的数据类型 type keyname 重命名key rename oldkey newkey 删除key del keyname String操作命令设置指定key的值(如果key已经存在，会覆盖以前的value) set key value 获取指定key的值 get key 追加指定key的value(返回追加之后的字符串的长度，如果key不存在，则新创建一个key value) append key value 获取指定key的长度 strlen key 指定key+1运算 incr key 指定key加指定增量运算 incr key increment 指定key-1运算 decr key 指定key减指定减量运算 decrby key decrment 加减运算必须是数值 字符串截取 getrange key startindex endindex 修改部分字符串 setrange key startindex value 设置值的同时设置最大生命周期 setex key second value 当key不存在时设置值,key存在则设置失败 setnx key value 批量设置数据 mset key1 v1 key2 v2 key3 v3 批量获取key的值 mget k1 k2 k3 批量设置key不存在时再设置,有一个失败，全部失败 msetnx list操作命令单个key,多个有序的value,最左侧是表头，最右侧是表尾。每个元素都有下标，从0开始，也可以用负数表示，从表尾开始，元素的在列表中的顺序，由放入顺序决定。 将1个或多个值放入往表头插入 lpush key v1 v2 v3 获取列表中指定区间下标的元素 将1个或多个值放入往表尾插入 rpush key v1 v2 v3 删除表头的第一个元素并返回该元素 lpop key 删除表尾的元素，并返回该元素 rpop key 获取列表的长度 llen key 通过索引获取列表的值 lindex key index 移除并获取列表的第一个元素 blpop key timeout 移除并获取列表的最后一个元素 brpop key timeout 在列表的元素前或后插入元素 linsert key before/after 指定元素 value 给已存在的列表元素 rpushx key value 移除列表中某些数据 lrem key count value count&gt;0 从列表左侧移除count个数据 count&lt;0从列表右侧移除count个数据 修剪列表，删除不在区间之内的元素 LRANGE key startindex endindex Set操作命令单key有多个无序的value,一个key有多个value,value之间没有顺序，并且不能重复 将一个或多个存储到set sadd key value 获取指定集合中的元素 SMEMBERS key 判断元素是否存在集合中,存在返回1，不存在返回0 SISMEMBER key value 获取集合的长度 SCARD key 移除指定集合中的一个或多个元素,返回成功移除的个数 srem key vlaue value value 随机获取一个或多个元素 srandmember key count 随机移除一个或多个元素 spop key count 将一个集合的元素移动到另一个集合 smove source destination value 求差集key1中有，key2中没有 sdiff key1 key2…… 获取集合的交集 sinter key1 key2 获取集合的并集 sunion key1 key2 hash操作命令单key:field-value 将一个或多个单key:field-value设置到哈希表中 hset stu1001 id 1001 获取指定哈希表中的指定filed的值 hget key filed 批量获取哈希表中filed的值 hmget key filedname1 filedname2…… 获取指定哈希表所有filed和value hgetall key 删除哈希表中一个filed或多个filed hdel key filedname1 filedname2 获取哈希表中所有filed的个数 hlen key 判断哈希表中是否存在某一个filed hexists key files 获取哈希表中所有filed hkeys key 获取哈希表中所有的value hvals key 对指定哈希表中指定filed值进行整数加法运算 hincreby key filed increment 对指定哈希表中指定filed值进行浮点数加法运算 hincrebyfloat key filed increment 设置filed-value,当其不存在时设置 hsetnx key filed value Zset操作命令有序集合,元素有序，且不能重复，zset每个元素都会关联一个分数，分数可以重复，redis通过分数的大小进行排序，有序集合都有顺序，每个元素都有一个下标，和list排序规则不一样，list是放入顺序，zset是分数大小排序。 将一个或多个memeber及其分数值加入有序集合 zadd key score value score value 获取指定有序集合中指定下标区间的元素 zrange key srartindex endindex withscores 获取指定分数区间的有序集合的元素 zrangebyscore key min max withscores 删除指定有序集合元素 zrem key value 获取有序集合中元素的个数 zcard zset01 获取指定有序集合中指定的元素排名 zrank key value,排名从0开始 获取指定分数区间的有序集合的个数 zcount key startscore endscore 获取指定元素的分数 zscore key vlaue redis配置文件网络配置 port: 指定redis服务所使用的端口，默认使用6379 bind: 配置客户端连接redis服务时，所使用的ip地址 redis-cli -h 192.168.43.179 -p 6379 tcp-keepalieve：连接保活策略 常规配置 loglevel:配置日志级别，开发阶段配置debug,上线配置notcing和warning logfile:指定日志文件，redis运行过程会输出一些日志信息，默认情况信息会输出到控制台，我们可以使用logfile配置 database 16：默认配置16个数据库实例 安全配置 requirepass：设置redis服务时，所使用的密码，默认不使用。此参数protected-mode=yes时才起作用。 一旦设置密码验证，客户端连接redis服务时，必须使用密码连接，redis-cli -a pwd -h ip -p port redis持久化redis是内存数据库，他把数据存储到内存中，高效访问的同时带来了安全问题–宕机导致数据丢失，redis提供了持久化策略，适当的时候把内存的数据持久化到硬盘，每次redis服务启动时，都可以把磁盘上的数据再次加载到内存中使用。 RDB策略：在指定时间间隔内，redis服务执行指定次数写操作，会触发一次持久化操作。默认使用。 save second change 多少秒，进行多少次写操作，触发持久化。 dbfilename：持久化文件名称 dir : ./ 持久化文件保存目录 缺点：最后写的数据可能会丢失，不能完全持久化。 AOF策略：采用操作日志来记录每一次写操作。每次redis服务启动时，都会执行一遍操作。效率低，默认不开启。 appendonly ：配置是否开启AOF策略 appendfilename：配置操作日志文件 小结：根据数据的特点决定开启哪种策略，一般情况开启rdb足够 事务事务：把一组数据库写操作放到一起执行，保证操作的原子性，要么同时成功，要么同时失败。 redis事务，允许把一组redis命令放在一起执行，把命令进行序列化，按照顺序依次执行，保证部分原子性。 multi:标记一个事务的开启 exec:执行队列中事务 redis事务只能保证部分原子性，一组命令中，进入事务队列如果发生错误，则该事务的所用命令都不执行，保证事务的原子性。 一组命令中，进入队列过程正常，但是在执行队列任务命令发生了错误，则只会影响该命令的错误，不会影响其他命令执行，所以不能保证事务的原子性。 discard：放弃压入队列的命令。清楚所有已经压入队列中的命令，结束整个事务。 watch：监控某一个key-vlaue,当事务执行过程中，key-value发生改变，则事务放弃执行，否则正常执行。 unwatch : 放弃监控所有键 消息发布与订阅redis订阅频道，消息的发布者往频道上发布消息，所有订阅频道的客户端都能收到消息。 subscribe：订阅一个或多个频道消息 subscribe ch1 ch2，psubscribe也可以订阅，订阅的频道名支持通配符。 publish : 将消息发送到指定频道。 主从复制主少从多，主写从读，读写分离，主写同步复制到从。 搭建一主而从 搭建3台redis服务，用一个redis模拟三台redis服务，修改redis的配置文件，提供三份配置文件。 分别启动三个redis服务 查看redis服务的角色，info 先往6379写数据，三台redis服务相互独立，互不影响。 设置主从关系，设置6379主机，6380，6381从机 全量复制：主从关系确定，会将主机上已有的数据全部复制到从机。 增量复制 : 主机写数据，会自动同步到从机 主写从读，读写分离：6380和6381上写数据报错。 主机宕机：关闭6379服务，从机原地待命。 主机恢复：无影响 从机宕机：关闭6380服务，主机少一个从机，其他从机不变。 从机恢复：必须重新设置主从关系 从机上位：关闭主机，断开主从关系，SLAVEOF no one,重新设置主从关系 原主机恢复：可恢复成主机，也可以变成主机，从机也可以有从机，一台主机有多个从机，一个从机也可以有多个从机，主机数据会依次传递数据。 哨兵模式 搭建一主二从集群架构 提供一个哨兵配置文件 : redis_sentinel.conf 启动哨兵服务 主机宕机，哨兵自动选举从机上位 之前主机恢复","pubDate":"Fri, 19 Feb 2021 02:30:26 GMT","guid":"https://augus-liuzhi.github.io/2021/02/19/redis/","category":""},{"title":"微服务Gateway","link":"https://augus-liuzhi.github.io/2021/02/02/GateWay/","description":"Gateway SpringCloud Gateway 使用的webflux中的reactor-netty响应式编程组件，底层使用的Netty通讯框架 路由 断言 过滤","pubDate":"Tue, 02 Feb 2021 01:49:34 GMT","guid":"https://augus-liuzhi.github.io/2021/02/02/GateWay/","category":""},{"title":"Hystrix","link":"https://augus-liuzhi.github.io/2021/01/28/Hystrix/","description":"HYSTRIX服务降级服务器压力剧增，根据当前服务和流量对一些服务和页面进行有策略的降级，来保证服务器的高可用。 当出现问题时，它直接返回一个提前准备好的fallback(退路)错误处理信息，这样虽然提供了一个有损的服务但是保证了整个系统的稳定性和可用性。 服务熔断为了防止整个系统雪崩，暂停对该服务的调用。 熔断VS降级相同点： 目标一致都是从可用性和可靠性出发，为了防止系统崩溃 用户体验类似，最终都是让用户体验到某些功能暂时不可用 不同点： 触发原因不同，服务熔断是下游服务故障导致的，服务降级是保证服务的高可用 服务限流秒杀高并发等操作，为了保证服务不被大量请求冲垮，通过限制请求速度来保护系统","pubDate":"Thu, 28 Jan 2021 05:50:43 GMT","guid":"https://augus-liuzhi.github.io/2021/01/28/Hystrix/","category":""},{"title":"Ribbon","link":"https://augus-liuzhi.github.io/2021/01/26/Ribbon/","description":"RibbonRibbon客户端负载均衡工具","pubDate":"Tue, 26 Jan 2021 05:53:05 GMT","guid":"https://augus-liuzhi.github.io/2021/01/26/Ribbon/","category":""},{"title":"服务发现Consul","link":"https://augus-liuzhi.github.io/2021/01/25/Consul/","description":"ConsulconsulConsul是一个服务网格解决方案，它提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。这些特性中的每一个都可以根据需要单独使用，也可以一起用于构建全服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。领事船与一个简单的内置代理，使一切工作的开箱即用，但也支持第三方代理集成，如特使。 key featuresService Discovery Health Checking KV Store Secure Service Communication Multi Datacenter 启动命令 1docker run -d -p 8500:8500/tcp --name consulconsul consul agent -server -ui -bootstrap-expect=1 -client=0.0.0.0","pubDate":"Mon, 25 Jan 2021 07:48:55 GMT","guid":"https://augus-liuzhi.github.io/2021/01/25/Consul/","category":""},{"title":"ZooKeeper","link":"https://augus-liuzhi.github.io/2021/01/25/Zookeeper/","description":"Zookeeper","pubDate":"Mon, 25 Jan 2021 06:03:20 GMT","guid":"https://augus-liuzhi.github.io/2021/01/25/Zookeeper/","category":""},{"title":"微服务注册与发现中心Eureka","link":"https://augus-liuzhi.github.io/2021/01/22/Eureka/","description":"Eureka1. Eureka简介Eureka是一种基于REST服务，主要用在AWS云，用于定位服务，实现中间层服务器的负载平衡和故障转移。 在微服务中，Eureka是微服务的注册与发现中心，主管服务的注册与发现，使用简单的服务标识符，consumer微服务想要访问provider微服务,不需要修改服务调用的配置文件。 2. Eureka两大组件1.Eureka Server 提供服务注册服务，各个微服务启动后的会在Eureka Server进行服务的注册，Eureka Server会将各个可用微服务节点存储到服务注册表中。 Eureka Server功能 服务注册 服务提供者启动后，会通过Eureka Client向Eureka Server注册信息，Eureka Server会存储该服务信息，Eureka Server内部有两层缓存机制来维护整个注册表。 提供注册表 服务消费者调用服务时，如果Eureka Client没有缓存注册表，会从Eureka Server获取最新的注册表 同步状态 Eureka Client通过注册，心跳机制和Eureka Server同步当前客户端的状态 2.Eureka Client 是一个java客户端，用于简化和Eureka Server交互，客户端同时具有一个内置的，使用轮询算法的负载均衡器。客户端启动后会向Eureka Server发送心跳，默认周期30S,如果Eureka Server在3个心跳周期内(默认90S)没有收到该客户端发送心跳，Eureka Server将会在服务列表删除该节点信息。 3.创建Eureka Server pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213server: port: 7001eureka: instance: hostname: eureka7001.com client: #是否向注册中心注册自己 register-with-eureka: false #是否从Eureka Server获取注册实例信息 fetch-registry: false #设置注册中心地址 service-url: defaultZone: http://eureka7001.com:7001/eureka 主启动类 12345678@SpringBootApplication#开启Eureka Server服务@EnableEurekaServerpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class,args); &#125;&#125; 4. 创建Eureka Client pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 1234567891011spring: application: name: cloud-order-serviceserver: port: 8888eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka 主启动 12345678@SpringBootApplication#开启Eureka Client客户端@EnableEurekaClientpublic class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; 3. Eureka架构 Eureka Server：表示注册中心集群 us-east-xxx：表示集群所在的区域 Application Service：表示服务提供者 Application Client：表示服务消费者 Eureka Client：表示Eureka客户端 4. Eureka原理eureka server可以集群部署，多个节点之间会进行（异步方式）数据同步，保证数据最终一致性，Eureka Server作为一个开箱即用的服务注册中心，提供的功能包括：服务注册、接收服务心跳、服务剔除、服务下线等。需要注意的是，Eureka Server同时也是一个Eureka Client，在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server进行拉取注册表、服务注册和发送心跳等操作。 5. 自我保护默认情况下，如果 Eureka Server 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。 Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 Eureka 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。 1eureka.server.enable-self-preservation=true 6. Eureka和Zookeeper对比CAP理论一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 两者区别zookeeper优先保证CP，当服务发生故障会进行leader的选举，整个期间服务处在不可用状态，如果选举时间过长势必会大幅度降低性能，另外就用途来说zookeeper偏向于服务的协调，当然含有注册中心的作用。 eureka优先保证AP, 即服务的节点各个都是平等的，没有leader不leader一说， 当服务发生故障时，其余的节点仍然可以提供服务，因此在出现故障时，性能表现优于zookeeper，但是可能会造成数据不一致的情况。 Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。","pubDate":"Fri, 22 Jan 2021 06:33:55 GMT","guid":"https://augus-liuzhi.github.io/2021/01/22/Eureka/","category":""},{"title":"SpringCloud","link":"https://augus-liuzhi.github.io/2021/01/20/SpringCloud-md/","description":"springcloud环境搭建 创建项目 名称为springcloud002，删除SRC文件夹，隐藏无关紧要的其他文件。 ​ 工程下只有POM.xml文件。 修改pom.xml文件 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springcloud002&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--父项目传递依赖--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--指定依赖版本号--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.cloud-version&gt;Hoxton.SR9&lt;/spring.cloud-version&gt; &lt;spring.boot-version&gt;2.3.5.RELEASE&lt;/spring.boot-version&gt; &lt;/properties&gt; &lt;!--父项目管理依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.boot-version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud-version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;/project&gt; ​ springcloud和springboot版本的选择参见官网。 ​ https://spring.io/projects/spring-cloud#learn ​ 添加子工程 通过maven创建Module ​","pubDate":"Wed, 20 Jan 2021 08:44:15 GMT","guid":"https://augus-liuzhi.github.io/2021/01/20/SpringCloud-md/","category":""},{"title":"RabbitMQ","link":"https://augus-liuzhi.github.io/2021/01/14/RabbitMQ/","description":"工作模式简单模式 P : 生产者，发送消息 queue : 队列 C : 消费者，接收消息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class publisher &#123; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\");//设置虚拟机 //3.获取Connection Connection connectionPub=factory.newConnection(); //4.获取channel Channel channel=connectionPub.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"hello\",true,false,false,null); //6.发送消息 /* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数: exchange:交换机,简单模式默认为”“ routingKey:路由名称,简单模式默认和队列名字一致 props:配置信息 body:发送消息的内容 */ String body=\"hello rabbitMQ\"; channel.basicPublish(\"\",\"hello\",null,body.getBytes()); //7.释放资源 channel.close(); connectionPub.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class consumer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connection=factory.newConnection(); //4.获取channel Channel channel=connection.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"hello\",true,false,false,null); //6 接收消息 /* (String queue, boolean autoAck, Consumer callback) */ DefaultConsumer defaultConsumer=new DefaultConsumer(channel)&#123; /** * 回调方法，当收到消息后会自动执行 * @param consumerTag 标识 * @param envelope 获取一些信息 * @param properties 配置信息 * @param body 真实数据 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"consumerTag\"+consumerTag); System.out.println(\"Exchange\"+envelope.getExchange()); System.out.println(\"RoutingKey\"+envelope.getRoutingKey()); System.out.println(\"properties\"+properties); System.out.println(\"body\"+new String(body)); &#125; &#125;; channel.basicConsume(\"hello\",true,defaultConsumer); &#125;&#125; work queue工作队列模式work queus 与简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个对列的消息 应用场景： 任务过重或者任务过多情况下使用工作队列提高任务处理速度 C1 C2都是消费者 一个队列对应多个消费者，消费者之间对于同一消息是竞争关系 两个消费者对于任务过重或者任务过多情况下使用工作队列提高任务处理速度 P 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class work_queues &#123; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connectionPub=factory.newConnection(); //4.获取channel Channel channel=connectionPub.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"work_queues\",true,false,false,null); //6.发送消息 /* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数: exchange:交换机,简单模式默认为”“ routingKey:路由名称,workqueue模式默认和队列名字一致 props:配置信息 body:发送消息的内容 */ //发送多条消息 for (int i = 1; i &lt;= 10; i++) &#123; String body=\"hello rabbitMQ\"+i; channel.basicPublish(\"\",\"work_queues\",null,body.getBytes()); &#125; //7.释放资源 channel.close(); connectionPub.close(); &#125;&#125; C1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class work_queues1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connection=factory.newConnection(); //4.获取channel Channel channel=connection.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"work_queues\",true,false,false,null); //6 接收消息 /* (String queue, boolean autoAck, Consumer callback) */ DefaultConsumer defaultConsumer=new DefaultConsumer(channel)&#123; /** * 回调方法，当收到消息后会自动执行 * @param consumerTag 标识 * @param envelope 获取一些信息 * @param properties 配置信息 * @param body 真实数据 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body\"+new String(body)); &#125; &#125;; channel.basicConsume(\"work_queues\",true,defaultConsumer); &#125;&#125; C2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class work_queues2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connection=factory.newConnection(); //4.获取channel Channel channel=connection.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"work_queues\",true,false,false,null); //6 接收消息 /* (String queue, boolean autoAck, Consumer callback) */ DefaultConsumer defaultConsumer=new DefaultConsumer(channel)&#123; /** * 回调方法，当收到消息后会自动执行 * @param consumerTag 标识 * @param envelope 获取一些信息 * @param properties 配置信息 * @param body 真实数据 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body\"+new String(body)); &#125; &#125;; channel.basicConsume(\"work_queues\",true,defaultConsumer); &#125;&#125; Pub/Sub订阅模式 在订阅模式中，多了一个Exchange角色,多个消费者接收不同队列的信息 Exchange类型： fanout广播 Direct:定向 Topic通配符 生产者 12345678910111213141516171819202122232425262728293031323334353637383940public class pubsubMode &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.channel声明交换机 String exchangeName=\"firstExchange\"; /** * (String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments) */ channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,true,false,false,null); //6.channel声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(\"queue3\",true,false,false,null); channel.queueDeclare(\"queue4\",true,false,false,null); //7.交换机绑定队列 channel.queueBind(\"queue3\",exchangeName,\"\",null); channel.queueBind(\"queue4\",exchangeName,\"\",null); //8.发送消息 String hello=\"hello,RabbitMQ1111\"; channel.basicPublish(exchangeName,\"\",null,hello.getBytes()); //9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 1234567891011121314151617181920212223242526272829303132333435363738public class pubsubModeCousumer1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setVirtualHost(\"virtual\"); factory.setPort(5672); //3.创建连接 Connection connection = factory.newConnection(); //4.创建channel Channel channel = connection.createChannel(); String exchangeName=\"firstExchange\"; channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,true,false,false,null); //5.声明队列 String queue3=\"queue3\"; /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(queue3,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; channel.basicConsume(queue3,true,defaultConsumer); &#125;&#125; 消费者2 1234567891011121314151617181920212223242526272829303132333435public class pubhubModeConsumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setVirtualHost(\"virtual\"); factory.setPort(5672); //3.创建连接 Connection connection = factory.newConnection(); //4.创建channel Channel channel = connection.createChannel(); //5.声明队列 String queue4=\"queue4\"; /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(queue4,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; super.handleDelivery(consumerTag, envelope, properties, body); System.out.println(\"body \"+new String(body)); &#125; &#125;; channel.basicConsume(queue4,true,defaultConsumer);&#125;&#125; Routing路由模式 队列和交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey(路由key) 消息的发送发在向Exchange发送消息的时候也要指定消息的RoutingKey Exchange不再把消息交给每一个绑定的队列，而是根据消息的RoutingKey进行判断，只有队列的routingKey和消息的RoutingKey保持一致才会接收到消息 生产者 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RoutingModelPublisher &#123; private static final String EXCHANGE_NAME = \"direct_logs\"; private static final String QUEUE_NAME1 = \"RoutingQueue1\"; private static final String QUEUE_NAME2 = \"RoutingQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.channel声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT,true,false,false,null); //6.channel声明队列 channel.queueDeclare(QUEUE_NAME1,true,false,false,null); channel.queueDeclare(QUEUE_NAME2,true,false,false,null); //7.交换机绑定队列 channel.queueBind(QUEUE_NAME1,EXCHANGE_NAME,\"RoutingKey1\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"RoutingKey2\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"RoutingKey3\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"RoutingKey4\"); //8.发送消息 String data1=\"RoutingKey1从队列1来\"; String data2=\"RoutingKey2从队列2来\"; String data3=\"RoutingKey3从队列2来\"; String data4=\"RoutingKey4从队列2来\"; String data5=\"RoutingKey5从队列2来\"; channel.basicPublish(EXCHANGE_NAME,\"RoutingKey1\",null,data1.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data2.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data3.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data4.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data5.getBytes()); //9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 1234567891011121314151617181920212223242526272829303132333435363738public class RoutingModelConsumer1 &#123; private static final String QUEUE_NAME1 = \"RoutingQueue1\"; private static final String QUEUE_NAME2 = \"RoutingQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(QUEUE_NAME1,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; /** * (String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) */ channel.basicConsume(QUEUE_NAME1,defaultConsumer); &#125;&#125; 消费者2 1234567891011121314151617181920212223242526272829303132333435public class pubhubModeConsumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setVirtualHost(\"virtual\"); factory.setPort(5672); //3.创建连接 Connection connection = factory.newConnection(); //4.创建channel Channel channel = connection.createChannel(); //5.声明队列 String queue4=\"queue4\"; /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(queue4,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; super.handleDelivery(consumerTag, envelope, properties, body); System.out.println(\"body \"+new String(body)); &#125; &#125;; channel.basicConsume(queue4,true,defaultConsumer);&#125;&#125; Topics通配符模式生产者 12345678910111213141516171819202122232425262728293031323334353637383940public class TopicModelPublisher &#123; private static final String EXCHANGE_NAME = \"Topic_logs\"; private static final String QUEUE_NAME1 = \"TopicQueue1\"; private static final String QUEUE_NAME2 = \"TopicQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.channel声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC,true,false,false,null); //6.channel声明队列 channel.queueDeclare(QUEUE_NAME1,true,false,false,null); channel.queueDeclare(QUEUE_NAME2,true,false,false,null); //7.交换机绑定队列 channel.queueBind(QUEUE_NAME1,EXCHANGE_NAME,\"#.error\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"*.order\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"*.*\"); //8.发送消息 String data1=\"my.error\"; String data2=\"123456.order\"; String data3=\"topic\"; channel.basicPublish(EXCHANGE_NAME,\"#.error\",null,data1.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"*.order\",null,data2.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"*.*\",null,data3.getBytes()); //9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 12345678910111213141516171819202122232425262728293031323334353637public class TopicModelConsumer1 &#123; private static final String QUEUE_NAME1 = \"TopicQueue1\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(QUEUE_NAME1,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; /** * (String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) */ channel.basicConsume(QUEUE_NAME1,defaultConsumer); &#125;&#125; 消费者2 12345678910111213141516171819202122232425262728293031323334353637public class TopicModelConsumer2 &#123; private static final String QUEUE_NAME2 = \"TopicQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(QUEUE_NAME2,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; /** * (String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) */ channel.basicConsume(QUEUE_NAME2,defaultConsumer); &#125;&#125; 消息的可靠性传递confirm模式 return回退模式 Consumer ACKack(Acknowledge) 确认，表示消费端收到消息后的确认方式。 三种方式： 自动确认 acknowledge=”none” 手动确认 acknowledge=”manual” 根据异常确认 acknowledge=”auto” 配置文件 12345678910111213spring: rabbitmq: username: admin password: admin virtual-host: virtual host: 192.168.43.179 port: 5672 #开启消费者手动确认 listener: direct: acknowledge-mode: manual simple: acknowledge-mode: manual 消费者代码 1234567891011121314151617181920212223242526272829303132333435@Componentpublic class Consumer &#123; @RabbitListener(queues = \"TopicQueue\") public void getMessage(Message message, Channel channel) &#123; try &#123; //1.接收转换消息 System.out.println(new String(message.getBody())); //2.处理业务逻辑 System.out.println(\"处理业务\"); //int i=3/0; //3.签收消息 /** * (long deliveryTag, boolean multiple) * deliveryTag: 标签 * multiple: true签收所有消息 */ //3.1 手动签收消息 channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); System.out.println(\"手动签收成功\"); &#125; catch (Exception e) &#123; //3.2 如果签收失败 /** * (long deliveryTag, boolean multiple, boolean requeue) * requeue:设置为true，消息会重回队列，broker会重新发送给消费者这条消息 */ try &#123; System.out.println(\"手动签收失败，正在回退到队列\"); channel.basicNack(message.getMessageProperties().getDeliveryTag(),true,true); &#125; catch (IOException ioException) &#123; System.out.println(\"消息回退失败\"); &#125; &#125; &#125;&#125; 消息可靠性总结 持久化 exchange持久化 queue持久化 message持久化 生产方确认Confirm 消费方确认ACK Broker高可用 消费端限流 consumer ack为手动确认 配置属性prefetch 1234567891011121314spring: rabbitmq: username: admin password: admin virtual-host: virtual host: 192.168.43.179 port: 5672 listener: direct: acknowledge-mode: manual prefetch: 1 simple: acknowledge-mode: manual prefetch: 1 12345678910@Componentpublic class Consumer &#123; @RabbitListener(queues = \"TopicQueue\") public void getMessage(Message message, Channel channel) throws IOException, InterruptedException &#123; //Thread.sleep(1000); System.out.println(new String(message.getBody())); //channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); &#125;&#125; TTL存活时间，过期时间 当消息到达存活时间，还没有被消费，会被自动清除 RabbitMQ可以对消息设置过期时间，也可以对整个队列设置过期时间 队列消息过期 1234@Bean(\"queue\") public Queue getQueue()&#123; return QueueBuilder.durable(QueueName).ttl(100000).build(); &#125; 消息过期 123456789rabbitTemplate.convertAndSend(Producer.ExchangeName, \"boot.aaaa\", meaaage, new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; //设置消息过期时间 message.getMessageProperties().setExpiration(\"5000\"); return message; &#125; &#125;); 队列消息过期后，会将队列里所有的消息移除 消息过期后，会将在队列顶端的消息进行判断是否过期，过期的话移除 两者同时设置，按照时间最短的 死信队列DLX dead Letter Exchange(死信交换机)，当消息成为dead message后，可以被重新发往另一个交换机，这个交换机就是DLX. 消息成为死信的三种情况 队列消息长度到达限制 消费者拒收消息，basicNack不在把消息重新放入目标队列，requeue=FALSE 原队列存在消息过期设置，消费到达超时时间未被消费。 创建死信交换机和队列 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class Producer &#123; public static final String ExchangeName=\"topicExchange\"; public static final String DlxExchangeName=\"DlxTopicExchange\"; public static final String QueueName=\"TopicQueue\"; public static final String DlxQueueName=\"DlxTopicQueue\"; @Bean(\"dlxExchange\") public Exchange getDlxExchange()&#123; return ExchangeBuilder.topicExchange(DlxExchangeName).durable(true).build(); &#125; @Bean(\"dlxQueue\") public Queue getDlxQueue()&#123; return QueueBuilder.durable(DlxQueueName).build(); &#125; @Bean public Binding getDlxBinding(@Qualifier(\"dlxQueue\")Queue dlxQueue,@Qualifier(\"dlxExchange\")Exchange dlxExchange)&#123; return BindingBuilder.bind(dlxQueue).to(dlxExchange).with(\"#.dlx\").noargs(); &#125; @Bean(\"exchange\") public Exchange getExchange()&#123; return ExchangeBuilder.topicExchange(ExchangeName).durable(true).build(); &#125; @Bean(\"queue\") public Queue getQueue()&#123; return QueueBuilder.durable(QueueName).deadLetterExchange(DlxExchangeName).deadLetterRoutingKey(\"haha.dlx\").ttl(10000).maxLength(10).build(); &#125; @Bean public Binding getBinding(@Qualifier(\"queue\")Queue queue,@Qualifier(\"exchange\")Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(\"boot.#\").noargs(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class DlxTest &#123; @Autowired RabbitTemplate rabbitTemplate; /** * 发送死信消息 * 1.过期时间 * 2.长度限制 * 3.消息拒收 */ //测试过期时间 @Test public void test()&#123; String letter=\"我是消息\"; rabbitTemplate.convertAndSend(Producer.ExchangeName,\"boot.haha\",letter); &#125; //测试长度限制 @Test public void lengthTest()&#123; String letter=\"我是消息\"; for (int i = 0; i &lt; 20; i++) &#123; rabbitTemplate.convertAndSend(Producer.ExchangeName,\"boot.haha\",letter+i); &#125; &#125; //测试消息拒收 @Test public void rejectTest()&#123; String letter=\"拒收消息\"; rabbitTemplate.convertAndSend(Producer.ExchangeName,\"boot.haha\",letter); &#125;&#125; 123456789101112131415161718//测试消息拒收的消费者@Componentpublic class RejectConsumer &#123; @RabbitListener(queues = \"TopicQueue\") public void getMessage(Message message, Channel channel) &#123; try &#123; System.out.println(\"执行业务\"); int i=3/0; channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); &#125;catch (Exception e)&#123; try &#123; System.out.println(\"拒收消息\"); channel.basicNack(message.getMessageProperties().getDeliveryTag(),true,false); &#125; catch (IOException ioException) &#123; System.out.println(\"回退失败\"); &#125; &#125; &#125;&#125; 死信交换机和死信队列和普通的没有区别 当消息称为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列 消息称为死信的三种情况 消息长度限制 消息达到过期时间 消费者拒收消息 延迟队列延迟队列：消息进入队列后不会被立即消费，只有达到指定时间才会被消费。 TTL+死信队列实现延迟队列 日记与监控默认日志存放：/var/log/rabbitmq/ 消息追踪rabbitmqctl trace_on rabbitmq-plugins enable rabbitmq_tracing 应用问题消息可靠性保障 消息幂等性保障 集群搭建","pubDate":"Thu, 14 Jan 2021 10:47:43 GMT","guid":"https://augus-liuzhi.github.io/2021/01/14/RabbitMQ/","category":""},{"title":"Thymeleaf","link":"https://augus-liuzhi.github.io/2021/01/13/Thymeleaf/","description":"","pubDate":"Wed, 13 Jan 2021 08:13:58 GMT","guid":"https://augus-liuzhi.github.io/2021/01/13/Thymeleaf/","category":""},{"title":"单链表","link":"https://augus-liuzhi.github.io/2021/01/12/单链表/","description":"链表的结构数据域+指针域 头指针指向链表的第一个节点的位置。 头节点链表第一个节点前额外设置的一个节点，数据域不存放数据，指针域指向第一个节点的指针（存储位置），引入头节点使得开始节点可以和其他的元素一样，方便进行删除和插入操作。 单链表的基本操作增 add删 delete改 update查 find插 insert 创建节点123456789101112131415/** * 创建一个节点类 * @param &lt;String&gt; */public class Node&lt;String&gt; &#123; //数据域 public String data; //指针域 public Node&lt;String&gt; next; //有参构造函数 public Node(String data, Node&lt;String&gt; next) &#123; this.data = data; this.next = next; &#125;&#125; 初始化链表123456789101112131415161718public class SingleLinkedList &#123; //头节点 private Node head; //首元节点，链表中真正第一个元素 private Node first; //链表长度 int listSize; //初始化链表 public boolean initList()&#123; //链表长度为0 listSize=0; //头指针指向首元节点 first=new Node(null,null); head=new Node(null,first); return true; &#125;&#125; 其他操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//判断单链表是否为空 public boolean isEmpty()&#123; if(listSize==0)&#123; return true; &#125; return false; &#125; //获取节点 public Node&lt;String&gt; getNode(int i)&#123; if(i&lt;0||i&gt;=listSize)&#123; throw new IllegalArgumentException(\"非法参数\"); &#125; Node&lt;String&gt; currNode=head; for(int j=0;j&lt;i;j++)&#123; currNode= currNode.next; &#125; return currNode; &#125; //在末尾添加元素 public void add(Node&lt;String&gt; node)&#123; getNode(listSize-1).next=node; listSize++; &#125; //删除i位置的节点，并返回删除的数据。 public String remove(int i)&#123; if(i==listSize-1)&#123; String s=getNode(i).data; getNode(i-2).next=null; return s; &#125; Node&lt;String&gt; node=getNode(i-1); String s=node.next.data; node.next=node.next.next; return s; &#125; //在i位置插入新节点 public void insert(int i,String a)&#123; Node&lt;String&gt; preNode=getNode(i-1); Node&lt;String&gt; newNode=new Node&lt;&gt;(a,null); newNode.next=preNode.next; preNode.next=newNode; listSize++; &#125; //获取i位置的数据 public String getData(int i)&#123; return getNode(i).data; &#125; //为i位置元素重新赋值 public void setData(int i,String newData)&#123; getNode(i).data=newData; &#125; //返回链表节点的个数 public int length()&#123; return listSize; &#125; //清空链表 public void clear()&#123; initList(); &#125; //打印链表 public void print()&#123; for (int i=0;i&lt;listSize;i++)&#123; System.out.println(getNode(i).data); &#125; &#125; //查找链表中是否有元素e public boolean contains(String s)&#123; Node currNode=head.next; while (currNode.next!=null)&#123; if(currNode.data.equals(s))&#123; return true; &#125; currNode=currNode.next; &#125; return false; &#125;","pubDate":"Tue, 12 Jan 2021 06:26:48 GMT","guid":"https://augus-liuzhi.github.io/2021/01/12/单链表/","category":""},{"title":"SpringBoot-Web开发","link":"https://augus-liuzhi.github.io/2021/01/01/SpringBoot-Web开发/","description":"SpringBoot-Web开发1 简单功能分析1.1 静态资源目录springBoot默认将类路径下的/static (or /public or /resources or /META-INF/resources)作为静态资源目录，静态资源只要放在以上目录，访问路径为localhost:8080/+静态资源名，就可以直接访问静态资源。 当静态资源名和controller包的映射名一致时，优先进行controller进行处理，当请求进来时，先去找controller看看能不能处理，如果controller处理不了，再交给静态资源处理，这是因为静态资源它的映射也是/**，一般默认使用static作为存放静态资源的路径。可以通过访问前缀进行区分 1.2 静态资源访问前缀springboot默认访问静态资源是没有前缀的，访问路径直接localhost:8080/+静态资源名 设置访问前缀 1234#配置访问前缀spring: mvc: static-path-pattern: /res/** 此时访问路径：localhost:8080/+前缀+静态资源名。 1.3 设置静态资源路径springboot默认是那4个静态资源路径，一旦自定义访问静态资源的路径，其他的将会失效。[meta-inf/resources还是生效why] 设置静态资源路径 1234spring: web: resources: static-locations: classpath:/haha 1.4 访问webjars访问webjars时，例如jquery,首先添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 访问路径为：localhost:8080/webjars/jquery/版本号/静态资源名 1.5 welcome欢迎页index.html存放在默认的静态目录下，或者我们指定的静态文件下，即可默认直达欢迎页面，当我们设置前缀的时候，必须加上前缀才可以访问欢迎页面。 1.6 favicon配置favicon.ico,只需要在静态资源路径放置favicon.ico图片，springboot会自动配置。 1.7 静态资源配置原理 2 请求参数处理表单rest风格rest风格是指以不同的请求方式，来区分用户的增删改查操作，表单提交默认只有post,get请求，通过修改隐藏域的_method参数，可以添加springboot2支持的put,delete,patch请求。 以前增删改查，/addUser,/DeleteUser,/UpdateUser,/SelectUser Rest风格，处理增删改查，url映射统一为/User,用不同的请求方法，进行区分增删改查操作 rest开发步骤 创建表单，修改隐藏域，添加put,delete请求方式 创建Controller,用SpringBoot新注解进行区分请求方式 springboot开启rest风格配置 12345678910111213141516171819&lt;h4&gt;REST风格测试&lt;/h4&gt;&lt;form action=\"/user\" method=\"get\"&gt; &lt;input type=\"submit\" value=\"get测试\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"post测试\"&gt;&lt;/form&gt;添加隐藏域的_method的值，表单必须为post请求才可以&lt;form action=\"/user\" method=\"post\"&gt; &lt;input name=\"_method\" type=\"hidden\" value=\"put\"&gt; &lt;input type=\"submit\" value=\"put测试\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\"&gt; &lt;input name=\"_method\" type=\"hidden\" value=\"delete\"&gt; &lt;input type=\"submit\" value=\"delete测试\"&gt;&lt;/form&gt; 1234567891011121314151617181920//使用不同请求方式的注解，进行区分增删改查@RestControllerpublic class HelloController &#123; @GetMapping(\"/user\") public String helloRest1()&#123; return \"get\"; &#125; @PostMapping(\"/user\") public String helloRest2()&#123; return \"request\"; &#125; @PutMapping(\"/user\") public String helloRest3()&#123; return \"put\"; &#125; @DeleteMapping(\"/user\") public String helloRest4()&#123; return \"delete\"; &#125;&#125; 123456#开启REST风格spring: mvc: hiddenmethod: filter: enabled: true 请求参数注解@PathVariable(“参数名”) 绑定url占位符参数到Controller localhost:8080/user/{占位符1}/{占位符2} 12345678@RestControllerpublic class ParameterController &#123; @GetMapping(\"/variable/&#123;username&#125;/&#123;password&#125;\") public String parameter(@PathVariable(\"username\")String username,@PathVariable(\"password\") String password)&#123; String variable=username+\"--\"+password; return variable; &#125;&#125; @RequestHeader 获取请求头中的数据，通过指定参数，来获取请求头中指定参数的值 1234567@GetMapping(\"/RequestHeader\") public Map ReqHeader(@RequestHeader(\"User-Agent\") String UserAgent,@RequestHeader(\"Accept-Language\") String language)&#123; Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"UserAgent\",UserAgent); map.put(\"Accept-Language\",language); return map; &#125; @RequestParam 获取请求的指定参数，通过制定参数的名称来获取请求参数的值 http://localhost:8080/RequestParam?id=3 123456@GetMapping(\"/RequestParam\") public Map ReqParam(@RequestParam(\"id\")Integer id)&#123; Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); map.put(\"id\",id); return map; &#125; @CookieValue 获取请求的Cookies的值，通过指定参数的值来获取cookies的值 123456@PostMapping(\"/cookies\") public Map getCookies(@CookieValue(value = \"JSESSIONID\",required = false,defaultValue = \"null\") String JSESSIONID)&#123; Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"JSESSIONID\",JSESSIONID); return map; &#125; @RequestBody 该注解可以用来接收从前端传入的json数据 @RequestAttribute 获取request域中指定参数的值 12345678910111213@PostMapping(\"/ReqAt\") public String Reqat(HttpServletRequest httpServletRequest)&#123; HttpServletRequest request=httpServletRequest; request.setAttribute(\"user\",\"root\"); return \"forward:/requestAttribute\"; &#125; @PostMapping(\"/requestAttribute\") @ResponseBody public Map getrequestAttribute(@RequestAttribute(\"user\")String user)&#123; Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"User\",user); return map; &#125; ​ @MatrixVariable","pubDate":"Fri, 01 Jan 2021 12:46:43 GMT","guid":"https://augus-liuzhi.github.io/2021/01/01/SpringBoot-Web开发/","category":""},{"title":"Lombok","link":"https://augus-liuzhi.github.io/2020/12/30/lombok/","description":"Lombok简介lombok通过注解消除POJO的冗余代码，如POJO的Setter,Getter,ToString等方法，使用对应的注解，可以在编译的时候生成相应的方法，减少代码量的书写。 Lombok的安装Maven安装123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.14&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 插件安装IDEA-File-Setting-Plugins 搜索lombok,安装后重启IDEA Lombok常用注解123456789101112131415161718构造方法注解@NoArgsConstructor@AllArgsConstructor@RequiredArgsConstructorToString注解@ToStringSetter/Getter注解@Getter@Setter整合注解@Value@DataSetter注解@Builder日志注解@Slf4jEquals和HashCode注解@EqualsAndHashCode Lombok注解的使用@Setter/@Getter 生成对应的setter和getter方法 12345678910111213141516171819202122232425262728使用注解@Getter@Setterpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Integer getPrice() &#123; return price; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125;&#125; @ToString 生成对应的ToString方法 12345678910111213141516171819使用注解@ToStringpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; @Override public String toString() &#123; return \"Car&#123;\" + \"brand='\" + brand + '\\'' + \", price=\" + price + '&#125;'; &#125;&#125; @NoArgsConstructor 生成无参构造方法 123456789101112131415使用注解@NoArgsConstructorpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; public Car() &#123; &#125;&#125; @AllArgsConstructor 生成全部参数的构造方法 1234567891011121314151617使用注解@AllArgsConstructorpublic class Car &#123; String brand; Integer price; &#125;相当于不使用注解public class Car &#123; String brand; Integer price; public Car(String brand, Integer price) &#123; this.brand = brand; this.price = price; &#125;&#125; @RequiredArgsConstructor 生成特定参数的构造方法，此处指生成被final修饰的属性的构造方法，如果没有final修饰的属性，生成的默认是无参构造方法 12345678910111213141516使用注解@RequiredArgsConstructorpublic class Car &#123; final String brand; Integer price; &#125;相当于不使用注解public class Car &#123; final String brand; Integer price; public Car(String brand) &#123; this.brand = brand; &#125;&#125; @Builder 仅生成属性的setter方法 1234567891011121314151617181920使用注解@Builderpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; public void setBrand(String brand) &#123; this.brand = brand; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125;&#125; @Data 整合注解@Data=@Getter+@Setter+@ToString+@EqualsAndHashCode+@RequiredArgsConstructor 适用在pojo上 123456789101112131415161718使用注解@Datapublic class Car &#123; String brand; Integer price;&#125;@Getter@Setter@ToString@EqualsAndHashCode@RequiredArgsConstructorpublic class Car &#123; String brand; Integer price;&#125; @Value 整合注解@Value=@RequiredArgsConstructor+@Getter+@EqualsAndHashCode+@ToString 适合用于类的属性值不更改，只有可读操作 此@Value为lombok包下的，区分Spring包下的@Value注解 1234567891011121314151617使用注解@Valuepublic class Car &#123; String brand; Integer price;&#125;@RequiredArgsConstructor@Getter@EqualsAndHashCode@ToStringpublic class Car &#123; String brand; Integer price;&#125; @Slf4j 自动生成该类的log静态变量 1234567891011121314使用注解@Slf4jpublic class Car &#123; public static void main(String[] args) &#123; log.info(\"hello\"); &#125;&#125;相当于不使用注解public class Car &#123; private static Logger log= LoggerFactory.getLogger(Car.class); public static void main(String[] args) &#123; log.info(\"hello\"); &#125;&#125; @EqualsAndHashCode 生成对应的equals方法和hashCode方法 123456789101112131415161718192021222324252627282930使用注解@EqualsAndHashCodepublic class Car &#123; String brand; Integer price; &#125;相当于不使用注解public class Car &#123; String brand; Integer price; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Car car = (Car) o; if (brand != null ? !brand.equals(car.brand) : car.brand != null) return false; return price != null ? price.equals(car.price) : car.price == null; &#125; @Override public int hashCode() &#123; int result = brand != null ? brand.hashCode() : 0; result = 31 * result + (price != null ? price.hashCode() : 0); return result; &#125;&#125;","pubDate":"Wed, 30 Dec 2020 07:50:08 GMT","guid":"https://augus-liuzhi.github.io/2020/12/30/lombok/","category":""},{"title":"","link":"https://augus-liuzhi.github.io/2020/11/16/Mysql技术内幕/","description":"一 MySql体系结构和存储引擎1.1 定义数据库和实例数据库：物理操作系统文件或其他形式文件的类型的集合。 实例：Mysql数据库由后台线程以及一个共享内存区组成。（数据库实例操作数据库文件） 实例和数据库的对应关系是一一对应的，一个实例对应一个数据库，一个数据库对应一个实例。集群情况下，存在一个数据库被多个实例操作。 1.2 Mysql体系结构 连接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 缓冲组件 插件式存储引擎 物理文件 Mysql区别于其他数据库的特点：插件式的表存储引擎 存储引擎是基于表的，不是数据库 1.3 Mysql存储引擎 InnoDB存储引擎 提供了对数据库ACID的事务支持，并且提供了行级锁和外键约束。 它的目标：处理大数据容量的数据库系统。 Mysql的默认引擎 MyISAM存储引擎 不提供事务支持，也不支持行级锁和外键约束 NDB存储引擎 Memory存储引擎 所有数据都在内存中，数据的处理速度快，但是安全性不高。 Archive存储引擎 Federated存储引擎 Maria存储引擎 1.4 各存储引擎的比较 MyISAM Innodb 存储结构 每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB 存储空间 MyISAM可被压缩，存储空间较小 InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 可移植性、备份及恢复 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 文件格式 数据和索引是分别存储的，数据.MYD，索引.MYI 数据和索引是集中存储的，.ibd 记录存储顺序 按记录插入顺序保存 按主键大小有序插入 外键 不支持 支持 事务 不支持 支持 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） 表级锁定 行级锁定、表级锁定，锁定力度小并发能力高 SELECT MyISAM更优 INSERT、UPDATE、DELETE InnoDB更优 select count(*) myisam更快，因为myisam内部维护了一个计数器，可以直接调取。 索引的实现方式 B+树索引，myisam 是堆表 B+树索引，Innodb 是索引组织表 哈希索引 不支持 支持 全文索引 支持 不支持 1.5 连接Mysql 连接Mysql操作是一个连接进程和Mysql数据库实例进行通信。（本质：进程通信） 进程通信方式： TCP/IP套接字 如：客户端和服务器不在同一个服务器上，在windows下，可以使用 12&gt; mysql -h 服务器地址 -u 用户名 -p 密码&gt; 命名管道和共享内存 UNIX套接字 二 InnoDB存储引擎","pubDate":"Mon, 16 Nov 2020 11:15:45 GMT","guid":"https://augus-liuzhi.github.io/2020/11/16/Mysql技术内幕/","category":""},{"title":"LeetCode","link":"https://augus-liuzhi.github.io/2020/11/16/LeetCode/","description":"11.12922.按照奇偶排序数组 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 123456789101112131415161718class Solution &#123; public int[] sortArrayByParityII(int[] A) &#123; int[] B=new int[A.length]; int c=0; int d=1; for (int i=0;i&lt;A.length;i++)&#123; if(A[i]%2==0)&#123; B[c]=A[i]; c+=2; &#125; else &#123; B[d]=A[i]; d+=2; &#125; &#125; return B; &#125;&#125; 解题思路 新创建一个数组，作为排序后的数组返回。 遍历数组中的每个数据元素，判断是奇数还是偶数。 如果是奇数，将其赋值给新数组的下标为1，切下标值加2，依次进行。 如果是偶数，将其赋值给新数组的下标为0，且下标值加2，依次进行。 字符串中字符出现的频次 给定一个字符串，统计字符串中各个字符出现的次数，如String s=”abbcccdddd”,则a出现一次，b出现两次，c出现3次，d出现4次。 1234567891011121314public HashMap countChar(String s)&#123; HashMap&lt;Character,Integer&gt; hashMap=new HashMap&lt;Character,Integer&gt;(); for (int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); Integer count = hashMap.get(c); if(count==null)&#123; hashMap.put(c,1); &#125; else &#123; hashMap.put(c,count+1); &#125; &#125; return hashMap; &#125; 解题思路 把字符串变成字符数组。 出现的字符作为key,出现的次数为value，将其存入HashMap中。 count作为计数，也就是作为hashmap中的value,出现重复的key,直接count+1,覆盖上次的value 11.13遍历数组12345678910111213141516public class ArrayTraversal &#123; public static void main(String[] args) &#123; Integer[] items = &#123; 1, 2, 3 &#125;; //1.for循环 for (int i=0;i&lt;items.length;i++)&#123; System.out.print(items[i]); &#125; //2.foreach循环 for (int a:items) &#123; System.out.print(a); &#125; //3.lambda表达式 Arrays.asList(items).forEach(System.out::print); Arrays.asList(items).forEach(item-&gt;System.out.print(item)); &#125;&#125; 7 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 输入：123 输出：321 12345678910111213public int reverse(int x)&#123; int y=0; while (x!=0)&#123; if (y &gt; 214748364 || y &lt; -214748364)&#123; return 0; &#125; else&#123; y=y*10+x%10; x=x/10; &#125; &#125; return y; &#125; 解题思路 定义一个参数y,作为反转后的数字返回 X/10操作得到去除个位数的数字，X%10得到个位数 y&gt; 214748364 || y &lt; -214748364 指定参数为整形范围 11.16","pubDate":"Mon, 16 Nov 2020 11:15:33 GMT","guid":"https://augus-liuzhi.github.io/2020/11/16/LeetCode/","category":""},{"title":"并发编程","link":"https://augus-liuzhi.github.io/2020/10/28/并发编程/","description":"创建和运行线程方法1:继承Thread类12345678910111213141516171819202122232425262728293031public class ExtendThread extends Thread&#123; static Logger logger=Logger.getLogger(ExtendThread.class); @Override public void run() &#123; logger.info(\"running\"); &#125; public static void main(String[] args) &#123; ExtendThread thread=new ExtendThread(); thread.setName(\"线程T\"); thread.start(); logger.info(\"running\"); &#125;&#125;//使用匿名内部类public class Test &#123; public static void main(String[] args) &#123; final Logger logger=Logger.getLogger(Test.class); //创建线程 Thread thread=new Thread()&#123; @Override public void run() &#123; logger.info(\"111\"); &#125; &#125;; //设置线程名 thread.setName(\"线程T\"); //启动线程 thread.start(); logger.info(\"2222\"); &#125;&#125; 方法2:实现Runnable接口12345678910111213public class Run implements Runnable &#123; static Logger logger=Logger.getLogger(Run.class); public void run() &#123; logger.info(\"1111\"); &#125; public static void main(String[] args) &#123; Run run=new Run(); Thread thread=new Thread(run); thread.setName(\"线程T\"); thread.start(); logger.info(\"22222\"); &#125;&#125; 12使用lambda表达式 Runnable runnable1= () -&gt; logger.info(\"1111\"); 方法3:实现Callable接口1234567891011121314public class Call implements Callable&lt;String&gt;&#123; Logger logger=Logger.getLogger(Call.class); @Override public String call() throws Exception &#123; String s=\"123\"; logger.info(s); return s ; &#125; public static void main(String[] args) &#123; Call call=new Call(); FutureTask futureTask=new FutureTask(call); new Thread(futureTask).start(); &#125;&#125;","pubDate":"Wed, 28 Oct 2020 07:29:51 GMT","guid":"https://augus-liuzhi.github.io/2020/10/28/并发编程/","category":""},{"title":"","link":"https://augus-liuzhi.github.io/2020/10/23/MySql/","description":"数据库相关概念 DB: 数据库，保存一组有组织的数据的容器 DBMS : 数据库管理系统，就是数据库管理软件，用来管理DB中的数据 SQL : 结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点 将数据放在表中，再将表放到数据库中 一个数据库可以有多个数据表，表名具有唯一性 表有一些特性 表每列称为一个字段，表中数据按行存储。 Mysql产品的介绍和安装Mysql服务的启动和停止1234567方式1：计算机--&gt;右键管理--&gt;服务和应用程序--&gt;服务--&gt;mysql方式2：管理员身份cmd命令net stop mysqlnet start mysql MySql的登陆和退出1234567win--&gt;cmd登陆mysql -h 主机名 -P 端口号 -u 用户名 -p 密码退出：exit或者ctrl+c Mysql常见命令1234567891011121314151617显示数据库：show databases;进入test数据库：use test;查看数据表：show tables;创建数据表：create table 表名（列名 列类型，列名 列类型，……）;查看当前所在数据库：select database();查看某个数据库中的数据表：show tables from mysql;查看数据表的结构：desc students;查看表的内容 ： select * from 表名；查看当前数据库版本：select version(); Mysql语法规范12345671. 不区分大小写，建议关键字大写，表名、列名小写2. 每条命令用分号结尾3. 每条命令根据需要，可以进行缩进换行4. 注释 单行注释：#注释文字 单行舒适：-- 注释文字 多行注释：/* 注释文字 */ Mysql查询基础查询1234567891011121314151617181920212223242526272829303132333435363738394041#进阶1：基础查询/*语法：select 查询列表 from 表名;查询列表可以是：表中字段、常量值、表达式、函数查询结果是一个虚拟表格*/#打开库USE student;#1. 查询表中的单个字段SELECT NAME FROM student;#2. 查询表中的多个字段SELECT NAME,age,xuehao FROM student;#3. 查询表中所有字段SELECT * FROM student;#4. 查询常量SELECT 1;SELECT &apos;hdsdhsadihis&apos;;#5. 查询表达式SELECT 100*98;#6. 查询函数SELECT VERSION();#7. 起别名/*便于理解区分重名字段*/# 方式1SELECT 100*98 AS 结果;SELECT NAME AS 姓名 FROM student;# 方式2 SELECT NAME 姓名2 FROM student;#8. 去重SELECT DISTINCT chengji FROM student;#9. +号的作用,运算符/*1. 一方为null，结果为null2. 两边都是数值，做加法运算3. 一方数值，一方字符，将字符转换成数值再加，如果转换失败，则就是0+数值*/SELECT CONCAT(NAME,IFNULL(chengji,0)) AS 姓名和成绩 FROM student; 进阶查询123456789101112131415161718192021222324252627282930313233343536373839404142#进阶2：条件查询/*语法： select 查询列表 from 表名 where 筛选条件;分类： 1. 条件表达式筛选 条件运算符：＞ ＜ ＝ ！＝ ＜＞ ＞＝ ＜＝ 2. 逻辑表达式筛选 逻辑运算符：＆＆ ｜｜ ！ and or not 3. 模糊查询 between and like in is null*/#1. 按照条件表达式筛选#查找成绩大于80fen的SELECT * FROM student WHERE chengji&gt;80;#查找年龄不等于20岁的姓名和年龄SELECT NAME,age FROM student WHERE age!=20;SELECT NAME,age FROM student WHERE age&lt;&gt;20;#2. 按照逻辑表达式筛选#查找成绩成绩在60-90之间的姓名和成绩SELECT NAME,chengji FROM student WHERE chengji&gt;60 AND chengji&lt;90;#3. 模糊查询#1. like 一般和通配符搭配使用 %任意多个字符 _任意单个字符#查找姓名中包含字符a的学生信息SELECT * FROM student WHERE NAME LIKE &apos;a%&apos;;#查询第一个字符为w，第3个字符为nSELECT * FROM student WHERE NAME LIKE &apos;w_n_&apos;;#查询姓名中第二个字符为下划线SELECT * FROM student WHERE NAME LIKE &apos;_\\_%&apos;;#\\转译SELECT * FROM student WHERE NAME LIKE &apos;_$_%&apos; ESCAPE &apos;$&apos;;#escape 转译#2. between and#查找成绩在60到90之间,包含60 90，闭区间，不能颠倒顺序SELECT * FROM student WHERE chengji BETWEEN 60 AND 90;#3. in 通俗来讲可以理解为=SELECT * FROM student WHERE chengji IN(60,80,90);#4. is null 查找null值 is not nullSELECT * FROM student WHERE chengji IS NOT NULL;#安全等于 &lt;=&gt; 可以判断null,也可以判断普通数值SELECT * FROM student WHERE chengji&lt;=&gt;NULL;SELECT * FROM student WHERE chengji&lt;=&gt;100; 排序查询12345678910111213141516171819#进阶3：排序查询/*select 列表 from 表名 【where 筛选条件】order by 排序列表1 【asc|desc】,排序列表2【asc|desc】,如果不写默认是升序排序列表可以是单个字段，多个字段，表达式，函数，别名order by 放在查询语句最后面，limit除外！！！*/#1. 按照某一项排序SELECT * FROM student ORDER BY chengji ASC;SELECT * FROM student ORDER BY chengji DESC;#2. 按照筛选条件排序SELECT * FROM student WHERE chengji&gt;60 ORDER BY xuehao;#3. 按照表达式或者别名排序SELECT *,IFNULL(chengji,0)*12 AS 总成绩 FROM student ORDER BY IFNULL(chengji,0)*12 DESC;SELECT *,IFNULL(chengji,0)*12 AS 总成绩 FROM student ORDER BY 总成绩 ASC;#4. 按照姓名的长度显示姓名和成绩SELECT LENGTH(NAME) AS 姓名长度,NAME,chengji FROM student ORDER BY LENGTH(NAME) DESC;#5. 先按照成绩排序，再按照学号排序SELECT * FROM student ORDER BY chengji DESC,xuehao DESC; 常见函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#进阶4：常见函数/*概念：类似java方法，将一组逻辑语句封装在方法体中，对外暴露方法名好处：1. 隐藏了实现细节 2. 提高代码复用性调用：select 函数（实参列表） 【from 表】;特点：函数名,函数功能,分类：1. 单行函数 concat length ifnull 2. 分组函数 做统计使用又称为统计函数【聚合函数】*/#1.字符函数 #length 获取参数值的字符个数SELECT LENGTH(&apos;john&apos;);SELECT LENGTH(&apos;哈哈&apos;);#concat 拼接字符SELECT CONCAT(NAME,chengji) FROM student;#upper(),lower()大小写SELECT UPPER(&apos;sjdj&apos;);SELECT LOWER(&apos;ASD&apos;);#substr、substring#截取指定索引处后面所有字符SELECT SUBSTR(&apos;abcd&apos;,2);#截取从指定索引处指定字符长度的字符SELECT SUBSTR(&apos;abcdefg&apos;,1,3);#姓名中首字母大写，其余字母小写SELECT CONCAT(UPPER(SUBSTR(NAME,1,1)),&apos;_&apos;,LOWER(SUBSTR(NAME,2))) FROM student;#instr 返回子串第一次出现的索引，找不到返回值0SELECT INSTR(&quot;abcdefg&quot;,&apos;efg&apos;);#trim 去前后空格SELECT TRIM(&apos; ggjj &apos;);SELECT TRIM(&apos;a&apos; FROM &apos;aaaaa369aaaaa&apos;);#lpad 左填充指定长度字符 rpad 右填充指定长度SELECT LPAD(&apos;abcdefg&apos;,2,&apos;*&apos;);SELECT RPAD(&apos;asdc&apos;,5,&apos;*&apos;);#replace 替换所有指定字符SELECT REPLACE(&apos;abcdefg&apos;,&apos;g&apos;,&apos;G&apos;);#2. 数学函数#roundSELECT ROUND(1.65);SELECT ROUND(1.657,2);#ceil 向上取整 返回大于等于参数的最小整数#floor 向下取整 返回小于等于参数的最大整数SELECT CEIL(1.00);SELECT FLOOR(2.3);#truncate 截断SELECT TRUNCATE(1.66666,1);#mod 取余SELECT MOD(10,3);SELECT 10%3;#日期函数#now 返回当前系统时间SELECT NOW();#curdate 返回当前系统日期，不反回时间SELECT CURDATE();#cuetime 返回当前时间，不返回日期SELECT CURTIME();#获取指定部分的年，月，日，小时，分钟，秒SELECT YEAR(NOW());SELECT YEAR(NOW() AS 年 ;SELECT MONTH(NOW()) AS 数字月;SELECT MONTHNAME(NOW()) AS 英文月;#str_to_date 将字符转换成指定格式SELECT STR_TO_DATE(&apos;2022-2-17&apos;,&apos;%Y-%m-%d&apos;);#date_format 将日期转换成字符SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;);#4. 其他函数SELECT VERSION();SELECT DATABASE();SELECT USER();#5. 流程控制函数#if函数SELECT IF(10&gt;5,&apos;大&apos;,&apos;小&apos;);#case函数/*用法：case 要判断字段或表达式when常量1 then 语句1； when常量2 then 语句2；else 要显示的值n,或语句；end */#case使用1SELECT IFNULL(chengji ,0) AS 成绩,CASE FLOOR(chengji/10)WHEN 10 THEN &apos;A&apos;WHEN 9 THEN &apos;A&apos;WHEN 8 THEN &apos;B&apos;WHEN 7 THEN &apos;C&apos;ELSE &apos;D&apos;END AS 评定FROM student ORDER BY chengji DESC;#case使用2SELECT IFNULL(chengji,0) AS 成绩,CASEWHEN chengji&gt;90 THEN &apos;A&apos;WHEN chengji&gt;80 THEN &apos;B&apos;ELSE &apos;C&apos;ENDAS 评定FROM student ORDER BY chengji DESC; 分组函数12345678910111213141516171819#分组函数/*功能：用作统计使用，又称为聚合函数或统计函数或分组函数分类：sum 和 avg平均值 参数类型整型 ，忽略null值max min count计算个数 参数任何类型支持，忽略null值可以和distinct搭配，实现去重运算count 函数 计算非null值的个数和分组函数一同查询字段有限制,要求是group by后的字段*/SELECT SUM(chengji) FROM student;SELECT AVG(chengji) FROM student;SELECT MAX(chengji) FROM student;SELECT COUNT(chengji) FROM student;SELECT SUM(chengji) 和,COUNT(chengji) 一共,AVG(chengji)平均值 FROM student;SELECT SUM(DISTINCT chengji),SUM(chengji) FROM student;SELECT COUNT(*) FROM student;SELECT COUNT(chengji) FROM student;SELECT AVG(chengji),chengji FROM student;","pubDate":"Fri, 23 Oct 2020 01:14:12 GMT","guid":"https://augus-liuzhi.github.io/2020/10/23/MySql/","category":""},{"title":"CSS","link":"https://augus-liuzhi.github.io/2020/10/15/CSS/","description":"","pubDate":"Thu, 15 Oct 2020 13:03:33 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/CSS/","category":""},{"title":"HTML","link":"https://augus-liuzhi.github.io/2020/10/15/HTML/","description":"","pubDate":"Thu, 15 Oct 2020 13:03:03 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/HTML/","category":""},{"title":"JS","link":"https://augus-liuzhi.github.io/2020/10/15/JS/","description":"JavaScript基本语法变量声明123var num;声明变量num=100;document.write(num); 变量类型 变量的基本类型有Number,String,Boolean,Undefined,Null 1234567声明数字var a=1;声明字符串var a=\"hello\"或者var a='hello'声明一个布尔类型var a=true当一个变量未被初始化的时候，它的值为undefined 引用类型1234var student=&#123;id:1,name:\"张三\",age:20&#125;document.write(student.id);document.write(student.name);document.write(student.age); 数组类型123var a=[1,2,3,4]alert(a[1]);alert(a[a.length-1]); 运算符 名称 运算符 加 + 减 - 乘 * 除 / 求余 % 赋值 = 加等 += 减等 -= 乘等 *= 除等 /= 求余等 %= 与 &amp;&amp; 或 \\ \\ 非 ！ 小于 &lt; 大于 &gt; 小于等于 &lt;= 大于等于 &gt;= 等于 == 不等于 != 自增 ++ 自减 – 三目 ？： 条件分支 if-else switch 循环结构 for while do-while 函数12345function fun(num1,num2)&#123; return num1+num2; &#125;var num=fun(10,20); alert(num); 弹框 alert(“hello”); confirm(“hello”); prompt(“hello”) 1234567var res=confirm(\"是否确定\"); if(res)&#123; alert(\"success\"); &#125; else&#123; alert(\"fail\"); &#125; 12var res=prompt(\"请输入参数\")； alert(res); 事件onclick事件 123456789//点击事件&lt;body&gt; &lt;script type=\"text/javascript\"&gt; function fun()&#123; alert(\"hihi\"); &#125; &lt;/script&gt; &lt;button onclick=\"fun()\"&gt;普通按钮&lt;/button&gt; &lt;/body&gt; onload事件 12 正则表达式修饰符 修饰符 描述 i 忽略大小写 g 全局匹配 m 多行匹配 支持正则表达式的String对象 方法 描述 search 检索与正则表达式相匹配的值 match 找到一个或多个正则表达式的匹配 replace 替换与正则表达式匹配的字符串 split 把字符串分割为字符数组 正则表达式对象的方法 方法 描述 comlile 编译正则表达式 exec 检索字符串中指定的值，返回找到的值，并确定其位置 test 检索字符串中指定的值，返回true或false JavaScript的DOM对象查找HTML元素123456//通过id查找html元素document.getElementById(id)//通过标签名找到HTML元素document.getElementsByTagName(name)//通过类名找到HTML元素document.getElementsByClassName(className) 改变HTML的内容1234&lt;p id=\"p1\"&gt;Hello world&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById(\"p1\").innerHTML=\"abcd\"; &lt;/script&gt; CSS变化123456789101112&lt;style type=\"text/css\"&gt; #p1&#123;width: 200px;height:200px; background-color: yellow;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"p1\"&gt;Hello world&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var p1=document.getElementById(\"p1\"); p1.style.width=\"400px\"; p1.style.backgroundColor=\"blue\"; p1.style.height=\"400px\"; &lt;/script&gt; DOM事件123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; #p1&#123; width: 200px; height:400px; background-color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; function fun()&#123; var p1=document.getElementById(\"p1\"); var x,y,z; x=Math.ceil(Math.random()*255); y=Math.ceil(Math.random()*255); z=Math.ceil(Math.random()*255); p1.style.backgroundColor=\"rgb(\"+x+\",\"+y+\",\"+z+\")\"; &#125; &lt;/script&gt; &lt;p id=\"p1\"&gt;hello&lt;/p&gt; &lt;button onclick=\"fun()\"&gt;普通按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; addEventListener12345678910111213141516171819202122232425262728293031323334353637383940414243444546addEventListener(event, listener, useCapture)event事件listener函数useCpature事件的传递方式（冒泡或者捕获）默认是冒泡事件的执行顺序冒泡：内——》外捕获：外——》内//同一元素绑定一个事件//同一元素绑定多个事件//多个元素绑定同一事件&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; #p1&#123; width: 200px; height:400px; background-color: yellow; &#125; #p2&#123; width: 200px; height:400px; background-color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"p1\"&gt;&lt;/div&gt; &lt;div id=\"p2\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function fun1()&#123; alert(\"事件1\"); &#125; function fun2()&#123; alert(\"事件2\"); &#125; var p1=document.getElementById(\"p1\"); p1.addEventListener(\"click\", fun1()); p1.addEventListener(\"mouseover\",fun2()); var p2=document.getElementById(\"p2\"); p2.addEventListener(\"click\", fun1()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器BOMwindow的尺寸","pubDate":"Thu, 15 Oct 2020 13:02:29 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/JS/","category":""},{"title":"JSP","link":"https://augus-liuzhi.github.io/2020/10/15/JSP/","description":"","pubDate":"Thu, 15 Oct 2020 13:01:53 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/JSP/","category":""}]}