{"title":"LiuZhi'Blog","description":"my blog","language":"en","link":"https://augus-liuzhi.github.io","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","lastBuildDate":"Tue, 06 Oct 2020 15:16:42 GMT","generator":"hexo-generator-json-feed","webMaster":"兔崽子","items":[{"title":"SpringMVC","link":"https://augus-liuzhi.github.io/2020/10/06/SpringMVC/","description":"SpringMVC概述1.1 SpringMVC概述 Spring 为展现层提供的基于MVC设计理念的优秀的web框架，是目前最主流的MVC框架。 Spring 3.0以后超越strusts2,称为最优秀的MVC框架。 SpringMVC通过一套MVC注解，让pojo成为处理请求的控制器，而无需实现任何接口。 支持REST风格的URL请求。Restful 采用了松散耦合可插拔组件，比MVC架构更有扩展性和灵活性 1.2 SpringMVC是什么轻量级，基于MVC的web层的应用框架，偏前端而不是业务逻辑层，Spring框架的后续产品 1.3 SpringMVC能干什么支持与Spring框架集成，如：（Ioc,aop） 支持REST风格 支持灵活的URL到页面控制器的映射 1.4 SpringMVC组件DispatcherServlet：前端控制器 Controller : 处理器/页面控制器 HandlerMapping : 请求映射处理器 View Resolver : 视图解析器 LocalResolver : 本地化，国际化 MultipartResolver : 本地上传解析器 HandlerExceptionResolver : 异常处理器 1.5 SpringMVC搭建 1 导入jar包 2 配置web.xml前端控制器 作用：加载springmvc配置文件，此时的配置文件有默认的位置和名称，默认位置在WEB—INF下，默认名称是-servlet.xml 例如：springMVC-servlet.xml 当加载了配置文件，SpringMVC就会根据扫描组件，找到控制层 12345678&lt;servlet&gt;&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3 创建一个pojo,在此类上加上@contriller注解，SpringMVC就会将此类作为控制层加载，让其请求响应 4 在控制层中，需要在方法上设置@RequestMapping(value=”hello”),springmvc就是通过此注解将请求路径与控制层的方法进行匹配，此时请求路径为localhost:8080/projectName/xxx 5 处理请求的方法会返回一个字符串（视图名称），通过配置文件中的视图解析器进行页面跳转 方式：prefix+视图名称+suffix,此为页面跳转路径 RequestMapping注解2.1概念 requestmapping 请求映射处理器，主要功能就是把接收到的url请求，根据相应的映射，转发到另一个url 2.2 标注位置@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。 限定类 123456789@Controller@RequestMapping(\"/home\")public class TestController &#123; @RequestMapping(value=\"/test\") public String test() &#123; System.out.println(\"get\"); return \"success\"; &#125;&#125; 访问时必须访问localhost:8080/projectName/home/test 限定方法 12345678@Controllerpublic class TestController &#123; @RequestMapping(value=\"/test\") public String test() &#123; System.out.println(\"get\"); return \"success\"; &#125;&#125; 访问时必须访问localhost:8080/projectName/test 2.3 映射请求方式1234@RequestMapping(value=\"/test\",method=RequestMethod.PUT) 修改操作@RequestMapping(value=\"/test\",method=RequestMethod.GET) 查询操作 @RequestMapping(value=\"/test\",method=RequestMethod.POST) 添加操作@RequestMapping(value=\"/test\",method=RequestMethod.DELETE) 删除操作 2.4 映射请求参数12@RequestMapping(value=\"/test\", params= &#123;\"username\",\"age!=12\"&#125;)指定有两个参数，一个username，一个age并且age不能等于12 2.5 映射请求头1@RequestMapping(value=\"/test\", headers= &#123;\"Accept-Language=zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\"&#125;) 2.6 支持Ant路径123456@RequestMapping(value=\"/*/test\") 任意字符匹配访问路径：http://localhost:8080/SpringMVCdemo02/sdsd/test@RequestMapping(value=\"/abc?/test\") 任意单个字符匹配访问路径：http://localhost:8080/SpringMVCdemo02/abcd/test@RequestMapping(value=\"/**/test\") 任意多层路径匹配访问路径：http://localhost:8080/SpringMVCdemo02/abcd/sdsd/test 2.7 映射请求占位符12345678@Controllerpublic class TestController &#123; @RequestMapping(value=\"/test/&#123;id&#125;\") public String test(@PathVariable(\"id\")int id) &#123; System.out.println(id); return \"success\"; &#125;&#125; { }的形式进行占位符 使用@PathVariable(“参数名”)来接收参数 访问路径： 12&gt;http://localhost:8080/SpringMVCdemo02/test/10010&gt; REST3.1 概念表现层状态转化，是目前最流行的一种互联网软件架构 简单来说就是put,post,delete,get进行资源的创建，删除，查找，修改 3.2 使用方式首先在web.xml中配置过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 然后再写四种请求 123456789101112131415&lt;a href=\"testREST/1001\"&gt;rest&lt;/a&gt;&lt;form action=\"testREST\" method=\"post\"&gt;&lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt;&lt;form action=\"testREST\" method=\"post\"&gt;&lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"&gt;&lt;input type=\"submit\" value=\"put\"&gt;&lt;/form&gt;&lt;form action=\"testREST\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"&gt;&lt;input type=\"submit\" value=\"delete\"&gt;&lt;/form&gt; Controller响应四种请求 123456789101112131415161718192021222324@RequestMapping(value=\"/testREST/&#123;id&#125;\",method=RequestMethod.GET) public String getUserById(@PathVariable(\"id\")Integer id) &#123; System.out.println(\"GET,id=\"+id); return \"success\"; &#125; @RequestMapping(value=\"/testREST\",method=RequestMethod.POST) public String insert() &#123; System.out.println(\"post\"); return \"success\"; &#125; @RequestMapping(value=\"/testREST\",method=RequestMethod.PUT) public String update() &#123; System.out.println(\"put\"); return \"success\"; &#125; @RequestMapping(value=\"/testREST\",method=RequestMethod.DELETE) public String delete() &#123; System.out.println(\"delete\"); return \"success\"; &#125; 流程：首先必须得是post请求，然后设置一个_method此 _method的value为put或者delete,触发请求后，首先web.xml中过滤器首先进行过滤，当看到有 _method时，并且里面有put或者delete，会把post请求转换成相应的put或者post请求，如果不符合条件直接是post请求，如果满足直接就是相对应的方法请求 处理请求数据4.1 从客户端获取数据1234567@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(String username,String password,String age) &#123; System.out.println(\"username=\"+username); System.out.println(\"password=\"+password); System.out.println(\"age=\"+age); return \"success\"; &#125; 在处理请求方法的时候，只需要在方法中加入形参，并且和要传入的参数名保持一致就可以直接接收数据 4.2 参数名称和形参名称不一致1234567@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(@RequestParam(value=\"name\",required=false,defaultValue=\"111\")String username,String password,String age) &#123; System.out.println(\"username=\"+username); System.out.println(\"password=\"+password); System.out.println(\"age=\"+age); return \"success\"; &#125; 在处理名称不一致的时候，需要设置@RequestParam(value=”name”）String username进行参数的绑定，就是从前端收到name的值，注解将其绑定在username上，required=true时，此时传递的参数必须得有name这个属性，required=false当为false时，传递的参数的属性值中可以没有name的属性值，defaultVlaue指的是，当这个值null时，会根据defaultvalue的值作为默认值 4.3 处理请求头数据12345@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(@RequestHeader(\"Accept-language\")String AcceptLanguage) &#123; System.out.println(AcceptLanguage); return \"success\"; &#125; @RequestHeader(“Accept-language”)是用来获取请求头中的数据 4.4 获取cookies12345@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(@CookieValue(\"JSESSIONID\")String JSESSIONID) &#123; System.out.println(JSESSIONID); return \"success\"; &#125; 通过注解@CookieValue(“JSESSIONIS”)来获取cookies 4.5 使用pojo作为参数12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(User user) &#123; System.out.println(user); return \"success\"; &#125;&#125; 使用pojo获取客户端数据，实体类的属性名和表单中的属性值一致，而且支持级联关系 4.6 使用原生servlet获取数据12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(HttpServletRequest request) &#123; System.out.println(request.getParameter(\"username\")); return \"success\"; &#125;&#125; 4.7 作用域中放值方式一 12345678910@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public ModelAndView test(User user) &#123; ModelAndView mav=new ModelAndView(); mav.addObject(\"username\", \"root\"); mav.setViewName(\"success\"); return mav; &#125;&#125; 方式二 12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(Map&lt;String,Object&gt; map) &#123; map.put(\"username\", \"admin\");//像作用域中放值 return \"success\"; &#125;&#125; 方式三 12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(Model model) &#123; model.addAttribute(\"username\", \"zhangsan\"); return \"success\"; &#125;&#125; SpringMVC处理数据，保存数据，可以用以上三种方式，不管适应哪种方式，最终都会调用的Model和View封装成一个ModelAndView对象。 视图解析5.1 概述不论控制器返回一个String,ModelAndView,View最终都会返回一个modelandview对象，由视图解析器解析试图，进行页面跳转 5.2 视图类型view作用：处理模型数据，重定向/转发视图 internalResourceView:转发视图 JstlView:转发视图 RedirectView:重定向视图 文件上传6.1 加入jar包 commons-io-1.4.jar 6.2 配置springmvc-servlet.xml 123456789&lt;mvc:annotation-driven/&gt; &lt;!-- 文件上传 ,将客户端上传的文件处理为multipartfile文件 ，此bean的id必须是multipartResolver--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置文件解析器编码，注意：一定要和页面编码保持一致 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt; &lt;!-- 设置最大上传的文件大小 --&gt; &lt;property name=\"maxUploadSize\" value=\"1111111111\"&gt;&lt;/property&gt; &lt;/bean&gt; 6.3 前端页面 123456&lt;form action=\"hello\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件: &lt;input type=\"file\" name=\"uploadfile\"&gt; 上传描述:&lt;input type=\"text\" name=\"description\" &gt; &lt;input type=\"submit\"&gt; &lt;/form&gt;注意：enctype=\"multipart/form-data 6.4 控制层 1234567891011121314@Controllerpublic class TestController &#123; @RequestMapping(value=\"hello\") public String hello(String description,MultipartFile uploadfile,HttpServletRequest request) throws IOException &#123; //获得上传的文件的文件名 String filename=uploadfile.getOriginalFilename(); //获得文件上传的路径 String path=request.getSession().getServletContext().getRealPath(\"/photo\")+File.separator+filename; File file=new File(path); uploadfile.transferTo(file); return \"success\"; &#125;&#125; 拦截器1. 概念SpringMVC的拦截器类似于Servlet的filter过滤器，主要作用是拦截用户的请求做出相应处理。 2. 拦截器类的实现 继承HandlerInterceptorAdapter类 实现HandlerInterceptor接口 12345678910111213141516171819202122232425import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class InterceptorHanddler implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; return false; &#125;&#125; 拦截器类中有3个方法 boolean preHandle() 控制方法执行前，它就开始执行，当返回值为true时，表示放行，当返回值为flase时，表示拦截（即中断后面所有操作） void postHandle() 控制方法调用之后执行，视图解析之前执行，就是return 返回ModelAndView后执行，主要作用就是对模型或者视图进行进一步的修改 void afterCompletion() 该方法在视图解析后执行，类似于finall语句块执行语句，主要进行资源的释放。 3. 单个拦截器的配置12345&lt;!-- 设置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 指定拦截器类就可以了--&gt; &lt;bean class=\"com.baidu.Handdler.InterceptorHanddler\"&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; 4. 单个拦截器执行流程用户–&gt;Controller方法执行前，进行preHandle()，返回值为true–&gt;Controller方法–&gt;Controller执行完毕，进行postHandle()执行–&gt;DispatcherServlet向客户端响应–&gt;afterCompletion() 5. 多个拦截器的配置12345678910111213&lt;!-- 设置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;!-- 设置不包含哪个路径 --&gt; &lt;mvc:exclude-mapping path=\"\" /&gt; &lt;bean class=\"com.baidu.Handdler.FirstInterceptorHanddler\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.baidu.Handdler.SecondInterceptorHanddler\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 6. 多个拦截器的执行流程1234567First: preHandleSecond: preHandleinterceptor已经启用Second: postHandleFirst: postHandleSecond: afterCompletionFirst: afterCompletion 多个拦截器配置时，会按照拦截器的配置顺序进行执行，首先会进行第一个拦截器的preHandle(),当返回值为true时，进行第二个拦截器的preHandle()当返回值为true时，进行第二个拦截器的postHandle，然后进行第一个拦截器的postHandle(),然后进行第二个拦截器的afterCompletion(),最后进行第一个拦截器的afterCompletion 7. 拦截器路径问题/ 的意思是所有文件夹及里面的子文件夹** /*是所有文件夹，不含子文件夹 /是web项目的根目录 /test 拦截以test结尾的路径 /*/.html 拦截以.html结尾的 异常处理1234567891011&lt;!-- 设置异常 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;&lt;!-- 异常默认页面 --&gt;&lt;property name=\"defaultErrorView\" value=\"error\"&gt;&lt;/property&gt;&lt;!-- 异常指定页面 --&gt;&lt;property name=\"exceptionMappings\"&gt;&lt;props&gt;&lt;prop key=\"java.lang.NullPointerException\"&gt;nullpoint&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; SpringMVC执行流程用户发送请求到前端控制器，前端控制器请求映射处理器，映射处理器调用相应的Handle处理器，返回给前端控制器一个执行链（包含处理器对象和拦截器），前端控制器会调用适配器处理器，适配器处理器调用相应的处理器返回给前端控制器一个ModelAndView对象，前端控制器调用视图解析器，返回一个具体的View，前端控制器再渲染这个view响应给客户。","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/SpringMVC/","category":""},{"title":"SpringBoot","link":"https://augus-liuzhi.github.io/2020/10/06/SpringBoot/","description":"一 Spring Boot入门1 springboot简介springboot是为了简化spring开发的一个框架 2 微服务一个应用应该是一组小型服务，可以通过http方式进行沟通 每一个功能元素最终都是可独立替换和独立升级的软件单元 3 SpringBoot环境搭建 导入坐标 123456789101112&lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建springboot启动引导类 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot都有一个启动引导类，在启动引导类添加注解@SpringBootApplication */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125; 创建控制器类 12345678910/** *@RestController等价于@Controller+@ResponseBody */@RestControllerpublic class HelloController &#123; @GetMapping(\"hello\") public String hello()&#123; return \"hello,SpringBoot\"; &#125;&#125; 测试 浏览器：localhost:8080/hello 简化部署 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该插件可以打包应用，直接使用java -jar jar包名就可以执行这个jar包了 4 Hello World探究 父依赖 12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/parent&gt;它的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt;它是真正的管理SpringBoot应用里面的所有依赖的版本 SpringBoot版本仲裁中心： ​ 以后我们导入的依赖默认不需要写版本（没有在的dependencies里面管理的依赖，需要写版本号） 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; Spring-boot-starter：SpringBoot场景启动器 Spring-boot-starter-web：帮我们导入web模块 主程序 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot都有一个启动引导类，在启动引导类添加注解 */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125; @SpringBootApplication :该注解表明该类是SpringBoot主配置类 通过运行该类的main()来启动SpringBoot应用 5 Quickstart Guide 使用initializr创建SpringBootProject,会自动创建一个springboot项目，只需要关注逻辑 Resources文件夹目录结构 static：保存所有静态资源（js css image） templates：保存所有的模板页面（SpringBoot默认jar包嵌入tomcat,默认不支持jsp页面），可以使用模板引擎（freemaker,thymeleaf） application.properties：SpringBoot应用的配置文件，可以修改一些配置 二 配置文件配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的 application.properties application.yml/application.yaml ==配置文件作用==：修改SpringBoot自动配置的默认值 YAML(YAML Ain’t a Markup Language)以数据为中心 YAML 不是一种标记语言 YAML 仍是一种标记语言 YAML配置实例 12server: port: 8000 XML: 123&lt;server&gt; &lt;port&gt;8000&lt;/port&gt;&lt;/server&gt; YAML语法 基本语法 12port: 8080path: /hello ==冒号后面有空格== 值的写法 字面量： ​ Key: Value ​ 字符串默认不用加上单引号或双引号 ​ 双引号：不会转义里面的特殊字符 ​ name: “zhangsan \\n lisi” 输出: zhangsan ​ lisi ​ 单引号：会转义特殊字符 ​ name: ‘zhangsan \\n lisi’ 输出:zhangsan \\n lisi 对象(Map)： ​ Key: Value 1234&gt;friends:&gt; lastname: zhangsan&gt; age: 20&gt; 行内写法 12&gt;friends: &#123;lastname: zhangsan,age: 20&#125;&gt; 数组（List,Set） 用-（空格）值来表示一个元素 12345678&gt;pets:&gt;&gt; - cat&gt;&gt; - dog&gt;&gt; - pig&gt; 行内写法 12&gt;pets: [cat,dog,pig]&gt; 配置文件值注入 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建要被注入的类 1234567891011@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; String name; Integer age; Boolean boss; Map&lt;String,Object&gt; map; List&lt;Object&gt; list; Dog dog;……………………&#125; @Component标注该类成为组件 @ConfigurationProperties(prefix = &quot;person&quot;)标注引入前缀为person的属性值 测试类 123456789@SpringBootTestclass DemoApplicationTests &#123; @Autowired Person person; @Test void contextLoads() &#123; System.out.println(person.toString()); &#125;&#125; @Value属性注入 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; 创建启动器引导类 创建java配置类 12345678910111213141516171819202122@Configuration//加载外部文件@PropertySource(\"classpath:db.properties\")public class jdbcConfig &#123; @Value(\"$&#123;db.driver&#125;\") String driver; @Value(\"$&#123;db.url&#125;\") String url; @Value(\"$&#123;db.username&#125;\") String username; @Value(\"$&#123;db.password&#125;\") String password; @Bean public DataSource dataSource()&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driver); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; &#125;&#125; 创建处理器类 12345678910@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping(\"hello\") public String hello()&#123; System.out.println(\"DataSource =\"+dataSource); return \"hello,SpringBoot\"+dataSource.toString(); &#125;&#125; @Value和@ConfigurationProperties区别 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个一个绑定 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂数据类型 支持 不支持 @PropertySource读取指定的配置文件1234567891011@Component@ConfigurationProperties(prefix = \"person\")@PropertySource(\"classpath:person.properties\")public class Person &#123; String name; Integer age; Boolean boss; Map&lt;String,Object&gt; map; List&lt;Object&gt; list; Dog dog;&#125; @PropertySource（value=路径）注解用来指定读取指定的配置文件，SpringBoot默认读取的配置文件是固定的（application.properties或者application.yml）通过该注解可以可以来读取其他的名称的配置文件，但是仍然需要和@ConfigurationProperties（prefix=”前缀”）注解来配合使用 @ImportResource导入spring配置文件 SpringBoot不识别spring的配置文件，当我们写spring的配置文件时候，需要在SpringBoot的主配置类上使用@ImportResource(location=”路径”)来导入我们所需要的spring配置文件，这样我们才可以在springboot中使用spring配置文件 @Bean给容器添加组件123456789101112** * @Configuration指明当前类为配置类 * 在配置文件中庸&lt;bean&gt;&lt;bean/&gt;添加组件 * 在配置类中用@Bean添加组件 */@Configurationpublic class MyConfig &#123; @Bean(\"configbean\") public SpringBean getSpringBean()&#123; return new SpringBean(); &#125;&#125; 配置文件占位符 随机数 12person.name=root$&#123;random.int&#125;person.list=1,2,3$&#123;random.uuid&#125; 占位符 12person.name=root$&#123;random.int&#125;person.map.k1=v1$&#123;person.name&#125; Profile多环境支持 多profile配置文件 配置文件名可以是application-(profile).properties/yml,需要在住配置文件中激活才可以使用 123&gt;#激活dev的配置，默认使用application.propreties配置文件内容，激活后使用激活的配置文件的配置&gt;spring.profiles.active=dev&gt; yml多文档块 yml支持多文档块，用—来区分文档块 123456789101112131415161718192021&gt;server:&gt; port: 8080&gt;&gt;#激活使用指定的配置pro的配置文件&gt;spring:&gt; profiles:&gt; active: pro&gt;&gt;---&gt;server:&gt; port: 8081&gt;&gt;spring:&gt; profiles: dev&gt;---&gt;server:&gt; port: 8083&gt;spring:&gt; profiles: pro&gt;&gt; 配置文件加载位置优先级优先级由高到低，高优先级会覆盖低优先级的配置，配置内容不同，SpringBoot会互补配置 conf文件，根目录，类路径conf文件，类路径根目录 自动配置原理 springboot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration 1234@EnableAutoConfiguration 利用selector给容器导入一些组件组件：将类路径下的META-INF/spring.factories里面的配置所有的EnableAutoConfiguration的值加入到了容器每一个xxxAutoConfiguration都是容器的一个组件，都加入到容器中，用他们来自动配置，每一个自动配置类进行相应的自动配置功能 精髓： SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有springboot默认写好配置类 再看自动配置类中到底配置哪些组件（只有有我们要用组件有，我们就不需要配置了） 给容器自动配置类添加组件的时候，会从properties类中获取属性，我们可以在配置文件中指定这些属性的值 细节： @Conditional 作用：指定条件成立，才给容器添加组件，配置类里面的内容才生效 扩展注解 1.class条件注解 @ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。 @ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。 2.Bean条件注解 @ConditionalOnBean：当容器中有指定Bean的条件下进行实例化。 @ConditionalOnMissingBean：当容器里没有指定Bean的条件下进行实例化。 3.属性条件注解 @ConditionalOnProperty：当指定的属性有指定的值时进行实例化。 4.Resource条件注解 @ConditionalOnResource：当类路径下有指定的资源时触发实例化。 5.web条件注解 @ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。 @ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。 6.表达式条件注解 @ConditionalOnExpression：基于SpEL表达式的条件判断，当表达式为true的时候，才会实例化一个Bean。 @ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。 @ConditionalOnJndi：在JNDI存在的条件下触发实例化。 @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。 自动配置报告 1debug=true 在主配置文件中开启springboot的debug,使用该代码启用，生效后运行springboot应用会在控制台打印自动配置报告 三 日志日志框架==SpringBoot选用：SLF4j+logback== SlF4j使用SpringBoot属性注入类上使用@ConfigurationProperties 实现SpringBoot配置文件读取和应用 步骤： 创建配置项类jdbcProperties,在该类上使用注解@ConfigurationProperties 123456789101112131415161718192021222324252627282930313233343536/** * ConfigurationProperties从application配置文件中读取配置项 * prefix表示前缀 * 配置类的变量名必须要与前缀之后的配置项名保持相同 */@ConfigurationProperties(prefix = \"db\")public class jdbcProperties &#123; String diverClassName; String url; String username; String password; public String getDiverClassName() &#123; return diverClassName; &#125; public void setDiverClassName(String diverClassName) &#123; this.diverClassName = diverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 将db.properties修改为application.properties 将jdbcProperties对象注入到jdbcConfig中 123456789101112@Configuration@EnableConfigurationProperties(jdbcProperties.class)public class jdbcConfig &#123; @Bean public DataSource dataSource(jdbcProperties db)&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(db.getDiver()); druidDataSource.setUrl(db.getUrl()); druidDataSource.setUsername(db.getUsername()); druidDataSource.setPassword(db.getPassword()); return druidDataSource;&#125; 方法上使用@ConfigurationProperties 12345678@Configurationpublic class jdbcConfig &#123; @Bean @ConfigurationProperties(prefix = \"db\") public DataSource dataSource()&#123; return new DruidDataSource(); &#125;&#125; 此方法采用自动注入，需要将后缀和配置类变量名保持一致 多个yml文件配置配置文件可以使用application.properties以外，还可以使用application.yml或者application.yaml yaml与properties配置文件除了展示形式不相同以外，其他功能和作用都是一样的，在项目中原路读取方式不需要改变 yml配置文件特征 树状层级结构展示配置项 配置项之间如果有关系的话需要分行空两格 配置项如果有值，需要在：之后空一格再写配置值 将application.properties修改为为application.yml 12345db: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/lyb?serverTimezone=UTC username: root password: 123456 2）多个yml配置文件，在SpringBoot中是被允许的，这些配置文件的名称必须为application-***.yml,并且这些配置文件必须在总的application.yml配置文件激活才可以使用 1234#激活配置文件，需要指定其他配置文件的名称spring: profiles: active: 另一个配置文件的-后面的名字 3）如果properties和yml配置文件同时存在springboot项目中，那么这两类配置文件都有效。在两个配置文件中存在同名的配置项会以properties为主 自动配置原理","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/SpringBoot/","category":""},{"title":"Spring","link":"https://augus-liuzhi.github.io/2020/10/06/Spring/","description":"1 Spring概述1.1 Spring是什么？Spring框架是针对bean的生命周期进行管理的轻量级容器（lightweight container）以ioc（控制反转）和aop（面向切片编程）为内核。 1.2 Spring的优势方便解耦，简化开发 AOP编程 声明事务支持 方便程序的测试 方便集成各种优秀框架 降低JavaEE API的使用难度 java源代码经典学习示范 1.3 Spring体系结构Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。 2 spring的第一个核心功能控制反转（IoC）：把对象的创建，赋值，管理工作都交给的容器处理，也就是对象的创建由Ioc容器完成。 控制：创建对象，对象属性的赋值，对象之间的关系管理。 反转：把原来的开发人员创建对象的控制权，转交给Ioc容器来控制 正转：有开发人员通过new 构造方法创建对象，并由开发人员主动控制对象。 Ioc目的(作用)：减少对代码的改动，也能实现不同的功能，实现解耦合。 Ioc的技术实现 ​ DI是Ioc的技术实现 ​ DI：依赖注入，只需要提供对象的名称就可以了，至于对象的创建，查找，赋值都是由容器内部实现的 Spring Ioc实现 Spring使用DI实现了Ioc的功能，spring底层的创建对象，采用了反射机制。 3 一般属性注入Setter-based 依赖注入 实体类 1234567891011121314151617181920212223242526272829package com.baidu.Dao;public class Person &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \"]\"; &#125; &#125; 创建bean 1234&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt; id : bean的唯一标识，通过getBean（）获取对像的时候，通过bean的id来指定具体要获取哪个bean的对象 class ：指定你要创建哪个类bean 注意：该方法主要是通过实体类的setXXX方法实现的，因此实体类必须得有set方法，还要注意属性的命名规范，以免造成找不到该set方法 Constructor-based 依赖注入 实体类 123456789101112131415161718192021222324package com.baidu.Dao;public class Person &#123; private String username; private String password; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; public Person(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \"]\"; &#125; &#125; 创建bean 1234&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"123456\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 构造方法重载 3.1 相同个数参数 1234567891011121314151617181920212223242526272829303132package com.baidu.Dao;public class Person &#123; private String username; private String password; private int age; public Person() &#123; super(); &#125; public Person(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; public Person(String username, int age) &#123; super(); this.username = username; this.age = age; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \", age=\" + age + \"]\"; &#125; &#125; 1234567891011121314151617 &lt;bean id=\"person1\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"123456\" type=\"String\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"person2\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"22\" type=\"int\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;或者 &lt;bean id=\"person1\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"123456\" type=\"String\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"person2\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\" index=\"0\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"2\" index=\"1\" type=\"int\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 通过type来指定该位置的参数类型 index主要来指定参数的顺序 3.2 不同参数个数 不同参数个数构造方法，会自动匹配 4 特殊属性注入4.1 对象注入4.1.1 内部bean方式 1234567891011&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt;&lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;&lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;&lt;property name=\"teacher\" &gt;&lt;bean class=\"com.baidu.Dao.Teacher\"&gt;&lt;property name=\"tusername\" value=\"laoshi\"&gt;&lt;/property&gt;&lt;property name=\"tid\" value=\"1000\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/property&gt;&lt;/bean&gt; 4.1.2 ref引用bean 1234567891011&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt;&lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;&lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;&lt;property name=\"teacher\" ref=\"teacher\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"teacher\" class=\"com.baidu.Dao.Teacher\"&gt;&lt;property name=\"tusername\" value=\"laoshi\"&gt;&lt;/property&gt;&lt;property name=\"tid\" value=\"1001\"&gt;&lt;/property&gt;&lt;/bean&gt; 1注意：内部bean只能通过先访问外部bean然后才能再次访问内部bean，外部bean可以单独使用 4.2 数组注入123456&lt;property name=\"hobby\"&gt;&lt;array&gt; &lt;value&gt;play&lt;/value&gt; &lt;value&gt;games&lt;/value&gt;&lt;/array&gt;&lt;/property&gt; 4.3 List注入1234567&lt;property name=\"list\"&gt;&lt;list&gt; &lt;value&gt;list1&lt;/value&gt; &lt;value&gt;list2&lt;/value&gt; &lt;value&gt;list3&lt;/value&gt;&lt;/list&gt;&lt;/property&gt; 4.4 Map注入1234567&lt;property name=\"map\"&gt;&lt;map&gt; &lt;entry key=\"key1\" value=\"result1\"&gt;&lt;/entry&gt; &lt;entry key=\"key2\" value=\"result2\"&gt;&lt;/entry&gt;&lt;/map&gt;&lt;/property&gt;&lt;/bean&gt; 4.5 Set注入123456&lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 4.6 Properties注入123456&lt;property name=\"properties\"&gt;&lt;props&gt; &lt;prop key=\"pkey1\"&gt;p1&lt;/prop&gt; &lt;prop key=\"pkey2\"&gt;p2&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt; 4.7 实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.baidu.Dao;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Person &#123; private String username; private String password; private int age; private Teacher teacher; private String[] hobby; private List&lt;String&gt; list; private Map&lt;String,String&gt; map; private Set&lt;String&gt; set; private Properties properties; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public Map&lt;String, String&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public Set&lt;String&gt; getSet() &#123; return set; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public String[] getHobby() &#123; return hobby; &#125; public void setHobby(String[] hobby) &#123; this.hobby = hobby; &#125; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; public Person(String username, String password, int age, Teacher teacher) &#123; super(); this.username = username; this.password = password; this.age = age; this.teacher = teacher; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \", age=\" + age + \", teacher=\" + teacher + \", hobby=\" + Arrays.toString(hobby) + \", list=\" + list + \", map=\" + map + \", set=\" + set + \", properties=\" + properties + \"]\"; &#125;&#125; 5 FactoryBean注入5.1 applicationContext.xml1&lt;bean id=\"factory\" class=\"com.baidu.Dao.Myfactory\"&gt;&lt;/bean&gt; 5.2 实体类1234567891011121314151617181920212223package com.baidu.Dao;public class Car &#123; private String bround; private double price; public String getBround() &#123; return bround; &#125; public void setBround(String bround) &#123; this.bround = bround; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return \"Car [bround=\" + bround + \", price=\" + price + \"]\"; &#125; &#125; 5.3 Factory类123456789101112131415161718192021222324252627package com.baidu.Dao;import org.springframework.beans.factory.FactoryBean;public class Myfactory implements FactoryBean&lt;Car&gt; &#123; @Override public Car getObject() throws Exception &#123; Car car=new Car(); car.setBround(\"OOOO\"); car.setPrice(50.0); return car; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // TODO Auto-generated method stub return Car.class; &#125; @Override public boolean isSingleton() &#123; // TODO Auto-generated method stub return false; &#125;&#125; 5.4 测试类1234567891011public class Test &#123; public static void main(String[] args) &#123; //1 初始化容器 ApplicationContext applicationContext=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 通过getBean获取对象 Object object = applicationContext.getBean(\"factory\"); System.out.println(object); &#125;&#125; 5.5 测试结果1Car [bround=OOOO, price=50.0] 6 Bean的作用域6.1 singleton（单例模式）1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"singleton\"&gt; scope来指定作用域 singleton作为单例模式 单例模式下，只会创建一次对象，且在容器初始化的时候就已经执行了 6.2 prototype（原型模式）1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"prototype\"&gt; prototype作为原型模式 原型模式下，每次创建对象都是不同的 6.3 request在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。 1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"request\"/&gt; 针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。 6.4 session在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。 1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"session\"/&gt; 同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。 7 Bean的生命周期7.1 bean的生命周期 实例化Bean对象 依赖注入 初始化 使用 容器关闭时，销毁 1234&lt;bean id=\"life\" class=\"com.baidu.Dao.life\" init-method=\"init\" destroy-method=\"destroy\"&gt;&lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;&lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;&lt;/bean&gt; init-method 用来指定初始化方法 destroy-method用来指定销毁方法 注意：只有当容器关闭是，才会调用销毁方法 7.2 bean的后置处理器后置处理器加在初始化前后进行操作 12345678910public class AfterHanddler implements BeanPostProcessor&#123; public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; //初始化之后的操作 return null; &#125; public Object postProcessBeforeInitialization(Object arg0, String arg1) throws BeansException &#123; //初始化之前的操作 return null; &#125;&#125; 12&lt;bean class=\"com.baidu.Dao.AfterHanddler\"&gt;&lt;/bean&gt;在xml文件中能够直接引用就行了 8 自动装配手动装配：以valu或者ref的方式明确指定属性值都是手动装配手段 自动装配：根据指定的装配规则，不需要明确指定，spring自动匹配的属性值注入bean中 123456789101112131415手动装配： &lt;bean id=\"emp\" class=\"com.baidu.Dao.Emp\"&gt; &lt;property name=\"name\" value=\"zhangsan\"&gt;&lt;/property&gt; &lt;property name=\"id\" value=\"1001\"&gt;&lt;/property&gt; &lt;property name=\"car\" ref=\"car\"&gt;&lt;/property&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"car\" class=\"com.baidu.Dao.Car\"&gt; &lt;property name=\"cid\" value=\"666\"&gt;&lt;/property&gt; &lt;property name=\"cname\" value=\"cccc\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept\" class=\"com.baidu.Dao.Dept\"&gt; &lt;property name=\"did\" value=\"11111\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"dpart\"&gt;&lt;/property&gt; &lt;/bean&gt; 123456789101112131415161718192021222324252627自动装配： &lt;bean id=\"emp\" class=\"com.baidu.Dao.Emp\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"zhangsan\"&gt;&lt;/property&gt; &lt;property name=\"id\" value=\"1001\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"car\" class=\"com.baidu.Dao.Car\"&gt; &lt;property name=\"cid\" value=\"666\"&gt;&lt;/property&gt; &lt;property name=\"cname\" value=\"cccc\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept\" class=\"com.baidu.Dao.Dept\"&gt; &lt;property name=\"did\" value=\"11111\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"dpart\"&gt;&lt;/property&gt; &lt;/bean&gt;保持bean id和属性名一致，采用byName就可以了 &lt;bean id=\"emp\" class=\"com.baidu.Dao.Emp\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"zhangsan\"&gt;&lt;/property&gt; &lt;property name=\"id\" value=\"1001\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"car1\" class=\"com.baidu.Dao.Car\"&gt; &lt;property name=\"cid\" value=\"666\"&gt;&lt;/property&gt; &lt;property name=\"cname\" value=\"cccc\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept1\" class=\"com.baidu.Dao.Dept\"&gt; &lt;property name=\"did\" value=\"11111\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"dpart\"&gt;&lt;/property&gt; &lt;/bean&gt;当属性名和id不一致时，采用byType就行了 autowire 根据某种策略自动装配 9 注解 注解 说明 @Configuration 指定该类为Spring配置类 @ComponentScan 启用组件扫描，同xml中配置context:component-scan @Controller 控制层Bean @Service 业务层Bean @ Repository Dao层Bean @Component 实例化Bean @Bean 返回一个对象 @Autowired 自动装配Bean @Qualifier(“id”) 根据Id装配 @Resource 相当于@Autowired+@Qualifier(“id”)根据id装配 @Import 导入其他配置类 @Conditional 放在类上，当满足条件时，这个类中配置的所有bean注册才能生效，放在方法上，当满足条件时，才向容器中注册当前bean @Profile 前环境，动态的激活和切换一系列组件的功能；指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件，加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中 123456789101112131415161718192021222324252627282930@Repository@Scope(\"prototype\")public class User &#123; @Value(\"root\") String username; @Value(\"123456\") String password; @Value(\"20\") Integer age; @Autowired Teacher teacher; @PostConstruct public void init()&#123; System.out.println(\"初始化方法执行\"); &#125; @PreDestroy public void dest()&#123; System.out.println(\"销毁方法执行\"); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", age=\" + age + \", teacher=\" + teacher + '&#125;'; &#125;&#125; 123456789101112131415@Componentpublic class Teacher &#123; @Value(\"张三\") String Username; @Value(\"老师\") String Job; @Override public String toString() &#123; return \"Teacher&#123;\" + \"Username=\" + Username + \", Job='\" + Job + '\\'' + '&#125;'; &#125;&#125; 1234567public class AnnoTest &#123; public static void main(String[] args) &#123; ApplicationContext ac=new AnnotationConfigApplicationContext(SpringConfig.class); Person person = (Person) ac.getBean(\"person\"); System.out.println(person); &#125;&#125; 10 AOP什么是AOP AOP为Aspect Oriented Progranmming的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 aop的作用及优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复的代码，提高开发效率，并且便于维护 aop底层实现 动态代理技术 aop的动态代理技术 JDK动态代理：基于接口的动态的代理技术 cglib动态代理：基于父类的动态代理技术 基于XML的AOP开发开发步骤： 导入坐标（spring-context,aspectjweaver） 12345678910&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建目标类以及目标接口 12345public class Target implements TargetInterface&#123; public void save()&#123; System.out.println(\"Save Running……\"); &#125;&#125; 123public interface TargetInterface &#123; public void save();&#125; 创建切面类 1234567891011121314151617181920212223public class MyAspect &#123; public void before()&#123; System.out.println(\"前置增强\"); &#125; public void afterReturning()&#123; System.out.println(\"后置增强\"); &#125; public void afterThrowing()&#123; System.out.println(\"抛出异常\"); &#125; public void around(ProceedingJoinPoint proceedingJoinPoint)&#123; System.out.println(\"环绕前增强\"); try &#123; proceedingJoinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.println(\"还绕后增加\"); &#125; public void after()&#123; System.out.println(\"最终增强\"); &#125;&#125; 切面类和目标类交给Spring容器 1234&lt;!--目标类--&gt; &lt;bean id=\"target\" class=\"com.ccut.aop.Target\"/&gt; &lt;!--切面类--&gt; &lt;bean id=\"myAspect\" class=\"com.ccut.aop.MyAspect\"/&gt; 配置织入 123456789101112131415161718&lt;!--配置织入--&gt; &lt;aop:config&gt; &lt;!--声明切面=切点+通知--&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!--切点表达式，指定被增强的方法--&gt; &lt;aop:pointcut id=\"mypointcut\" expression=\"execution(public void com.ccut.aop.Target.save())\"/&gt; &lt;!--前置增强--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"mypointcut\" /&gt; &lt;!--最终增强--&gt; &lt;aop:after method=\"after\" pointcut-ref=\"mypointcut\"/&gt; &lt;!--后置增强--&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"mypointcut\"/&gt; &lt;!--抛出异常--&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"mypointcut\"/&gt; &lt;!--环绕增强--&gt; &lt;aop:around method=\"around\" pointcut-ref=\"mypointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 配置织入需要先导入aop命名空间 基于注解的AOP开发 导入坐标 配置自动代理和扫描包 12&lt;context:component-scan base-package=\"com.ccut.aop\"/&gt;&lt;aop:aspectj-autoproxy/&gt; 创建切面类和目标类 123456@Component(\"target\")public class Target implements TargetInterface&#123; public void save()&#123; System.out.println(\"Save Running……\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@Component@Aspectpublic class MyAspect &#123; @Before(\"pointcut()\") public void before()&#123; System.out.println(\"前置增强\"); &#125; @AfterReturning(\"pointcut()\") public void afterReturning()&#123; System.out.println(\"后置增强\"); &#125; @AfterThrowing(\"pointcut()\") public void afterThrowing()&#123; System.out.println(\"抛出异常\"); &#125; @Around(\"pointcut()\") public void around(ProceedingJoinPoint proceedingJoinPoint)&#123; System.out.println(\"环绕前增强\"); try &#123; proceedingJoinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.println(\"还绕后增加\"); &#125; @After(\"pointcut()\") public void after()&#123; System.out.println(\"最终增强\"); &#125; /*定义切点*/ @Pointcut(\"execution(public void com.ccut.aop.Target.save())\") public void pointcut()&#123;&#125;&#125; 11 Spring jdbcTemplateJdbcTemplate开发步骤 导入spring-jdbc和Spring-tx 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--控制事务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建数据库表和实体 1创建数据库和实体类相对应 创建JdbcTemplate对象 1234567891011&lt;context:property-placeholder location=\"db.properties\"/&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"druid\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"druid\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"$&#123;db.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;db.password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;db.url&#125;\"/&gt; &lt;property name=\"driverClassName\" value=\"$&#123;db.driver&#125;\"/&gt; &lt;/bean&gt; 执行数据库操作 1234567891011121314151617181920212223242526272829303132333435@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcTemplateCRUDTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test public void testInsert()&#123; int row=jdbcTemplate.update(\"INSERT INTO testmybatis(NAME,age,address,cid) VALUE(?,?,?,?)\",\"liuzhi\",22,\"shandong\",\"1\"); System.out.println(row); &#125; @Test public void testUpdate()&#123; jdbcTemplate.update(\"UPDATE testmybatis SET age=? WHERE id=?\",20,17); &#125; @Test public void testDelete()&#123; jdbcTemplate.update(\"DELETE FROM testmybatis WHERE id=?\",16); &#125; @Test public void testQueryAll()&#123; List&lt;User&gt; list=jdbcTemplate.query(\"select * from testmybatis\",new BeanPropertyRowMapper&lt;User&gt;(User.class)); System.out.println(list); &#125; @Test public void testQueryOne()&#123; User user = jdbcTemplate.queryForObject(\"select * from testmybatis where id=?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), 1); System.out.println(user); &#125; @Test public void testQueryCount()&#123; int num = jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM testmybatis\",int.class); System.out.println(num); &#125;&#125; 12 Spring事务Spring支持的事务类型 编程式事务 声明式事务 Spring实现事务的方式和原理spring实现事务实质是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务，真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的 Spring事务隔离级别 默认 未提交读 提交读 可重复读 序列化 事务问题 脏读：读取另一个未提交的事务 不可重复读：同一个事务，多次读取同一个数据 幻读：同一个事务多次查询返回的结果集不一样","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/Spring/","category":""},{"title":"Mybatis","link":"https://augus-liuzhi.github.io/2020/10/06/mybatis/","description":"MybatisMybatis概念MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。 ORMORM：对象关系映射，它是一种思想，主要是指数据库中每行数据用对象表示 Mybatis是半自动ORM映射工具，与全自动的区别Hibernate属于全自动ORM映射工具，进行级联查询时，根据对象模型可以直接获取。 Mybatis属于半自动ORM映射工具，进行级联查询，要手动写sql来完成。 JDBC存在的问题问题：大量代码冗余 数据库连接 ​ 数据库链接创建，释放频繁造成资源浪费 ​ 解决：mybatis-config.xml文件配置数据库连接池，使用数连接池管理数据库连接。 Sql语句 ​ sql语句和java代码高耦合 解决：mybatis把sql语句配置在Mapper文件中与java代码分离 结果集 ​ 传统jdbc需要遍历，手动封装对象 ​ 解决：mybatis自动映射成对象 Mybatis优缺点优点： 简化代码，提高效率 sql放在配置文件，提高可维护性 自带连接池功能 自带缓存（提高查询效率） 缺点： 1. 当字段多时，查询多表时，sql语句编写量过大 2. sql语句依赖数据库，可移植性差 Hibernate和mybatis区别 Sql优化和移植性 Mybatis需要手动编写sql语句，移植性较差，可优化行好 hibernate封装了sql语句，移植性比较好，但是可优化性差 映射关系 mybatis半自动orm框架，配置对象和结果集关系映射 Hibernate全自动orm框架，配置对象和数据表的对应关系 环境搭建 导入jar(lib+mybatis-3.5.2.jar) 引入配置文件 mybatis-config.xml ​ driverClassNme ​ url ​ username ​ password ​ 连接池（pooled） 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 选取要使用哪个环境配置 ，选取enviroment id --&gt; &lt;environments default=\"development\"&gt; &lt;!-- 给环境配置一个名称，名称随意 --&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事物控制，类型是采用jdbc方式手动控制事物 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 开启连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 驱动名，url,用户名，密码 --&gt; &lt;property name=\"driver\" value=\"数据库驱动器名（com.mysql.cj.jdbc.Driver）\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/（数据库名）?serverTimezone=UTC\" /&gt; &lt;property name=\"username\" value=\"数据库用户名\" /&gt; &lt;property name=\"password\" value=\"数据库密码\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"实现类的xml文件的路径\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; xxxMapper.xml(相当于dao的实现类) 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.baidu.demo.PersonDao\"&gt;&lt;insert id=\"抽象类中insert方法\" parameterType=\"有参方法的参数类型\"&gt;insert into messages value(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;address&#125;,#&#123;hobby&#125;)&lt;/insert&gt;&lt;select id=\"抽象类中select方法\" parameterType=\"有参方法的参数类型\" resultType=\"返回值参数类型\" &gt;select * from messages where id=#&#123;id&#125;&lt;/select&gt;&lt;delete id=\"抽象类中delete方法\" parameterType=\"有参方法的参数类型\"&gt;delete from messages where id=#&#123;id&#125;&lt;/delete&gt;&lt;update id=\"抽象类中update方法\" parameterType=\"有参方法的参数类型\"&gt;写update的sql语句&lt;/update&gt;&lt;/mapper&gt; Mybatis常用API12345678910111213141516目的：使用Dao 获得Dao对象 使用Dao方法常用的类：SqlSession 1. 获得Dao对象 XXXDao dao=SqlSession.getMapper(接口.class) 2. 相当于Connection 对象，提交事务，事物回滚，关闭资源SqlSeesionFactory 1. 获得sqlSession SqlSession sqlsession=sqlSessionFactory.opensession() 2. 保存封装mybatis-config.xml SqlSeesionFactory sqlSessionFactory=new SqlSeesionFactoryBulider().build(is)SqlSeesionFactoryBulider():读取配置文件Resources:获得读取配置文件的输入流InputStream is=Resources. Mybatis编程步骤 获得mybatis-config.xml的输入流 读取mybatis-config.xml配置文件，构造SqlSessionFactory对象 通过构造SqlSessionFactory对象，调用opensession(),获得Sqlsession 通过SqlSession对象获得Dao接口对象 调用方法匹配 提交事务 释放资源 Mybatis编程示例抽象类 1234567public interface PersonDao &#123; public void insert(Person person); public Person select(int id); public void delete(int id); public void update(Person person); &#125; 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Person &#123; int id; String username; String password; int sex; String address; String hobby; public Person() &#123; super(); &#125; public Person(int id, String username, String password, int sex, String address, String hobby) &#123; super(); this.id = id; this.username = username; this.password = password; this.sex = sex; this.address = address; this.hobby = hobby; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125; public Person(String username, String password, int sex, String address, String hobby) &#123; super(); this.username = username; this.password = password; this.sex = sex; this.address = address; this.hobby = hobby; &#125; @Override public String toString() &#123; return \"Person [id=\" + id + \", username=\" + username + \", password=\" + password + \", sex=\" + sex + \", address=\" + address + \", hobby=\" + hobby + \"]\"; &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Testpublic void insert() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); Person person=new Person(\"zhong\", \"250\", 1, \"jinan\", \"play\"); personDao.insert(person); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125;@Testpublic void select() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); Person person=personDao.select(2); System.out.println(person.toString()); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125;@Testpublic void delete() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); personDao.delete(1); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125;@Testpublic void update() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); Person person=new Person(2, \"小二\", \"123456\", 1, \"jinan\", \"play\"); personDao.update(person); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125; Myabtis的执行器有哪些，以及他们的区别 simpleExcutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。就是单次使用statement对象. reuserExcutor : 执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。 bathExcutor : 执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 执行器的设置方式有两种A:在配置文件中通过setting设置B:在构建sqlsession对象时，通过opensession(执行器)指定执行器类型 Mybatis是否支持延迟加载？Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 1&lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; 作用：映射查询结果的列封装成实体的属性 要求：查询结果的列明必须和实体属性名一致 表名和实体属性名不一致 通过sql别名的关键字，把sql语句和属性名保持一致 查询多个只需要知道每一行数据的封装的类型，mybatis会自动把多个数据封装成一个list 1.书写Dao接口 2.书写Mapper文件 3.注册Mapper文件 参数绑定 单个参数 在mapper文件中直接指定parameterType就可以了 多个参数 方法一：注解方式 123public interface UserDao &#123; public User select(@Param(\"username\")String username,@Param(\"password\")String password);&#125; 123&lt;select id=\"select\" resultType=\"com.baidu.demo.User\" &gt;SELECT * FROM messages WHERE username=#&#123;username&#125; AND PASSWORD=#&#123;password&#125;&lt;/select&gt; 方法二：参数序号 123public interface UserDao &#123; public User select(String username,String password);&#125; 123&lt;select id=\"select\" resultType=\"com.baidu.demo1.User\" &gt;SELECT * FROM messages WHERE username=#&#123;param1&#125; AND PASSWORD=#&#123;param2&#125;&lt;/select&gt; 分页1public List&lt;Person&gt; queryPage(int start, int pagesize); 123&lt;select id=\"queryPage\" resultType=\"com.baidu.demo.Person\" &gt;select * from messages limit #&#123;para1&#125;,#&#123;para2&#125;&lt;/select&gt; 12345678910111213141516171819202122@Test public void page() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); int start=3; int pagesize=2; List&lt;Person&gt; list=personDao.queryPage(pagesize*(start-1), pagesize); System.out.println(list); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125; 分页插件PageHelperpom.xml中 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt; &lt;/dependency&gt; mybatis-config,xml中 12345&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt; &lt;property name=\"dialect\" value=\"mysql\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 测试类 123456789101112131415@Test public void selectall()&#123; SqlSession sqlSession= MybatisUtil.getSqlSession(); UserDao userDao=sqlSession.getMapper(UserDao.class); PageHelper.startPage(1,3); List&lt;User&gt; list=userDao.SelectAll(); for(User user:list)&#123; System.out.println(user); &#125; PageInfo pageInfo=new PageInfo(list); System.out.println(\"共\"+pageInfo.getTotal()+\"条数据\"); System.out.println(\"当前页\"+pageInfo.getPageNum()); System.out.println(\"上一页\"+pageInfo.getPrePage()); System.out.println(\"下一页\"+pageInfo.getNextPage()); &#125; MybatisUtil的封装mybatis的核心api SqlSession 相当于Connection commit() rollback() close() 轻量级对象，每次操作创建一个新的。 SqlSeesionFactory ​ 作用：封装Mybatis-config配置信息 ​ 重量级对象，整个web应用只创建一个，对象的创建比较消耗资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.baidu.util;import java.io.IOException;import java.io.InputStream;import javax.management.RuntimeErrorException;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.baidu.demo.PersonDao;public class MybatisUtil2 &#123; //定义重量级对象SqlSessionFactory，减轻消耗资源。 private static SqlSessionFactory sqlSessionFactory; //从线程中获取sqlSession对象 private static ThreadLocal&lt;SqlSession&gt; tdl=new ThreadLocal&lt;SqlSession&gt;(); //载入配置文件，构建SqlSessionFactory static &#123; InputStream is = null; try &#123; is = Resources.getResourceAsStream(\"mybatis-config.xml\"); sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); &#125; catch (IOException e) &#123; throw new RuntimeException(\"读取配置文件失败\",e); &#125;finally &#123; if(is!=null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //获得SqlSession对象 public static SqlSession getSqlSession() &#123; SqlSession sqlSession=null; sqlSession=tdl.get(); if(sqlSession==null) &#123; sqlSession=sqlSessionFactory.openSession(); tdl.set(sqlSession); &#125; return sqlSession; &#125; //获得XXXDAO实体对象 public static &lt;T&gt; T getMapper(Class&lt;T&gt; clssa)&#123; SqlSession sqlSession=getSqlSession(); T t=sqlSession.getMapper(clssa); return t; &#125; //提交事务 public static void commit() &#123; SqlSession sqlSession=getSqlSession(); sqlSession.commit(); &#125; //回滚事务 public static void rollback() &#123; SqlSession sqlSession=getSqlSession(); sqlSession.rollback(); &#125; //关闭资源 public static void close() &#123; SqlSession sqlSession=getSqlSession(); if(sqlSession!=null) &#123; sqlSession.close(); tdl.remove(); &#125; &#125; &#125; 日志log4j.properties 12345678910111213在pom.xml中配置&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; mybatis-config.xml 123&lt;settings &gt; &lt;setting name=\"logImpl\" value=\"LOG4J\" /&gt; &lt;/settings&gt; 实体类名简化 给实体类的权限定名取别名 1\"com.baidu.demo.Person\" ====&gt; 别名 \"Person\" Mapper文件中 12345parameterType=\"com.baidu.demo.Person\" ==&gt;parameterType=\"Person\"resultType=\"com.baidu.demo.Person\" ==&gt;resultType=\"Person\" 使用方法 在mybatis-config.xml中 123&lt;typeAliases&gt;&lt;typeAlias type=\"com.baidu.demo.Person\" alias=\"Person\"/&gt;&lt;/typeAliases&gt; 在mapper文件中 123&lt;select id=\"select\" parameterType=\"int\" resultType=\"com.baidu.demo.Person\" &gt; ======&gt;&gt;&gt;直接采用别名就可以了&lt;select id=\"select\" parameterType=\"int\" resultType=\"Person\" &gt; Mybatis底层绑定参数的底层原理 123456789101112131415161 默认mapper文件绑定参数 #&#123;参数&#125; 底层使用的是PreparedStatment对象 使用 sql ? 预编译的方式执行 优点： 预编译，防止sql注入，效率高 缺点： 只能绑定数据值，sql关键字 列 非数据无法绑定2 使用sql字符串拼接可以绑定任何参数 优点：可以绑定任何内容（关键词，列） 缺点：sql注入 缓存12一级缓存：它指的是Mybatis对象中的SqlSession对象的缓存，当我们执行查询后，查询结果会存入到SqlSession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询相同的数据，mybatis会先去SqlSession中去找，如果有拿来直接使用，当SqlSession对象执行commit()或者close()以及增删改操作，缓存会被默认清空，默认打开一级缓存二级缓存：它指的是Mybatis中SqlSessionFactory对象缓存，同一个SqlSessionFactory创建SqlSession对象共享SqlSessionFactory对象的缓存(二级缓存存储的是数据，不是对象) 使用： 1 mybatis框架支持二级缓存（mybatis-config.xml配置） 123&lt;settings&gt; &lt;setting name=\"cachedEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 2 让当前的映射文件支持二级缓存（Mapper文件中配置） 1&lt;cache/&gt; 3 让当前的操作支持二级缓存（在Select标签中配置） 1&lt;select id=\"SelectByPage\" resultType=\"com.ccut.mybtais.User\" useCache=\"true\"&gt; 注解1234567@Select(\"SELECT * FROM testmybatis\")public List&lt;User&gt; SelectAll();@Insert(\"INSERT INTO testmybatis(NAME,age,address,cid) VALUE(#&#123;name&#125;,#&#123;age&#125;,#&#123;address&#125;,#&#123;cid&#125;)\")@SelectKey(statement =\"SELECT LAST_INSERT_ID()\", keyProperty = \"id\",before = false, resultType = int.class)public int InsertUser(User user);@Select(\"SELECT * FROM testmybatis WHERE NAME LIKE '%$&#123;value&#125;%'\")List&lt;User&gt; SelectByName(String name); 多表操作一对一 1234567891011121314&lt;resultMap id=\"MyResultMap\" type=\"com.ccut.mybtais.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"age\" property=\"age\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;result column=\"cid\" property=\"cid\"&gt;&lt;/result&gt; &lt;association property=\"userClass\" javaType=\"com.ccut.mybtais.UserClass\"&gt; &lt;id column=\"cid\" property=\"cid\"&gt;&lt;/id&gt; &lt;result column=\"part\" property=\"part\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"SelectAll\" resultMap=\"MyResultMap\"&gt; SELECT * FROM testmybatis t ,class c WHERE t.`cid`=c.`cid` &lt;/select&gt; 一对多 1234&lt;collection property=\"userClass\" ofType=\"com.ccut.mybtais.UserClass\"&gt; &lt;id column=\"cid\" property=\"cid\"&gt;&lt;/id&gt; &lt;result column=\"part\" property=\"part\"&gt;&lt;/result&gt;&lt;/collection&gt;","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/mybatis/","category":""},{"title":"集合类","link":"https://augus-liuzhi.github.io/2019/11/26/集合类/","description":"1. 集合类概述集合类又称为容器 集合类和数组的区别： 集合类长度可变，存放对象的引用。 数组长度是固定的，存放数据的基本类型。 常用集合类： List集合（继承Collection类） Set集合（继承Collection类） Map集合 2. Collection接口Collection接口是层次结构中的根接口，构成Collection的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将对象添加到集合 remove(Object o) 将对象从集合中删除 isEmpty() 返回boolean值，判空操作 iterator() 遍历集合对象 size() 获取集合中元素的个数，返回值int ​ 遍历的使用 12345678910public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();//创建集合类对象 list.add(\"a\");//往集合中添加对象 list.add(\"b\"); list.add(\"c\"); Iterator&lt;String&gt; it=list.iterator();//创建迭代器 while(it.hasNext()) &#123;//判断是否有下一元素，返回值为布尔类型 System.out.println(it.next());//next()方法返回Object &#125; &#125; 3. List集合List集合包括List接口以及List接口所实现的类。 List集合中元素允许重复，各元素顺序就是对象的插入的顺序。 用户可以通过索引（元素在集合中的位置）来访问集合中的元素 3.1 List接口重要方法： get(int index): 获取指定索引位置的元素 set(int index,object):将集合中指定索引位置，修改为指定对象（修改操作） 1234567891011public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();//创建集合类对象 list.add(\"a\");//往集合中添加对象 list.add(\"b\"); list.add(\"c\"); System.out.println(list.get(0));//得到索引值为0的对象 System.out.println(list.get(1)); System.out.println(list.get(2)); list.set(0,\"c\");//把索引值0处对象修改成c,修改不是交换，对象a消失 System.out.println(list.get(0)); &#125; 3.2 List接口的实现类实现类一：ArrayList类 优点：实现可变数组，允许保存所有元素，包括Null，并可以根据索引位置对集合进行随机访问 缺点：向指定的索引位置插入对象或删除对象的速度缓慢。 实现类二：LinkedList类 优点：采用链表保存对象，便于向集合中插入和删除对象，插入删除效率高。 缺点：随机访问效率低 实例化用法： 123List&lt;E&gt; arraylist=new ArrayList&lt;&gt;();List&lt;E&gt; linkedList=new LinkedList&lt;&gt;();E为合法的Java数据类型 实例 123456789101112public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();//创建集合类对象 list.add(\"a\");//往集合中添加对象 list.add(\"b\"); list.add(\"c\"); int i=(int) (Math.random()*list.size()-1);//随机获取0-2 list.remove(2);//删除索引为2的元素。 Iterator&lt;String&gt; it=list.iterator(); while(it.hasNext()) &#123;//遍历输出 System.out.println(it.next()); &#125; &#125; 注意：与数组相同，集合的索引也是从0开始的。 4. Set集合set集合对象不按特定方式排序，只是简单的把对象加入集合，set集合不能包含重复的元素。 set集合由set接口和set接口实现类组成。 Set接口的实现类 实现类一：HashSet类实现Set接口，由哈希表支持，不保证迭代顺序，允许使用Null元素 实现类二：TreeSet类不仅实现Set接口，还实现了java.util.SortedSet接口。TreeSet类实现的Set集合在便利中按照自然顺序递增排序，也可以按照指定比较器递增排序。 TreeSet类增加方法 方法 功能描述 first() 返回第一个（最低）元素 last() 返回最后一个（最高）元素 comparator() 返回排序比较器，如果自然排序，返回NUll headSet(E toElement) 返回一个新集合，包含从头到toElement所有的元素 subSet(E fromElemnet,E toElement【不包含】) 返回一个新集合，包含从fromElement到toElement所有的元素 tailSet(E fromElement) 返回一个新集合，包含fromElement到之后的所有的对象 实例用法： 12345678910111213public static void main(String[] args) &#123; TreeSet &lt;String&gt; set=new TreeSet&lt;&gt;();//创建一个Set集合对象 set.add(\"a\");//添加对象 set.add(\"b\"); set.add(\"c\"); System.out.println(set.size());//输出个数 System.out.println(set.first());//输出集合第一个 System.out.println(set.last());//输出集合最后一个 System.out.println(set.comparator());//返回排序比较器 System.out.println(set.headSet(\"c\"));//从头到C，不包含C System.out.println(set.subSet(\"a\", \"c\"));C//从a到c,不包含c System.out.println(set.tailSet(\"b\"));//从b往后 &#125; HashSet类方法 方法 功能 HashSet() 构造一个默认的散列集合 HashSet(Collection c) 创建一个散列集合，并用类c中的元素初始化 HashSet(int capacity) 创建一个容量为capacity的散列集合 Hash(int capacity,float fillTadio) 创建一个容量为capacity的散列集合，填充比为fillTadio 用法： 12345678public static void main(String[] args) &#123; HashSet&lt;Object&gt; hs=new HashSet&lt;&gt;(); hs.add(\"A\"); hs.add(\"B\"); hs.add(\"C\"); hs.add(\"D\"); System.out.println(hs); &#125; 注意：散列集合的元素是无序的 5. Map集合Map集合中没有继承Collection接口，它提供的是Key到Value的映射。Map中不能包含相同的Key,每个Key只能映射一个Value. Map集合包含：Map接口以及Map接口所实现类。 5.1 Map接口Map接口的常用方法： 方法 功能 put(K key,V value) 向集合中添加Key和Value的映射关系 containsKey(object key) 包含指定Key的映射关系，返回true containsKey(object value) 映射一个或多个Key映射到指定值，返回true get(object key) 存在指定key对象，返回该对象的值，否则返回null keySet() 返回该集合中所有Key对象形成的Set集合 values() 返回该对象所有值对象形成的Collection集合 用法 1234567891011121314151617public static void main(String[] args) &#123; Map&lt;String,String&gt;map=new HashMap&lt;&gt;();//创建Map实例 map.put(\"0\", \"我\");//添加key和value映射关系 map.put(\"1\", \"是\"); map.put(\"2\", \"学\"); map.put(\"3\", \"生\"); Set&lt;String&gt; set=map.keySet();//构建map里面的所有key集合 Iterator &lt;String&gt; it=set.iterator();//创建迭代器 while(it.hasNext()) &#123;//判断是否还有下一个元素 System.out.println(it.next());//遍历集合 &#125; Collection&lt;String&gt; coll=map.values();//构建map里面的所有Value集合 it=coll.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125; 注意：map集合允许对象添加对象为Null值，而且没有个数限制。（这里的值对象value,不是key） 5.2 Map接口的实现类实现类一：HashMap类，允许使用null值null健，添加和删除映射关系效率更高，不保证映射的顺序。 实现类二：TreeMap类，映射关系具有一定的顺序，删除，添加，定位映射效率低，不允许null值。 用法： 123456789101112131415161718192021import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class day01 &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map=new HashMap&lt;&gt;(); map.put(\"面向对象程序设计\", \"100\"); map.put(\"软件工程导论\", \"80\"); map.put(\"高数\", \"60\"); Iterator&lt;String&gt;it=map.keySet().iterator(); while(it.hasNext()) &#123; String key=it.next(); String value=map.get(key); System.out.println(key+\" \"+value); &#125; &#125;&#125;结果：面向对象程序设计 100软件工程导论 80高数 60","pubDate":"Tue, 26 Nov 2019 05:27:56 GMT","guid":"https://augus-liuzhi.github.io/2019/11/26/集合类/","category":""},{"title":"字符串","link":"https://augus-liuzhi.github.io/2019/11/18/String/","description":"String类 声明字符串 java中有一对” “号包围的都是字符串 声明字符串语法：String s 注意：声明字符串必须经过初始化才能使用 创建字符串 方法一 String (char a[]) 1234char a[]=&#123;'a','b','c'&#125;;String s=new String(a);等价于String s=new String(\"abc\"); 方法二String(char a[],int offset,int length) 1234char a[]=&#123;'s','t','u','d','e','n','t'&#125;;String s=new String(a,2,4);等价于String s=new String(\"uden\") 方法三 1234String str1,str2;str1=\"we are student\";str2=\"we are student\";str1与str2引用相同的的字符串常量，具有相同的实体。 连接多个字符串 使用+运算符可以将多个字符串连接在一起 123456public static void main(String[] args) &#123; String str1=\"hello\"; String str2=\"world\"; String s=str1+\" \"+str2; System.out.println(s); &#125; 连接其他数据类型 字符串也可以和其他数据类连接，会自动将其他的数据类型转换成字符串 1234567public static void main(String[] args) &#123; String str1=\"10\"; int a=10; char b='a'; System.out.println(a+str1+b); &#125;结果：1010a 其他数据类型和字符串相连接的时候，会自动调用toString()方法，将其转换成字符串。 获取字符串长度 使用String类的length()方法获取声明字符串对象的长度 语法：str.length() 12String s=\"we are student\";int size=s.length(); 空格也算字符串的一位。 字符串查找 indexOf(String s)查找s在字符串第一次出现的位置 lastIndexOf(String s)查找s在字符串中最后一次出现的位置 查找成功，返回当前字符所在字符串的位置，查找失败，返回-1 1234567public static void main(String[] args) &#123; String s=\"we are student\"; System.out.println(s.indexOf(\"e\")); System.out.println(s.lastIndexOf(\"e\")); System.out.println(s.indexOf(\"l\")); System.out.println(s.indexOf('w')); &#125; 获取索引位置的字符 使用charAt()方法可以将指定索引处的字符返回 语法：s.charAt(int index) 12String s=\"we are student\";System.out.println(\"返回第5个位置\"+s.charAt(5)); 获取子字符串 方法一 ：substring(int beginIndex)从当前位置到结束 方法二 ：substring(int beginIndex,int endIndex)从当前开始，到指定结束 123String s=\"we are student\";System.out.println(s.substring(3));System.out.println(s.substring(2,6)); 去除空格 忽略前导空格和尾部空格 12345public static void main(String[] args) &#123; String s=\" String 123 \"; System.out.println(\"字符串长度为：\"+s.length()); System.out.println(\"去除空格后的长度为：\"+s.trim().length());&#125; 字符串替换 将指定字符或者字符串转换成新的字符或者字符串 语法：s.replace(old,new) s.replaceAll(regex,replacment) 123456public static void main(String[] args) &#123; String s=\"abcdefg\"; System.out.println(s.replace('a', 'A')); System.out.println(s.replaceAll(\"ab\", \"ccccccc\")); System.out.println(s.replaceAll(s, \"ccccccc\")); &#125; 判断字符串的开始与结尾 startWith()方法与endWith()方法分别用于判断字符串是否以指定内容开始或者结束，返回值为boolean类型 语法：s.startWith(String prefix) 语法：s.endWith(String suffix) 1234567public static void main(String[] args) &#123; String num=\"220123456789330\"; boolean a=num.startsWith(\"220\"); boolean b=num.endsWith(\"330\"); System.out.println(\"字符串是220开头么？\"+a); System.out.println(\"字符串是330结尾么？\"+b); &#125; 判断字符串是否相等 运算符==用于判断两个字符串的内存地址是否相同 如果两个字符串具有相同的字符和长度可以使用equals()进行比较 语法：s1.equals(s2) 语法：s1.equalsIgnoreCase()忽略大小写 123456789101112131415161718192021222324public static void main(String[] args) &#123; String a=\"123\";//将123字符串指向a String b=\"123\";//将123字符串指向b String c=new String(\"123\");//新开辟一个内存空间，存储123字符串 if(a==b) &#123; System.out.println(\"两个字符串内存地址一样\"); &#125; if(a==c) &#123; System.out.println(\"两个字符串内存地址一样\"); &#125; else &#123; System.out.println(\"两个内存地址不一样\"); &#125; if(a.equals(b)) &#123; System.out.println(\"两个字符串相同\"); &#125; else &#123; System.out.println(\"两个字符串不相同\"); &#125; &#125;输出结果： 两个字符串内存地址一样 两个内存地址不一样 两个字符串相同 按字典比较两个字符串 compareTo()方法按字典顺序比较两个字符串 s1&lt;s2返回小于0的值 s1=s2返回0 s1&gt;s2返回大于0的值 123456789101112public static void main(String[] args) &#123; String s1=\"abc\"; String s2=\"efg\"; String s3=\"abc\"; System.out.println(s1.compareTo(s3)); System.out.println(s1.compareTo(s2)); System.out.println(s2.compareTo(s3)); &#125;输出结果：0-44 字母大小写转换 toLowerCase():将所有字符转换成小写 toUpperCase() 将所有字符转换成大写 123456789public static void main(String[] args) &#123; String s1=\"abc\"; String s2=\"ABC\"; System.out.println(s1.toUpperCase()); System.out.println(s2.toLowerCase()); &#125;输出结果：ABCabc 字符串分割 split()方法可以使字符串按照指定的分割字符或字符串对内容进行分割，指定多个分隔符,|= split(String sign,int limit)指定分割次数 12345678910111213141516171819202122public static void main(String[] args) &#123; String s=\"123,456,789=789=123123123\"; String[] news1=s.split(\",|=\"); for(String i:news1) &#123; System.out.println(i); &#125; System.out.println(); String[] news2=s.split(\",|=\",3); for(String i:news2) &#123; System.out.println(i); &#125; &#125;结果：123456789789123123123123456789=789=123123123 日期和时间的字符串格式化 日期格式化 12345Date date=new Date(); String year=String.format(\"%tY\", date); String month=String.format(\"%tm\", date); String day=String.format(\"%td\", date); System.out.println(year+\"年\"+month+\"月\"+day+\"日\"); 时间格式化 12345Date date=new Date(); String hour=String.format(\"%tH\", date); String minute=String.format(\"%tM\", date); String sec=String.format(\"%tS\", date); System.out.println(hour+\"点\"+minute+\"分钟\"+sec+\"秒\"); 简单 12System.out.println(String.format(\"%tF\", new Date()));System.out.println(String.format(\"%tT\", new Date())); 正则表达式 元字符 意义 . 代表任意一个字符 \\d 0-9任意一个 \\D 非数字字符 \\s 空白字符 \\S 非空白字符 \\w 可用作标识符的字符不包括$ \\W 代表不可用于标识符的字符 通配符 ？ 0次或1次 * 0次或多次 + 一次或多次 {n} X=n {n,} n&lt;=X {n,m} n&lt;=X&lt;=m [abc] abc中的一个 [^abc] abc之外的任意字符 [a-zA-Z] 任何一个英文字母 [a-e[g-z]] 并运算 [a-z&amp;&amp;[def]] 交运算 字符串生成器 StringBuffer类提高频繁添加字符串的效率 12345678StringBuffer buffer=new StringBuffer(\"abcd\"); System.out.println(buffer); buffer.append(10); System.out.println(buffer); buffer.insert(6, \"hello\"); System.out.println(buffer); buffer.delete(6,11); System.out.println(buffer);","pubDate":"Mon, 18 Nov 2019 03:32:46 GMT","guid":"https://augus-liuzhi.github.io/2019/11/18/String/","category":""},{"title":"java面向对象基础","link":"https://augus-liuzhi.github.io/2019/10/28/面向对象/","description":"1 面向对象基础1.1 对象 概念：世间万物皆为对象，具有一定的属性和行为 1.2 类 概念：类是具有相同属性和行为的对象的抽象 1.3 属性 概念：描述对象的状态，在java中就是变量 1.4 行为 概念：描述对象的行为，在java中就是函数 1.5 面向对象编程的三大特点 1.5.1 封装 封装：将对象的属性和行为封装起来，对外的载体就是类【核心思想】 隐藏对象的属性和实现细节，仅对外提供公共访问方式 好处： 将转化提高 便于使用 提高重用性 提高安全性 封装原则 将不需要的对外提供的内容隐藏起来，把属性都隐藏，提供公共方法对其访问。 12345678910111213141516171819public class cardemo &#123; public static void main(String[] args) &#123; car c=new car(); c.setAge(0); System.out.println(c.getAge()); &#125;&#125;class car&#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age&gt;0&amp;&amp;age&lt;100) this.age = age; else System.out.println(\"age 错误！！！！\"); &#125;&#125; 1.5.2 继承 继承：子类有父类的属性和行为，子类也可以定义自己独有的属性和行为 1.5.3 多态 多态： 2 类2.1 成员变量和局部变量 成员变量定义在类中，整个类中都有访问。局部变量定义在函数、语句、局部代码块中，只有在所属区域有效 成员变量存在于堆内存的对象中，局部变量存在于栈内存的对象中 成员变量随着对象的创建而存在，随着对象的消失而消失。局部变量随着所属区域的执行而存在，随着所属区域结束而释放 成员变量都有默认初始值，局部变量必须初始化。 局部变量和成员变量同名，局部变量优先原则 注意：类类型的参数一定指向对象，否则为NULL 匿名对象 ​ 没有名字的对象new car(); 定义对象的简写格式 当对象对方法进行一次调用，可以使用匿名对象 new car().num=5; new car().color=”red”; new car().run(); 匿名对象可以作为实际参数传递 show(new car()); 构造函数 函数名和类名相同 没有返回值 作用: 给对象初始化 创建对象都必须通过构造函数初始化 一个类中如果没有定义过构造函数，那么该类中就会有一个默认无参的构造函数 如果类中指定了构造函数，那么类中默认的构造函数就没有了 构造函数和一般函数的区别 调用时间： 构造函数对象创建时调用，对对象初始化，一般函数，对象创建后，才可以调用 调用次数： 构造函数只调用一次且是自动调用，一般函数可以调用多次且手动调用 123456789101112131415161718192021222324252627282930public class cardemo &#123; public static void main(String[] args) &#123; person p = new person(); p.speak(); person p1 = new person(\"旺旺\"); p1.speak(); person p2 = new person(\"强强\",10); p2.speak(); &#125;&#125;class person &#123; private String name; private int age; person() &#123; name = \"baby\"; age = 1; System.out.println(\"person run\"); &#125; person(String n) &#123; name = n; &#125; person(String n, int a) &#123; name = n; age = a; &#125; void speak() &#123; System.out.println(name + \" \" + age); &#125;&#125; 多个构造函数出现，必须按照重载方式【参数类型，参数个数，参数顺序】对不同的对象进行初始化 2.2 成员方法 权限修饰符 返回值类型 方法名（参数1，参数2，……参数N）{ ​ //方法体（可以为空） ​ //返回值 } 构造方法 特点：1 无返回值 ​ 2 方法名和类名相同 权限修饰符 方法名（）{ //构造方法体 } 如果没有构造方法，系统会自动创建一个，如果有自己写的，系统将不会创建构造无参构造方法 2.3 权限修饰符 private protected public 本类 可见 可见 可见 同包其他类或者子类 不可见 可见 可见 其他包的类或者子类 不可见 不可见 可见 如果没有设置权限修饰符，默认为本包可见，类的权限决定变量和方法的权限 2.4 this关键字 调用成员的变量和成员的方法 当成员变量和局部变量同名时 用this区分 this表示当前对象的引用 this可以在构造函数中调用其它构造函数，但是必须放在当前调用构造函数的第一行，即this函数放置在第一行 2.5 静态变量、常量和方法 用static修饰的成员被所有对象共享 static优于对象存在，因为static的成员随着类的加载就已经存在了 用关键字static修饰的变量，常量，方法称为静态变量，常量，方法 static修饰的成员多了一种调用方式，使用语法：类名.静态类成员 static修饰的数据是共享数据（静态/类变量，静态方法），对象中存储的数据是特有数据（叫成员/实例变量，成员方法） 静态放法中不可以使用this关键字 在静态方法中不可以直接调用非静态方法 局部变量不可以声明static 成员变量和静态变量的区别 1 两个变量的生命周期的时间不一样，成员变量随着对象的创建而存在，随着对象的释放被回收，静态变量随着类的加载而实现，随着类的消失而消失 2 调用方式不同 成员变量只能被对象调用，然而静态变量可以用类名和对象调用【尽量使用类名调用】 3 别名不同 成员变量也叫实例变量 静态变量也叫类变量 4 存储位置不同 成员变量的数据存储在堆内存的对象中，所以也叫对象的特有数据 静态变量存储在方法区的静态区【共享数据区】，所以也叫对象的共享数据 静态的注意事项： 静态方法只能访问静态成员。【访问局限性】 非静态即可以访问静态，又可以访问静态 静态方法中不可以使用this和super关键字 主函数是静态的 主函数： 格式是固定的 被JVM识别和调用 public：权限是最大的 static : 虚拟机调用主函数，不需要对象，直接用类名调用 void : 无返回值 main : 函数名，JVM识别的一个名字 String[] args: 参数列表，是一个数组类型的参数，元素都是字符串【==&gt;new String[0]】 3 对象3.1 对象的创建 语法： Test test=new Test(); Test test=new Test(a); 注意：每创建一个对象，就会调用一次构造方法 3.2 访问对象的属性和行为 类名.行为 类名.属性 4. super关键字 调用构造方法 调用隐藏变量 调用重写方法 注意：super调用的都是父类 super使用代码 1234567891011121314151617181920212223242526272829303132333435class A &#123; int num = 10; A() &#123; System.out.println(\"父类无参构造方法执行了\"); &#125; A(int x) &#123; System.out.println(\"父类有参构造方法执行了\"); &#125; void show() &#123; System.out.println(\"父类show方法\"); &#125;&#125;class B extends A &#123; B() &#123; super();// 调用父类无参构造方法 System.out.println(\"隐藏变量已经调用:\"+super.num);// 调用隐藏变量 System.out.println(\"B子类的构造方法执行了\"); &#125; void show() &#123; super.show();// 调用父类被重写的方法 System.out.println(\"子类show方法\"); &#125;&#125;class C extends A &#123; C() &#123; super(4);// 调用父类中的有参构造方法 System.out.println(\"C子类的构造方法执行了\"); &#125;&#125; 5. final关键字继承的弊端：打破封装性 final关键字可以修饰类、方法、变量 5.1 final修饰类123final class A &#123;&#125; final修饰的类不能被继承，即不能有子类 2.2 final修饰方法123final void show() &#123; &#125; final修饰的方法不允许被子类重写 2.3 final变量final修饰的变量为常量，常量一般同时使用时final和static修饰，只能被赋值一次（常量大写） 1static final int a=10; 3. 抽象类6.1 抽象定义 抽象：模糊，不具体，看不懂 12345678910111213141516171819abstract class Animal &#123;// 定义抽象动物类 abstract void eat();// 定义抽象方法 void sleep() &#123;//定义实例方法 System.out.println(\"can sleep\"); &#125;&#125;class Person extends Animal &#123; void eat() &#123; System.out.println(\"用筷子拿着吃\"); &#125;&#125;class Bird extends Animal &#123; void eat() &#123; System.out.println(\"用嘴叼着吃\"); &#125;&#125; 6.2 抽象特点方法只有声明没有实现时，该方法就是抽象方法，被abstract修饰，抽象方法必须定义在抽象类中。 抽象类不可以被实例化【调用抽象方法没有意义】 抽象类的子类，必须重写抽象类的所有抽象方法才可以实例化，否则，子类还是抽象类 6.3 抽象细节 抽象类有构造函数，给子类对象进行初始化 抽象类可以不定义抽象方法【一般这种类主要是不让创建对象】 抽象关键字不可以和哪些关键字共存【private不行，static不行，final不行】 抽象类和一般类的异同 ​ 相同：描述事物，都在内部定了成员 ​ 不同点： ​ 1 一般类中有足够的信息用来描述事物，抽象类描述不足 ​ 2 一般类中，不可以定义抽象方法，但是抽象类中可以定义，也可以定义非抽象 ​ 3 一般类类可以被实例化，抽象类不可以被实例化 抽象类一定是父类【子类覆盖其方法后才可以对子类实例化】","pubDate":"Mon, 28 Oct 2019 01:02:24 GMT","guid":"https://augus-liuzhi.github.io/2019/10/28/面向对象/","category":"--satic关键字 --this关键字"},{"title":"java接口","link":"https://augus-liuzhi.github.io/2019/10/17/接口/","description":"1. 接口定义 当一个抽象类的所有方法是抽象方法的时候，这时可以将该抽象类用另一种形式和定义来表示，那就是接口 interface【接口和抽象类似，必须全部覆盖接口类的所有抽象方法】 定义接口关键字：interface 123456interface demo &#123; abstract void show(); abstract void show1();&#125; 对于接口中常见的成员，这些成员都有固定修饰符 全局常量：public static final 抽象方法：public abstract void show(); 结论：接口的成员都是公共权限 2. 接口的实现 类与接口之间的关系是实现，类与类之间是继承关系 接口不能实例化，只能由实现类覆盖接口类的所有方法，实现类才可以实例化 1234567891011121314151617181920212223242526272829public class Implementtext &#123; public static void main(String[] args) &#123; demoimpl d = new demoimpl(); System.out.println(d.num); System.out.println(demo.num);//静态类名调用 System.out.println(demoimpl.num);//静态类名调用 d.show(); d.show1(); &#125;&#125;interface demo &#123; public static final int num = 10;//按照格式写 public abstract void show();//按照格式写 public abstract void show1();//按照格式写&#125;class demoimpl implements demo &#123; public void show() &#123; System.out.println(\"show\"); &#125; public void show1() &#123; System.out.println(\"show1\"); &#125;&#125; java不支持多继承，会出现不确定调用，进行多继承改良，采用多实现 多实现：一个类可以实现多个接口 123456789101112131415161718interface A &#123; public abstract int add(int a, int b);&#125;interface B &#123; public abstract void show();&#125;class Text implements A, B &#123; public void show() &#123; System.out.println(\"show方法执行\"); &#125; public int add(int a, int b) &#123; return a + b + 3; &#125;&#125; 一个类继承另一类的时候还可以实现多个接口 接口的出现避免单继承的局限性 123456789101112131415161718192021222324252627282930interface gg &#123;//接口gg public void show();&#125;interface mm &#123;//接口mm public void see();&#125;interface Person extends gg, mm &#123;// 接口和接口之间是继承关系，而且还是多继承 public void fun();&#125;class Q implements Person &#123;//类Q有3个方法 @Override public void show() &#123; &#125; @Override public void see() &#123; &#125; @Override public void fun() &#123; &#125;&#125; 接口和抽象类的区别 相同点：都是向上抽取来的 不同点： ​ 抽象类需要被继承，而且单继承，接口需要被实现，可以多实现 ​ 抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法，但是接口中只能 定义抽象方法必须有子类去实现 ​ 抽象类的继承是 is a 关系，定义体系内共性内容，接口的实现是like a关系，定义的体系额外功能 用一个例子来说明 1234567891011121314151617181920212223242526272829303132333435363738abstract class dog &#123;//定义犬类 String name;//有名字 int age;//有年龄 void eat() &#123;//能吃 System.out.println(\"can eat\"); &#125; abstract void sleep();//能睡，不同狗睡的地方不一样&#125;interface fun_seek &#123;//定义额外功能接口 public abstract void seekroad();//认路&#125;interface fun_look //定义额外功能接口 public abstract void lookfor();//查毒&#125;class eyedog extends dog implements fun_seek &#123;//定义导盲犬继承犬类的共性，并添加认路的功能 void sleep() &#123;//重写抽象类睡觉的方式 System.out.println(\"在主人家睡觉\"); &#125; public void seekroad() &#123;//重写添加的认路功能 System.out.println(\"俺认识路\"); &#125;&#125;class lookdog extends dog implements fun_look &#123;//定义缉毒犬继承犬类共性，并添加找毒的功能 void sleep() //重写抽象类睡觉的方式 System.out.println(\"在警察局睡觉\"); &#125; public void lookfor() &#123;//重写添加找毒的功能 System.out.println(\"俺可以查毒\"); &#125;&#125;","pubDate":"Thu, 17 Oct 2019 10:46:14 GMT","guid":"https://augus-liuzhi.github.io/2019/10/17/接口/","category":""},{"title":"Java面向对象——继承","link":"https://augus-liuzhi.github.io/2019/10/15/继承/","description":"1. 继承的概述 继承就是子类继承父类的变量和方法，下面用代码解释一下： 1234567891011121314151617class Student &#123;// 定义学生类 String name; int age; void study() &#123; System.out.println(name + \"studay good\" + age); &#125;&#125;class Work &#123;// 定义工人类 String name; int age; void work() &#123; System.out.println(name + \"work good\" + age); &#125;&#125; 从上述例子中可以看到，学生类和工人类都有共同的特征，为了实现代码复用性，进行抽取，java中抽取用类表示将共有的的行为或特征进行抽取，然后原来的来类也要可以用，我们就需要用原来类继承我们抽取的类，用extends关键字进行调用，如： 12345678910111213141516class Student extends Person &#123;// 定义学生类 void study() &#123; System.out.println(name + \"studay good\" + age); &#125;&#125;class Work extends Person &#123;// 定义工人类 void work() &#123; System.out.println(name + \"work good\" + age); &#125;&#125;class Person &#123;// 定义我们抽取的类 String name; int age;&#125; 通常称Person（被继承的类）类为父类（也叫操类，基类），称Work和Student（继承类）称为子类。 2. 继承的优点 提高代码复用性 让类与类产生关系，给多态提供了前提 java支持单继承，不支持多继承，对C++多继承进行改良 单继承：一个子类只能有一个直接父类 1234567891011class A &#123;&#125;class B &#123;&#125;class C extends A &#123;&#125; 或者 1234567891011class A &#123;&#125;class B &#123;&#125;class C extends B &#123;&#125; 多继承：一个子类能有多个直接父类(为什么不能多继承)【不直接支持，会产生调用的不确定性】 123456789101112131415class A &#123; void show() &#123; System.out.println(a); &#125;&#125;class B &#123; void show() &#123; System.out.println(b); &#125;&#125;class C extends A,B &#123;&#125; 当我们new c();调用show方法，调用的是A的还是B的？为了区分java对此进行了改良，不用多继承，用接口 java支持多层（多重继承）=&gt;传递性 1234567891011class A &#123; &#125;class B extends A &#123; &#125;class C extends B &#123;&#125; 3. 类的继承原则 单继承 继承具有传递性 继承不能循环 除Object类，所有类都有父类 4. 继承的使用当要使用一个继承体系时，如何使用 ? 查看该体系中顶层类，了解该体系的基本功能。 创建该体系中最子类的对象，完成功能的使用。 什么时候写继承？ 当类存在所属关系，就定义继承，A属于B,则A继承B 5. 继承中的成员变量当本类局部和成员变量名相同时用this区分 当子父类中成员变量相同时用super区分 this和super的用法很相似 this：代表一个本类对象的引用 super：代表一个父类空间 1234567891011class A &#123; int num = 5;&#125;class B extends A &#123; int num = 10; void show() &#123; System.out.println(this.num + \"……\" + super.num);//调用子类和父类的成员变量 &#125;&#125; 注意：子类不能直接访问父类的私有成员 6. 继承中的成员方法1234567891011121314151617181920212223class A &#123; int num = 5; void show1() &#123; System.out.println(num); &#125;&#125;class B extends A &#123; int num = 10; void show2() &#123; System.out.println(num); &#125;&#125;public class Extendstext &#123; public static void main(String[] args) &#123; B b = new B(); b.show1(); b.show2(); &#125;&#125; 当子父类中函数一样，将会运行子类的函数，称为覆盖操作 12345678910111213141516171819202122class A &#123; int num = 5; void show() &#123; System.out.println(num); &#125;&#125;class B extends A &#123; int num = 10; void show() &#123; System.out.println(num); &#125;&#125;public class Extendstext &#123; public static void main(String[] args) &#123; B b = new B(); b.show(); &#125;&#125; 6.1 函数的两个特性 重载：同一个类 覆盖：子类中，覆盖也叫重写 6.2 注意事项 子类的方法覆盖父类方法时，子类的权限必须大于父类的权限 静态只能覆盖静态，或被静态覆盖 6.3 什么时候使用覆盖操作当对一个类进行子类扩展时，子类需要保留父类的功能声明，但要定义子类中功能的特有内容时，就用覆盖操作完成。(修改方法，添加功能)如： 12345678910111213141516171819202122232425class Phone &#123;// 定义一个手机类 void call() &#123;// 通话功能 &#125; void show() &#123;// 展示功能 System.out.println(\"number\"); &#125;&#125;class newphone extends Phone &#123; void show() &#123;// 展示功能重写 System.out.println(\"name\"); System.out.println(\"jpg\"); System.out.println(\"number\"); &#125;&#125;或者class newphone extends Phone &#123; void show() &#123;// 展示功能重写 System.out.println(\"name\"); System.out.println(\"jpg\"); super.show();//调用父类show方法 &#125;&#125; 7. 继承中的构造函数在子类构造对象时，访问子类构造函数时，父类也运行，在子类的构造函数中，有一个默认的隐士语句，super();调用父类中空参数的构造函数，无覆盖，无继承 无参数 123456789101112class fu &#123; fu() &#123; System.out.println(\"fu run\"); &#125;&#125;class zi extends fu &#123; zi() &#123; super();//隐士自带的调用父类空参数构造函数 System.out.println(\"zi run\"); &#125;&#125; 有参数 123456789101112class fu &#123; fu(int x) &#123; System.out.println(\"fu run\"); &#125;&#125;class zi extends fu &#123; zi() &#123; super(4);//隐士自带的调用父类空参数构造函数 System.out.println(\"zi run\"); &#125;&#125; 子类的实例化过程，子类中的每个构造函数都会访问父类中空参数的构造函数 结果：AC AD 123456789101112131415161718192021222324public class Extendstext &#123; public static void main(String[] args) &#123; new zi(); new zi(6); &#125;&#125;class fu &#123; fu()&#123; System.out.println(\"A\"); &#125; fu(int x) &#123; System.out.println(\"B\"); &#125;&#125;class zi extends fu &#123; zi() &#123; System.out.println(\"C\"); &#125; zi(int x)&#123; System.out.println(\"D\"); &#125;&#125; 结果：BD 123456789101112131415161718192021222324public class Extendstext &#123; public static void main(String[] args) &#123; new zi(6); &#125;&#125;class fu &#123; fu()&#123; System.out.println(\"A\"); &#125; fu(int x) &#123; System.out.println(\"B\"); &#125;&#125;class zi extends fu &#123; zi() &#123; System.out.println(\"C\"); &#125; zi(int x)&#123; super(x);//覆盖隐式super(); System.out.println(\"D\"); &#125;&#125; 为什么自子类实例化的时候，会调用父类构造方法？ 子类继承父类，所以子类有父类的属性，在使用父类内容前，要先看父类如何对自己的内容进行初始化，所以子类构造函数初始化的时候，必须调用父类构造函数，所以在子类的构造函数默认加了super(); 如果父类中没有定义无参构造函数或者说是父类中定义了有参，没有定义无参，那么必须用super();来指定调用父类的构造函数 如果子类的构造函数中使用了this();调用本类的构造函数，那么super();就没有了，因为super和this只能定义在第一行，所以只能有一个，但是可以保证的是，子类中肯定会有其他构造方法来访问父类的构造函数。 注意：super();语句必须要定义在子类构造函数的第一行，因为父类的初始化要先完成","pubDate":"Tue, 15 Oct 2019 12:08:31 GMT","guid":"https://augus-liuzhi.github.io/2019/10/15/继承/","category":""}]}