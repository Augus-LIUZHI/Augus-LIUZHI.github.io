{"title":"哈哈，你不行","description":"my blog","language":"en","link":"https://augus-liuzhi.github.io","pubDate":"Wed, 28 Oct 2020 07:29:51 GMT","lastBuildDate":"Mon, 16 Nov 2020 11:14:53 GMT","generator":"hexo-generator-json-feed","webMaster":"哈哈，你不行","items":[{"title":"","link":"https://augus-liuzhi.github.io/2020/10/28/并发编程/","description":"创建和运行线程方法1:继承Thread类12345678910111213141516171819202122232425262728293031public class ExtendThread extends Thread&#123; static Logger logger=Logger.getLogger(ExtendThread.class); @Override public void run() &#123; logger.info(\"running\"); &#125; public static void main(String[] args) &#123; ExtendThread thread=new ExtendThread(); thread.setName(\"线程T\"); thread.start(); logger.info(\"running\"); &#125;&#125;//使用匿名内部类public class Test &#123; public static void main(String[] args) &#123; final Logger logger=Logger.getLogger(Test.class); //创建线程 Thread thread=new Thread()&#123; @Override public void run() &#123; logger.info(\"111\"); &#125; &#125;; //设置线程名 thread.setName(\"线程T\"); //启动线程 thread.start(); logger.info(\"2222\"); &#125;&#125; 方法2:实现Runnable接口12345678910111213public class Run implements Runnable &#123; static Logger logger=Logger.getLogger(Run.class); public void run() &#123; logger.info(\"1111\"); &#125; public static void main(String[] args) &#123; Run run=new Run(); Thread thread=new Thread(run); thread.setName(\"线程T\"); thread.start(); logger.info(\"22222\"); &#125;&#125; 12使用lambda表达式 Runnable runnable1= () -&gt; logger.info(\"1111\"); 方法3:实现Callable接口1234567891011121314public class Call implements Callable&lt;String&gt;&#123; Logger logger=Logger.getLogger(Call.class); @Override public String call() throws Exception &#123; String s=\"123\"; logger.info(s); return s ; &#125; public static void main(String[] args) &#123; Call call=new Call(); FutureTask futureTask=new FutureTask(call); new Thread(futureTask).start(); &#125;&#125;","pubDate":"Wed, 28 Oct 2020 07:29:51 GMT","guid":"https://augus-liuzhi.github.io/2020/10/28/并发编程/","category":""},{"title":"","link":"https://augus-liuzhi.github.io/2020/10/23/MySql/","description":"数据库相关概念 DB: 数据库，保存一组有组织的数据的容器 DBMS : 数据库管理系统，就是数据库管理软件，用来管理DB中的数据 SQL : 结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点 将数据放在表中，再将表放到数据库中 一个数据库可以有多个数据表，表名具有唯一性 表有一些特性 表每列称为一个字段，表中数据按行存储。 Mysql产品的介绍和安装Mysql服务的启动和停止1234567方式1：计算机--&gt;右键管理--&gt;服务和应用程序--&gt;服务--&gt;mysql方式2：管理员身份cmd命令net stop mysqlnet start mysql MySql的登陆和退出1234567win--&gt;cmd登陆mysql -h 主机名 -P 端口号 -u 用户名 -p 密码退出：exit或者ctrl+c Mysql常见命令1234567891011121314151617显示数据库：show databases;进入test数据库：use test;查看数据表：show tables;创建数据表：create table 表名（列名 列类型，列名 列类型，……）;查看当前所在数据库：select database();查看某个数据库中的数据表：show tables from mysql;查看数据表的结构：desc students;查看表的内容 ： select * from 表名；查看当前数据库版本：select version(); Mysql语法规范12345671. 不区分大小写，建议关键字大写，表名、列名小写2. 每条命令用分号结尾3. 每条命令根据需要，可以进行缩进换行4. 注释 单行注释：#注释文字 单行舒适：-- 注释文字 多行注释：/* 注释文字 */ Mysql查询基础查询1234567891011121314151617181920212223242526272829303132333435363738394041#进阶1：基础查询/*语法：select 查询列表 from 表名;查询列表可以是：表中字段、常量值、表达式、函数查询结果是一个虚拟表格*/#打开库USE student;#1. 查询表中的单个字段SELECT NAME FROM student;#2. 查询表中的多个字段SELECT NAME,age,xuehao FROM student;#3. 查询表中所有字段SELECT * FROM student;#4. 查询常量SELECT 1;SELECT &apos;hdsdhsadihis&apos;;#5. 查询表达式SELECT 100*98;#6. 查询函数SELECT VERSION();#7. 起别名/*便于理解区分重名字段*/# 方式1SELECT 100*98 AS 结果;SELECT NAME AS 姓名 FROM student;# 方式2 SELECT NAME 姓名2 FROM student;#8. 去重SELECT DISTINCT chengji FROM student;#9. +号的作用,运算符/*1. 一方为null，结果为null2. 两边都是数值，做加法运算3. 一方数值，一方字符，将字符转换成数值再加，如果转换失败，则就是0+数值*/SELECT CONCAT(NAME,IFNULL(chengji,0)) AS 姓名和成绩 FROM student; 进阶查询123456789101112131415161718192021222324252627282930313233343536373839404142#进阶2：条件查询/*语法： select 查询列表 from 表名 where 筛选条件;分类： 1. 条件表达式筛选 条件运算符：＞ ＜ ＝ ！＝ ＜＞ ＞＝ ＜＝ 2. 逻辑表达式筛选 逻辑运算符：＆＆ ｜｜ ！ and or not 3. 模糊查询 between and like in is null*/#1. 按照条件表达式筛选#查找成绩大于80fen的SELECT * FROM student WHERE chengji&gt;80;#查找年龄不等于20岁的姓名和年龄SELECT NAME,age FROM student WHERE age!=20;SELECT NAME,age FROM student WHERE age&lt;&gt;20;#2. 按照逻辑表达式筛选#查找成绩成绩在60-90之间的姓名和成绩SELECT NAME,chengji FROM student WHERE chengji&gt;60 AND chengji&lt;90;#3. 模糊查询#1. like 一般和通配符搭配使用 %任意多个字符 _任意单个字符#查找姓名中包含字符a的学生信息SELECT * FROM student WHERE NAME LIKE &apos;a%&apos;;#查询第一个字符为w，第3个字符为nSELECT * FROM student WHERE NAME LIKE &apos;w_n_&apos;;#查询姓名中第二个字符为下划线SELECT * FROM student WHERE NAME LIKE &apos;_\\_%&apos;;#\\转译SELECT * FROM student WHERE NAME LIKE &apos;_$_%&apos; ESCAPE &apos;$&apos;;#escape 转译#2. between and#查找成绩在60到90之间,包含60 90，闭区间，不能颠倒顺序SELECT * FROM student WHERE chengji BETWEEN 60 AND 90;#3. in 通俗来讲可以理解为=SELECT * FROM student WHERE chengji IN(60,80,90);#4. is null 查找null值 is not nullSELECT * FROM student WHERE chengji IS NOT NULL;#安全等于 &lt;=&gt; 可以判断null,也可以判断普通数值SELECT * FROM student WHERE chengji&lt;=&gt;NULL;SELECT * FROM student WHERE chengji&lt;=&gt;100; 排序查询12345678910111213141516171819#进阶3：排序查询/*select 列表 from 表名 【where 筛选条件】order by 排序列表1 【asc|desc】,排序列表2【asc|desc】,如果不写默认是升序排序列表可以是单个字段，多个字段，表达式，函数，别名order by 放在查询语句最后面，limit除外！！！*/#1. 按照某一项排序SELECT * FROM student ORDER BY chengji ASC;SELECT * FROM student ORDER BY chengji DESC;#2. 按照筛选条件排序SELECT * FROM student WHERE chengji&gt;60 ORDER BY xuehao;#3. 按照表达式或者别名排序SELECT *,IFNULL(chengji,0)*12 AS 总成绩 FROM student ORDER BY IFNULL(chengji,0)*12 DESC;SELECT *,IFNULL(chengji,0)*12 AS 总成绩 FROM student ORDER BY 总成绩 ASC;#4. 按照姓名的长度显示姓名和成绩SELECT LENGTH(NAME) AS 姓名长度,NAME,chengji FROM student ORDER BY LENGTH(NAME) DESC;#5. 先按照成绩排序，再按照学号排序SELECT * FROM student ORDER BY chengji DESC,xuehao DESC; 常见函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#进阶4：常见函数/*概念：类似java方法，将一组逻辑语句封装在方法体中，对外暴露方法名好处：1. 隐藏了实现细节 2. 提高代码复用性调用：select 函数（实参列表） 【from 表】;特点：函数名,函数功能,分类：1. 单行函数 concat length ifnull 2. 分组函数 做统计使用又称为统计函数【聚合函数】*/#1.字符函数 #length 获取参数值的字符个数SELECT LENGTH(&apos;john&apos;);SELECT LENGTH(&apos;哈哈&apos;);#concat 拼接字符SELECT CONCAT(NAME,chengji) FROM student;#upper(),lower()大小写SELECT UPPER(&apos;sjdj&apos;);SELECT LOWER(&apos;ASD&apos;);#substr、substring#截取指定索引处后面所有字符SELECT SUBSTR(&apos;abcd&apos;,2);#截取从指定索引处指定字符长度的字符SELECT SUBSTR(&apos;abcdefg&apos;,1,3);#姓名中首字母大写，其余字母小写SELECT CONCAT(UPPER(SUBSTR(NAME,1,1)),&apos;_&apos;,LOWER(SUBSTR(NAME,2))) FROM student;#instr 返回子串第一次出现的索引，找不到返回值0SELECT INSTR(&quot;abcdefg&quot;,&apos;efg&apos;);#trim 去前后空格SELECT TRIM(&apos; ggjj &apos;);SELECT TRIM(&apos;a&apos; FROM &apos;aaaaa369aaaaa&apos;);#lpad 左填充指定长度字符 rpad 右填充指定长度SELECT LPAD(&apos;abcdefg&apos;,2,&apos;*&apos;);SELECT RPAD(&apos;asdc&apos;,5,&apos;*&apos;);#replace 替换所有指定字符SELECT REPLACE(&apos;abcdefg&apos;,&apos;g&apos;,&apos;G&apos;);#2. 数学函数#roundSELECT ROUND(1.65);SELECT ROUND(1.657,2);#ceil 向上取整 返回大于等于参数的最小整数#floor 向下取整 返回小于等于参数的最大整数SELECT CEIL(1.00);SELECT FLOOR(2.3);#truncate 截断SELECT TRUNCATE(1.66666,1);#mod 取余SELECT MOD(10,3);SELECT 10%3;#日期函数#now 返回当前系统时间SELECT NOW();#curdate 返回当前系统日期，不反回时间SELECT CURDATE();#cuetime 返回当前时间，不返回日期SELECT CURTIME();#获取指定部分的年，月，日，小时，分钟，秒SELECT YEAR(NOW());SELECT YEAR(NOW() AS 年 ;SELECT MONTH(NOW()) AS 数字月;SELECT MONTHNAME(NOW()) AS 英文月;#str_to_date 将字符转换成指定格式SELECT STR_TO_DATE(&apos;2022-2-17&apos;,&apos;%Y-%m-%d&apos;);#date_format 将日期转换成字符SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;);#4. 其他函数SELECT VERSION();SELECT DATABASE();SELECT USER();#5. 流程控制函数#if函数SELECT IF(10&gt;5,&apos;大&apos;,&apos;小&apos;);#case函数/*用法：case 要判断字段或表达式when常量1 then 语句1； when常量2 then 语句2；else 要显示的值n,或语句；end */#case使用1SELECT IFNULL(chengji ,0) AS 成绩,CASE FLOOR(chengji/10)WHEN 10 THEN &apos;A&apos;WHEN 9 THEN &apos;A&apos;WHEN 8 THEN &apos;B&apos;WHEN 7 THEN &apos;C&apos;ELSE &apos;D&apos;END AS 评定FROM student ORDER BY chengji DESC;#case使用2SELECT IFNULL(chengji,0) AS 成绩,CASEWHEN chengji&gt;90 THEN &apos;A&apos;WHEN chengji&gt;80 THEN &apos;B&apos;ELSE &apos;C&apos;ENDAS 评定FROM student ORDER BY chengji DESC; 分组函数12345678910111213141516171819#分组函数/*功能：用作统计使用，又称为聚合函数或统计函数或分组函数分类：sum 和 avg平均值 参数类型整型 ，忽略null值max min count计算个数 参数任何类型支持，忽略null值可以和distinct搭配，实现去重运算count 函数 计算非null值的个数和分组函数一同查询字段有限制,要求是group by后的字段*/SELECT SUM(chengji) FROM student;SELECT AVG(chengji) FROM student;SELECT MAX(chengji) FROM student;SELECT COUNT(chengji) FROM student;SELECT SUM(chengji) 和,COUNT(chengji) 一共,AVG(chengji)平均值 FROM student;SELECT SUM(DISTINCT chengji),SUM(chengji) FROM student;SELECT COUNT(*) FROM student;SELECT COUNT(chengji) FROM student;SELECT AVG(chengji),chengji FROM student;","pubDate":"Fri, 23 Oct 2020 01:14:12 GMT","guid":"https://augus-liuzhi.github.io/2020/10/23/MySql/","category":""},{"title":"CSS","link":"https://augus-liuzhi.github.io/2020/10/15/CSS/","description":"","pubDate":"Thu, 15 Oct 2020 13:03:33 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/CSS/","category":""},{"title":"HTML","link":"https://augus-liuzhi.github.io/2020/10/15/HTML/","description":"","pubDate":"Thu, 15 Oct 2020 13:03:03 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/HTML/","category":""},{"title":"JS","link":"https://augus-liuzhi.github.io/2020/10/15/JS/","description":"JavaScript基本语法变量声明123var num;声明变量num=100;document.write(num); 变量类型 变量的基本类型有Number,String,Boolean,Undefined,Null 1234567声明数字var a=1;声明字符串var a=\"hello\"或者var a='hello'声明一个布尔类型var a=true当一个变量未被初始化的时候，它的值为undefined 引用类型1234var student=&#123;id:1,name:\"张三\",age:20&#125;document.write(student.id);document.write(student.name);document.write(student.age); 数组类型123var a=[1,2,3,4]alert(a[1]);alert(a[a.length-1]); 运算符 名称 运算符 加 + 减 - 乘 * 除 / 求余 % 赋值 = 加等 += 减等 -= 乘等 *= 除等 /= 求余等 %= 与 &amp;&amp; 或 \\ \\ 非 ！ 小于 &lt; 大于 &gt; 小于等于 &lt;= 大于等于 &gt;= 等于 == 不等于 != 自增 ++ 自减 – 三目 ？： 条件分支 if-else switch 循环结构 for while do-while 函数12345function fun(num1,num2)&#123; return num1+num2; &#125;var num=fun(10,20); alert(num); 弹框 alert(“hello”); confirm(“hello”); prompt(“hello”) 1234567var res=confirm(\"是否确定\"); if(res)&#123; alert(\"success\"); &#125; else&#123; alert(\"fail\"); &#125; 12var res=prompt(\"请输入参数\")； alert(res); 事件onclick事件 123456789//点击事件&lt;body&gt; &lt;script type=\"text/javascript\"&gt; function fun()&#123; alert(\"hihi\"); &#125; &lt;/script&gt; &lt;button onclick=\"fun()\"&gt;普通按钮&lt;/button&gt; &lt;/body&gt; onload事件 12 正则表达式修饰符 修饰符 描述 i 忽略大小写 g 全局匹配 m 多行匹配 支持正则表达式的String对象 方法 描述 search 检索与正则表达式相匹配的值 match 找到一个或多个正则表达式的匹配 replace 替换与正则表达式匹配的字符串 split 把字符串分割为字符数组 正则表达式对象的方法 方法 描述 comlile 编译正则表达式 exec 检索字符串中指定的值，返回找到的值，并确定其位置 test 检索字符串中指定的值，返回true或false JavaScript的DOM对象查找HTML元素123456//通过id查找html元素document.getElementById(id)//通过标签名找到HTML元素document.getElementsByTagName(name)//通过类名找到HTML元素document.getElementsByClassName(className) 改变HTML的内容1234&lt;p id=\"p1\"&gt;Hello world&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById(\"p1\").innerHTML=\"abcd\"; &lt;/script&gt; CSS变化123456789101112&lt;style type=\"text/css\"&gt; #p1&#123;width: 200px;height:200px; background-color: yellow;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"p1\"&gt;Hello world&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var p1=document.getElementById(\"p1\"); p1.style.width=\"400px\"; p1.style.backgroundColor=\"blue\"; p1.style.height=\"400px\"; &lt;/script&gt; DOM事件123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; #p1&#123; width: 200px; height:400px; background-color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; function fun()&#123; var p1=document.getElementById(\"p1\"); var x,y,z; x=Math.ceil(Math.random()*255); y=Math.ceil(Math.random()*255); z=Math.ceil(Math.random()*255); p1.style.backgroundColor=\"rgb(\"+x+\",\"+y+\",\"+z+\")\"; &#125; &lt;/script&gt; &lt;p id=\"p1\"&gt;hello&lt;/p&gt; &lt;button onclick=\"fun()\"&gt;普通按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; addEventListener12345678910111213141516171819202122232425262728293031323334353637383940414243444546addEventListener(event, listener, useCapture)event事件listener函数useCpature事件的传递方式（冒泡或者捕获）默认是冒泡事件的执行顺序冒泡：内——》外捕获：外——》内//同一元素绑定一个事件//同一元素绑定多个事件//多个元素绑定同一事件&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; #p1&#123; width: 200px; height:400px; background-color: yellow; &#125; #p2&#123; width: 200px; height:400px; background-color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"p1\"&gt;&lt;/div&gt; &lt;div id=\"p2\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function fun1()&#123; alert(\"事件1\"); &#125; function fun2()&#123; alert(\"事件2\"); &#125; var p1=document.getElementById(\"p1\"); p1.addEventListener(\"click\", fun1()); p1.addEventListener(\"mouseover\",fun2()); var p2=document.getElementById(\"p2\"); p2.addEventListener(\"click\", fun1()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器BOMwindow的尺寸","pubDate":"Thu, 15 Oct 2020 13:02:29 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/JS/","category":""},{"title":"JSP","link":"https://augus-liuzhi.github.io/2020/10/15/JSP/","description":"","pubDate":"Thu, 15 Oct 2020 13:01:53 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/JSP/","category":""},{"title":"Jquery","link":"https://augus-liuzhi.github.io/2020/10/15/Jquery/","description":"","pubDate":"Thu, 15 Oct 2020 13:00:34 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/Jquery/","category":""},{"title":"Maven","link":"https://augus-liuzhi.github.io/2020/10/15/Maven/","description":"MavenMaven介绍maven主要是用来做依赖管理和项目构建 Maven的安装 maven下载 解压 配置环境变量 12新建MAVEN_HOME变量，值为安装位置在path中添加%MAVEN_HOME%\\bin 测试 cmd中使用mvn -v的命令 Maven配置本地仓库 新建一个文件夹，作为本地仓库，在set.xml中配置 1&lt;localRepository&gt;H:\\Maven\\repository&lt;/localRepository&gt; JDK配置 12345678910111213&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; Maven仓库 存储依赖的地方 仓库不仅存放依赖，每个依赖都有唯一标识（坐标），供java项目管理 仓库分类 本地仓库 远程仓库 1.中央仓库 2.公共仓库 3.私服 当需要依赖时会从仓库中查找顺序 本地仓库——&gt;私服——&gt;公共仓库——&gt;中央仓库 本地仓库 所有用过的依赖，都会自动存储到本地仓库中一份，供下一次使用 中央仓库 Maven官方提供，不用配置 公共仓库 阿里云仓库 123456&lt;mirror&gt;&lt;id&gt;alimaven&lt;/id&gt;&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;name&gt;aliyun maven&lt;/name&gt;&lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt; 依赖生命周期test 测试时 compile 编译时 runtime 运行时 provided 需要时 Maven指令clean 清楚上次编译 compile 编译 package 打包 install 打包并且存储到本地仓库","pubDate":"Thu, 15 Oct 2020 04:38:21 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/Maven/","category":""},{"title":"Git分布式版本控制器","link":"https://augus-liuzhi.github.io/2020/10/15/Git/","description":"Git1.引言 单人开发过程中，需要进行版本控制，利于开发进度的控制 多人开发过程中，不仅需要版本管理，还需要进行多人协同控制 2.介绍开源的分布式版本控制系统 3.安装下载地址 安装除了位置，其他直接下一步就行了 1234567#安装后，打开cmd，自报家门git config --global user.name \"your name\" #用户名git config --global user.email \"1759586066@qq.com\" #邮箱#查看信息git config -l#测试：查看版本git version 4.架构 版本库：工作区有一个隐藏目录.git,这个目录不属于工作区，而是git的版本库，是git管理的所有内容 暂存区：版本库中的一个临时区域，保存还需提交文件。 分支：版本库中包含若干分支，提交的文件存储在分支中 架构图 工作区—add—版本库中的暂存区—commit—分支 5.仓库 对应的就是一个目录，这个目录的所有文件被git管理。 以后会将一个项目的根目录，作为仓库 仓库中每个文件的改动都由git跟踪 5.1新建仓库 选择一个文件夹，执行git init,则该文件夹就是一个仓库了 执行完会生成一个.git的文件，该文件就是版本库，包含暂存区和分支 5.2工作区工作区就是该文件 5.3暂存区位于.git目录中 5.4分支位于.git目录中 6.基本操作6.1查看状态1git status 6.2暂存文件1git add 文件名 通过该指令，将指定文件暂存到版本库中的暂存区中 6.3提交文件1git commit -m \"提交的描述信息\" 将暂存区的文件提交到分支，形成一个版本 7.远程仓库 多人之间需要共享代码，合并代码，这就需要一个远程仓库 7.1远程仓库的工作模式程序员1——&gt;(push,pull,clone)远程仓库(push,pull,clone)&lt;——程序员2 7.2远程仓库的选择 1.github 2.gitee 7.3基本操作 注册github服务器账户 搭建仓库 本地关联远程仓库 1git remote add origin https://github.com/Augus-LIUZHI/Repo1.git origin是一个别名就是远程仓库的地址 推送到远程 1git push origin master 将分支中的提交到远程仓库origin 克隆远程仓库到本地 1git clone 远程仓库地址 从远程仓库复制到本地形成一个本地仓库 代码共享 1git pull 远程仓库地址 从远程仓库下载到本地仓库 8.分支分支：就是一个个版本最终存储的位置 分支：就是一条时间线，每次git commit形成一个个版本，一个个版本存储在分支的一个个提交点上 分支由多个提交点组成，分支上有一个指针，默认总是指向最新的提交点 基本操作 查看分支 1git branch 创建分支 1git branch 分支名 切换分支 1git checkout dev 分支提交日志 1git log --oneline/git log 该指令，可以查看每个提交点 分支合并 1git merge 分支名 将另一个分支合并到当前分支 合并方式 ​ 快速合并(一个分支变化，另一个分支不变) ​ 三方合并（两个分支都在变化） 处理冲突 修改冲突的文件的内容 ​","pubDate":"Thu, 15 Oct 2020 04:38:04 GMT","guid":"https://augus-liuzhi.github.io/2020/10/15/Git/","category":""},{"title":"Vue","link":"https://augus-liuzhi.github.io/2020/10/07/VUE/","description":"Vue概述Vue：渐进式JavaScript框架","pubDate":"Wed, 07 Oct 2020 12:47:08 GMT","guid":"https://augus-liuzhi.github.io/2020/10/07/VUE/","category":""},{"title":"Java基础知识","link":"https://augus-liuzhi.github.io/2020/10/07/java基础知识/","description":"Java概述什么是javajava是一种面向对象的编程语言 jdk1.5之后的三大版本 java SE java EE java ME JVM,JRE和JDK的关系JVM：java virtual Machine是java虚拟机,java程序需要运行在java虚拟机上，不同的平台有自己的虚拟机，因此java语言实现了跨平台 JRE: Java Runtime Environment包括java虚拟机和java程序所需要的核心类库（java.lang包）如果只运行java程序，只安装jre就可以了 JDK : Java Development Kit(java开发工具包)，包含了JRE和java开发工具（编译工具javac.exe,打包工具jar.exe） 什么是跨平台？原理是什么？跨平台：指的是java程序一次编译，可以在多个平台上运行 原理：java程序的运行时通过java虚拟机，只要该系统安装了java虚拟机就可以运行java程序 java语言特点 面向对象 平台无关性 多线程 健壮性（强类型机制，异常处理，垃圾自动回收） 网络编程（支持网络编程） 什么是字节码，字节码的好处？字节码：java源代码经过虚拟机编译后产生的文件（扩展名为.class的文件），不面向任何处理器，只面向虚拟机 好处：解决了解释型语言的效率低的问题，又保留解释型语言的可移植性的特点 Java和c++的区别 都是面向对象的语言 c++有指针，java没有指针 java是单继承，c++支持多继承 java有自动内存管理机制 基础语法数据类型java的数据类型 基本数据类型 ​ 1. 数值型：整数类型，浮点类型 ​ 2. 字符型 ​ 3. 布尔型 引用数据类型 ​ 1. 类 ​ 2. 接口 ​ 3. 数组 switch语句的数据类型 除long以外的整型 char enum String 注释 单行注释//注释文字 多行注释/注释文字 / 文档注释/*注释文字 / 访问修饰符 修饰符 当前类 同包 子类 其他包 private Y N N N default Y Y N N protected Y Y Y N public Y Y Y Y 运算符&amp;和&amp;&amp;的区别&amp;：1 按位与 2 逻辑与 &amp;&amp;：短路与运算符 |：逻辑或 ||：短路或运算符 关键字gotojava中没有goto，goto是保留字 final修饰类，属性和方法 修饰的类不可以被继承，修饰的方法不可以被重写，修饰变量不可以被改变 final，finally，finalizefinal: finally:用在try-catch语句块后 finalize: 是一个方法，属于Object类的一个方法，该方法由垃圾回收器调用，当我们调用System.gc()方法的时候，垃圾回收器会调用finalize（）回收垃圾 this this:代表对象本身 形参名与成员变量名重复用this来区分 this():引用本类的构造函数（位于构造函数的第一行） super super:代表父类 子类中的成员变量和方法与父类同名时，可以用super区分 super()调用父类的构造方法（位于构造函数的第一行） super和this的区别this和super不能同时出现在同一个构造函数中 this和super都指的是对象，不可以在static环境中使用 this指向本对象，super只是一个关键字 staticstatic块可以置于类中任何地方，类中可以有多个static块，类加载的时候会依次执行static块，每个static块只会执行一次 独特之处 被static修饰的方法和属性独立于该类的任何对象，也就是说这些类和变量不属于任何一个实例，但是可以被该对象的任何实例所共享 类第一次加载的时候就会加载static修饰的部分，而且在第一次类使用的时候就要加载并初始化，注意哦需要初始化，后面可以再赋值 staic在类加载的时候就会分配空间，以后创建对象的时候不会重新创建，赋值的话是随意赋值的 static修饰的变量和方法独立于对象存在，就是说一个类加载完了以后，即使没有创建对象也可以访问。 static应用场景 修饰类 修饰方法 修饰变量 静态代码块 静态导包 static注意事项 静态是能访问静态 非静态可以访问非静态，也可以访问静态 流程控制语句break 结束当前循环 continue 跳过当前循环，执行下一次循环 return 程序返回，结束执行，下面的语句不再执行 面向对象面向对象概述面向对象和面向过程的区别面向过程 是具体化，流程化，解决一个问题，一步一步分析，一步一步实现 优点：性能比面向对象高，因为类调用需要实例化，所以消耗资源 缺点：没有面向对象易维护，易复用，易扩展 面向对象 面向对象是模型化 优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，使系统更加灵活易于维护 缺点：性能比面向过程低 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，通过内部的面向过程实现外部面向对象 面向对象的三大特征抽象：抽象就是将一类的对象的共同特征总结出来构造类的过程，包含数据的抽象和行为的抽象。抽象只关注对象有哪些数据和行为，并不关注细节是什么。 封装：隐藏对象的属性和实现细节，仅对外提供访问方式 继承：继承就是使用已经存在的类的基础上创建新类的技术，新类的定义可以增加新的数据或者新的功能，也可以使用父类功能 注意： 子类拥有父类非private的属性和方法 子类可以拥有自己的属性和行为，子类对父类进行扩展 子类可以用自己的方式实现父类的方法 多态：父类或接口定义的引用变量指向子类或者具体实现类的实例对象 多态实现的条件： 方法重写 对象造型 继承/实现 面向对象的基本原则 单一职责原则 开放封闭原则 接口分离原则 类和接口抽象类和接口的对比抽象类是用来捕捉子类的通用特性，接口是抽象方法的集合 相同点 接口和抽象类都不能被实例化 都位于继承的顶端，用于被其他实现或继承 都包含抽象方法，子类必须重写抽象方法 不同点 抽象类 接口 声明 abstract interface 实现 extends,实现抽象类的所有方法 implement，实现接口的所有方法 构造器 抽象类可以有构造器 接口不能有构造器 访问修饰符 抽象类中方法可以是任意的访问修饰符 接口默认的修饰符石public,并且不允许定义为private或者protect 继承或实现 单继承 多实现（java接口可以多继承） 字段声明 抽象类中字段声明是任意的 接口的字段默认都是static和final的 普通类和抽象类有哪些区别 普通类不能包含抽象方法，抽象类可以包含抽象方法，也可以包含非抽象方法 抽象类不可以直接实例化，普通类可以直接实例化 抽象类能用final修饰么final修饰的类不可以被继承，final不能修饰抽象类 对象实例和对象引用的区别对象通过new关键字进行实例化创建对象实例，对象实例在堆内存中，对象引用在栈内存中，对象引用指向对象实例，对象引用可以指向一个对象或者不指向对象，一个对象实例可以被多个对象引用指向 变量和方法成员变量和局部变量 成员变量 局部变量 作用域 当前类 当前方法 存储位置 堆内存 栈内存 生命周期 随着对象的产生而产生，随对象销毁而销毁 语句执行完消失 初始化 有默认初始值 无默认初始值，必须初始化 构造方法调用子类的构造方法之前会先调用父类的构造方法作用是帮助子类初始化 构造方法作用是初始化，每个类中默认有一个无参数的构造函数 构造方法的特性 名字和类名相同 没有返回值 生成类的对象时自动执行，无需调用 静态变量和实例变量 静态变量：不属于任何一个实例，属于类中，内存中只有一份，在类加载的时候jvm会为它分配一次内存空间 实例变量：每次创建对象时，都会为每个对象分配成员变量的存储空间，实例变量属于对象的，在内存中创建几次对象，就会分配几次成员变量的存储空间 静态方法和实例方法 调用方式 静态方法可以使用类名.静态方法调用，实例方法，必须通过对象调用 静态方法访问本类的成员时，只允许访问静态方法和静态变量，实例方法无此限制 内部类静态内部类：定义在类中静态类 12345678910public class Outer &#123; private static int radius = 1; static class StaticInner &#123; public void visit() &#123; System.out.println(\"visit outer static variable:\" + radius); &#125; &#125;&#125; 访问 12Outer.StaticInner inner = new Outer.StaticInner();inner.visit(); 成员内部类：定义在类中的类 123456789101112public class Outer &#123; private static int radius = 1; private int count =2; class Inner &#123; public void visit() &#123; System.out.println(\"visit outer static variable:\" + radius); System.out.println(\"visit outer variable:\" + count); &#125; &#125;&#125; 访问 123Outer outer = new Outer();Outer.Inner inner = outer.new Inner();inner.visit(); 局部内部类：定义在方法中的类 匿名内部类：没有名字的内部类 重写与重载构造器不能被继承，所以不能被重写，但是可以重载 重载：发生在同一个类中，方法名相同，参数列表不同（参数个数，参数顺序，参数类型）与方法的返回值和修饰符无关，重载方法不能根据返回值类型进行区分 重写：发生在父子类中，方法名和参数列表必须相同，如果父类的访问修饰符是private子类就不是重写 对象相等判断== 判断的内存地址(基本数据类型判断的是值是否相等，引用数据类型比较的是内存地址) equals（）：它的作用判断两个对象是否相等 类没有覆盖equals方法的时候，等价于==判断的是内存地址 类覆盖equals方法的时候，判断的是两个对象的内容是否相等 注意：String对equals()进行了覆盖，因此它通常比较的是对象的内容 对象相等指的是内容相同，引用相同指的是内存地址 值传递java只有值传递 值传递：指的是方法调用后，传递参数是按值的拷贝传递，传递的是值的拷贝，传递后就互不相干了 引用传递：方法调用时，传递参数按照引用进行传递，其实传递的是引用地址，也就是变量的内存空间地址，传递的是值的引用，也就是说传递前和传递后都是指向同一个引用（也就是同一个内存空间） java包 java.lang：java基础包 java.io：输入输出有关的类 java.nio：为了完善io包的功能，提高性能而写的新包 java.net：网络相关的包 java.util：主要是集合类 java.sql：和数据库操作的类 IO流io流的分类 按照流向划分：输入流和输出流 按照操作单元划分：字节流和字符流 IO流抽象类基类 InputStream：字节输入流 Reader：字符输入流 OutputStream：字节输出流 Writer：字符输出流 BIO，NIO，AIO有什么区别 BIO:Block IO同步阻塞IO NIO:Non IO 同步非阻塞IO AIO: Asynchronous IO是NIO的升级，也叫NIO2,实现了异步非阻塞IO Files的常用方法有哪些 exists()：判断文件是否存在 creatFile()：创建文件 createDirectory：创建文件夹 delete：删除一个文件或目录 copy()：复制文件 move()：移动文件 size()：查看文件的数量 read()：读取文件 writer()：写入文件 反射java获取反射的三种方法1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制 123456public class Student &#123; private int id; String name; protected boolean sex; public float score;&#125; 123456789101112131415public class Get &#123; //获取反射机制三种方式 public static void main(String[] args) throws ClassNotFoundException &#123; //方式一(通过建立对象) Student stu = new Student(); Class classobj1 = stu.getClass(); System.out.println(classobj1.getName()); //方式二（所在通过路径-相对路径） Class classobj2 = Class.forName(\"fanshe.Student\"); System.out.println(classobj2.getName()); //方式三（通过类名） Class classobj3 = Student.class; System.out.println(classobj3.getName()); &#125;&#125; 网络编程tcp/ip协议三次握手四次挥手HTTP协议post和get的区别session和cookies的区别常用APIString相关字符型常量和字符串常量的区别形式上：字符型常量用单引号，字符串常量用双引号 含以上：字符型常量相当于一个整型值（ASCII）可以参加表达式运算，字符串常量代表地址值（该字符串在内存中存放的位置） 什么事字符串常量池字符串常量池位于堆内存中，用来存储字符串常量，可以提高内存效率，避免开辟多个内存空间存储相同的字符串常量，在创建字符串时，jvm会首先在字符串常量池中寻找是否有该字符串，如果有返回它的引用，如果没有实例化字符串，将他放到常量池中并返回它的引用 String是基本的数据类型么string不是基本的数据类型，string作为一个类只能是属于引用类型 String的特性 不可变性 常量池优化 final修饰（不可以被继承，不可以被改变） String str=”i”与 String str=new String(“i”)一样吗？不一样，分配内存的方式不一样 String str=”i” 是分配到常量池中 String str=new String(“i”) 是分配到堆内存中 String s = new String(“xyz”);创建了几个字符串对象两个对象，一个是静态区的xyz,一个是用new创建在堆上的对象 如何将字符串反转使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 数组有没有 length()方法？String 有没有 length()方法数组中没有length方法，只有length属性，String有length方法 注意：javaScript是通过字符串长度的length属性得到的 String 类的常用方法都有那些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 在使用HashMap时，用String作key的好处HashMap内部通过key的hashcode来确定value的位置，因为字符串是不可变的，它的hashcode被缓存下来，不需要再次计算，所以相对于其他对象来说更快。 String，StringBuffer,StringBulider的区别可变性：String不可变，StringBuffer和StringBuilder是可变的 线程安全：String不可变所以说他是线程安全的，StringBuffer对方法加了同步锁，所以说是线程安全的，StringBuilder是非线程安全 性能：String&lt;StringBuffer&lt;StringBulider 总结 操作数据量小：String 多线程操作数据量大:StringBuffer 单线程操作大量数据:StringBulider Date相关包装类相关自动装箱与拆箱 拆箱：将包装类转换为基本数据类型 装箱：将基本的数据类型用他们的包装类封装起来 对于引用数据类型：==比较的是对象的内存地址 对于基本数据类型：==比较的是值 12345678910111213141516 Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true//如果整型的字面量的值在-127-128之间，那么自动装箱就不会new产生新的对象，而直接引用常量池中的integer对象，如果超过范围则为false Integer a1 = 128; Integer b1 = 128; System.out.println(a1 == b1); // 128超过&#123;-128-127&#125;false Integer a2 = 127; Integer b2 = 127; System.out.println(a2 == b2); // true","pubDate":"Wed, 07 Oct 2020 01:33:52 GMT","guid":"https://augus-liuzhi.github.io/2020/10/07/java基础知识/","category":""},{"title":"SpringMVC","link":"https://augus-liuzhi.github.io/2020/10/06/SpringMVC/","description":"SpringMVC概述1.1 SpringMVC概述 Spring 为展现层提供的基于MVC设计理念的优秀的web框架，是目前最主流的MVC框架。 Spring 3.0以后超越strusts2,称为最优秀的MVC框架。 SpringMVC通过一套MVC注解，让pojo成为处理请求的控制器，而无需实现任何接口。 支持REST风格的URL请求。Restful 采用了松散耦合可插拔组件，比MVC架构更有扩展性和灵活性 1.2 SpringMVC是什么轻量级，基于MVC的web层的应用框架，偏前端而不是业务逻辑层，Spring框架的后续产品 1.3 SpringMVC能干什么支持与Spring框架集成，如：（Ioc,aop） 支持REST风格 支持灵活的URL到页面控制器的映射 1.4 SpringMVC组件DispatcherServlet：前端控制器 Controller : 处理器/页面控制器 HandlerMapping : 请求映射处理器 View Resolver : 视图解析器 LocalResolver : 本地化，国际化 MultipartResolver : 本地上传解析器 HandlerExceptionResolver : 异常处理器 1.5 SpringMVC搭建 1 导入jar包 2 配置web.xml前端控制器 作用：加载springmvc配置文件，此时的配置文件有默认的位置和名称，默认位置在WEB—INF下，默认名称是-servlet.xml 例如：springMVC-servlet.xml 当加载了配置文件，SpringMVC就会根据扫描组件，找到控制层 12345678&lt;servlet&gt;&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3 创建一个pojo,在此类上加上@controller注解，SpringMVC就会将此类作为控制层加载，让其请求响应 4 在控制层中，需要在方法上设置@RequestMapping(value=”hello”),springmvc就是通过此注解将请求路径与控制层的方法进行匹配，此时请求路径为localhost:8080/projectName/xxx 5 处理请求的方法会返回一个字符串（视图名称），通过配置文件中的视图解析器进行页面跳转 方式：prefix+视图名称+suffix,此为页面跳转路径 RequestMapping注解2.1概念 requestmapping 请求映射处理器，主要功能就是把接收到的url请求，根据相应的映射，转发到另一个url 2.2 标注位置@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。 限定类 123456789@Controller@RequestMapping(\"/home\")public class TestController &#123; @RequestMapping(value=\"/test\") public String test() &#123; System.out.println(\"get\"); return \"success\"; &#125;&#125; 访问时必须访问localhost:8080/projectName/home/test 限定方法 12345678@Controllerpublic class TestController &#123; @RequestMapping(value=\"/test\") public String test() &#123; System.out.println(\"get\"); return \"success\"; &#125;&#125; 访问时必须访问localhost:8080/projectName/test 2.3 映射请求方式1234@RequestMapping(value=\"/test\",method=RequestMethod.PUT) 修改操作@RequestMapping(value=\"/test\",method=RequestMethod.GET) 查询操作 @RequestMapping(value=\"/test\",method=RequestMethod.POST) 添加操作@RequestMapping(value=\"/test\",method=RequestMethod.DELETE) 删除操作 2.4 映射请求参数12@RequestMapping(value=\"/test\", params= &#123;\"username\",\"age!=12\"&#125;)指定有两个参数，一个username，一个age并且age不能等于12 2.5 映射请求头1@RequestMapping(value=\"/test\", headers= &#123;\"Accept-Language=zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\"&#125;) 2.6 支持Ant路径123456@RequestMapping(value=\"/*/test\") 任意字符匹配访问路径：http://localhost:8080/SpringMVCdemo02/sdsd/test@RequestMapping(value=\"/abc?/test\") 任意单个字符匹配访问路径：http://localhost:8080/SpringMVCdemo02/abcd/test@RequestMapping(value=\"/**/test\") 任意多层路径匹配访问路径：http://localhost:8080/SpringMVCdemo02/abcd/sdsd/test 2.7 映射请求占位符12345678@Controllerpublic class TestController &#123; @RequestMapping(value=\"/test/&#123;id&#125;\") public String test(@PathVariable(\"id\")int id) &#123; System.out.println(id); return \"success\"; &#125;&#125; { }的形式进行占位符 使用@PathVariable(“参数名”)来接收参数 访问路径： 12&gt;http://localhost:8080/SpringMVCdemo02/test/10010&gt; REST3.1 概念表现层状态转化，是目前最流行的一种互联网软件架构 简单来说就是put,post,delete,get进行资源的创建，删除，查找，修改 3.2 使用方式首先在web.xml中配置过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 然后再写四种请求 123456789101112131415&lt;a href=\"testREST/1001\"&gt;rest&lt;/a&gt;&lt;form action=\"testREST\" method=\"post\"&gt;&lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt;&lt;form action=\"testREST\" method=\"post\"&gt;&lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"&gt;&lt;input type=\"submit\" value=\"put\"&gt;&lt;/form&gt;&lt;form action=\"testREST\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"&gt;&lt;input type=\"submit\" value=\"delete\"&gt;&lt;/form&gt; Controller响应四种请求 123456789101112131415161718192021222324@RequestMapping(value=\"/testREST/&#123;id&#125;\",method=RequestMethod.GET) public String getUserById(@PathVariable(\"id\")Integer id) &#123; System.out.println(\"GET,id=\"+id); return \"success\"; &#125; @RequestMapping(value=\"/testREST\",method=RequestMethod.POST) public String insert() &#123; System.out.println(\"post\"); return \"success\"; &#125; @RequestMapping(value=\"/testREST\",method=RequestMethod.PUT) public String update() &#123; System.out.println(\"put\"); return \"success\"; &#125; @RequestMapping(value=\"/testREST\",method=RequestMethod.DELETE) public String delete() &#123; System.out.println(\"delete\"); return \"success\"; &#125; 流程：首先必须得是post请求，然后设置一个_method此 _method的value为put或者delete,触发请求后，首先web.xml中过滤器首先进行过滤，当看到有 _method时，并且里面有put或者delete，会把post请求转换成相应的put或者post请求，如果不符合条件直接是post请求，如果满足直接就是相对应的方法请求 处理请求数据4.1 从客户端获取数据1234567@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(String username,String password,String age) &#123; System.out.println(\"username=\"+username); System.out.println(\"password=\"+password); System.out.println(\"age=\"+age); return \"success\"; &#125; 在处理请求方法的时候，只需要在方法中加入形参，并且和要传入的参数名保持一致就可以直接接收数据 4.2 参数名称和形参名称不一致1234567@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(@RequestParam(value=\"name\",required=false,defaultValue=\"111\")String username,String password,String age) &#123; System.out.println(\"username=\"+username); System.out.println(\"password=\"+password); System.out.println(\"age=\"+age); return \"success\"; &#125; 在处理名称不一致的时候，需要设置@RequestParam(value=”name”）String username进行参数的绑定，就是从前端收到name的值，注解将其绑定在username上，required=true时，此时传递的参数必须得有name这个属性，required=false当为false时，传递的参数的属性值中可以没有name的属性值，defaultVlaue指的是，当这个值null时，会根据defaultvalue的值作为默认值 4.3 处理请求头数据12345@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(@RequestHeader(\"Accept-language\")String AcceptLanguage) &#123; System.out.println(AcceptLanguage); return \"success\"; &#125; @RequestHeader(“Accept-language”)是用来获取请求头中的数据 4.4 获取cookies12345@RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(@CookieValue(\"JSESSIONID\")String JSESSIONID) &#123; System.out.println(JSESSIONID); return \"success\"; &#125; 通过注解@CookieValue(“JSESSIONIS”)来获取cookies 4.5 使用pojo作为参数12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(User user) &#123; System.out.println(user); return \"success\"; &#125;&#125; 使用pojo获取客户端数据，实体类的属性名和表单中的属性值一致，而且支持级联关系 4.6 使用原生servlet获取数据12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(HttpServletRequest request) &#123; System.out.println(request.getParameter(\"username\")); return \"success\"; &#125;&#125; 4.7 作用域中放值方式一 12345678910@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public ModelAndView test(User user) &#123; ModelAndView mav=new ModelAndView(); mav.addObject(\"username\", \"root\"); mav.setViewName(\"success\"); return mav; &#125;&#125; 方式二 12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(Map&lt;String,Object&gt; map) &#123; map.put(\"username\", \"admin\");//像作用域中放值 return \"success\"; &#125;&#125; 方式三 12345678@Controllerpublic class ParamController &#123; @RequestMapping(value=\"/param\",method=RequestMethod.POST) public String test(Model model) &#123; model.addAttribute(\"username\", \"zhangsan\"); return \"success\"; &#125;&#125; SpringMVC处理数据，保存数据，可以用以上三种方式，不管适应哪种方式，最终都会调用的Model和View封装成一个ModelAndView对象。 视图解析5.1 概述不论控制器返回一个String,ModelAndView,View最终都会返回一个modelandview对象，由视图解析器解析试图，进行页面跳转 5.2 视图类型view作用：处理模型数据，重定向/转发视图 internalResourceView:转发视图 JstlView:转发视图 RedirectView:重定向视图 文件上传6.1 加入jar包 commons-io-1.4.jar 6.2 配置springmvc-servlet.xml 123456789&lt;mvc:annotation-driven/&gt; &lt;!-- 文件上传 ,将客户端上传的文件处理为multipartfile文件 ，此bean的id必须是multipartResolver--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置文件解析器编码，注意：一定要和页面编码保持一致 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt; &lt;!-- 设置最大上传的文件大小 --&gt; &lt;property name=\"maxUploadSize\" value=\"1111111111\"&gt;&lt;/property&gt; &lt;/bean&gt; 6.3 前端页面 123456&lt;form action=\"hello\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件: &lt;input type=\"file\" name=\"uploadfile\"&gt; 上传描述:&lt;input type=\"text\" name=\"description\" &gt; &lt;input type=\"submit\"&gt; &lt;/form&gt;注意：enctype=\"multipart/form-data 6.4 控制层 1234567891011121314@Controllerpublic class TestController &#123; @RequestMapping(value=\"hello\") public String hello(String description,MultipartFile uploadfile,HttpServletRequest request) throws IOException &#123; //获得上传的文件的文件名 String filename=uploadfile.getOriginalFilename(); //获得文件上传的路径 String path=request.getSession().getServletContext().getRealPath(\"/photo\")+File.separator+filename; File file=new File(path); uploadfile.transferTo(file); return \"success\"; &#125;&#125; 拦截器1. 概念SpringMVC的拦截器类似于Servlet的filter过滤器，主要作用是拦截用户的请求做出相应处理。 2. 拦截器类的实现 继承HandlerInterceptorAdapter类 实现HandlerInterceptor接口 12345678910111213141516171819202122232425import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class InterceptorHanddler implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; return false; &#125;&#125; 拦截器类中有3个方法 boolean preHandle() 控制方法执行前，它就开始执行，当返回值为true时，表示放行，当返回值为flase时，表示拦截（即中断后面所有操作） void postHandle() 控制方法调用之后执行，视图解析之前执行，就是return 返回ModelAndView后执行，主要作用就是对模型或者视图进行进一步的修改 void afterCompletion() 该方法在视图解析后执行，类似于finall语句块执行语句，主要进行资源的释放。 3. 单个拦截器的配置12345&lt;!-- 设置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 指定拦截器类就可以了--&gt; &lt;bean class=\"com.baidu.Handdler.InterceptorHanddler\"&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; 4. 单个拦截器执行流程用户–&gt;Controller方法执行前，进行preHandle()，返回值为true–&gt;Controller方法–&gt;Controller执行完毕，进行postHandle()执行–&gt;DispatcherServlet向客户端响应–&gt;afterCompletion() 5. 多个拦截器的配置12345678910111213&lt;!-- 设置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;!-- 设置不包含哪个路径 --&gt; &lt;mvc:exclude-mapping path=\"\" /&gt; &lt;bean class=\"com.baidu.Handdler.FirstInterceptorHanddler\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.baidu.Handdler.SecondInterceptorHanddler\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 6. 多个拦截器的执行流程1234567First: preHandleSecond: preHandleinterceptor已经启用Second: postHandleFirst: postHandleSecond: afterCompletionFirst: afterCompletion 多个拦截器配置时，会按照拦截器的配置顺序进行执行，首先会进行第一个拦截器的preHandle(),当返回值为true时，进行第二个拦截器的preHandle()当返回值为true时，进行第二个拦截器的postHandle，然后进行第一个拦截器的postHandle(),然后进行第二个拦截器的afterCompletion(),最后进行第一个拦截器的afterCompletion 7. 拦截器路径问题/ 的意思是所有文件夹及里面的子文件夹** /*是所有文件夹，不含子文件夹 /是web项目的根目录 /test 拦截以test结尾的路径 /*/.html 拦截以.html结尾的 异常处理1234567891011&lt;!-- 设置异常 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;&lt;!-- 异常默认页面 --&gt;&lt;property name=\"defaultErrorView\" value=\"error\"&gt;&lt;/property&gt;&lt;!-- 异常指定页面 --&gt;&lt;property name=\"exceptionMappings\"&gt;&lt;props&gt;&lt;prop key=\"java.lang.NullPointerException\"&gt;nullpoint&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; SpringMVC执行流程用户发送请求到前端控制器，前端控制器请求映射处理器，映射处理器调用相应的Handle处理器，返回给前端控制器一个执行链（包含处理器对象和拦截器），前端控制器会调用适配器处理器，适配器处理器调用相应的处理器返回给前端控制器一个ModelAndView对象，前端控制器调用视图解析器，返回一个具体的View，前端控制器再渲染这个view响应给客户。","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/SpringMVC/","category":""},{"title":"SpringBoot","link":"https://augus-liuzhi.github.io/2020/10/06/SpringBoot/","description":"一 Spring Boot入门1 springboot简介springboot是为了简化spring开发的一个框架 2 微服务一个应用应该是一组小型服务，可以通过http方式进行沟通 每一个功能元素最终都是可独立替换和独立升级的软件单元 3 SpringBoot环境搭建 导入坐标 123456789101112&lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建springboot启动引导类 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot都有一个启动引导类，在启动引导类添加注解@SpringBootApplication */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125; 创建控制器类 12345678910/** *@RestController等价于@Controller+@ResponseBody */@RestControllerpublic class HelloController &#123; @GetMapping(\"hello\") public String hello()&#123; return \"hello,SpringBoot\"; &#125;&#125; 测试 浏览器：localhost:8080/hello 简化部署 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该插件可以打包应用，直接使用java -jar jar包名就可以执行这个jar包了 4 Hello World探究 父依赖 12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/parent&gt;它的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt;它是真正的管理SpringBoot应用里面的所有依赖的版本 SpringBoot版本仲裁中心： ​ 以后我们导入的依赖默认不需要写版本（没有在的dependencies里面管理的依赖，需要写版本号） 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; Spring-boot-starter：SpringBoot场景启动器 Spring-boot-starter-web：帮我们导入web模块 主程序 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot都有一个启动引导类，在启动引导类添加注解 */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125; @SpringBootApplication :该注解表明该类是SpringBoot主配置类 通过运行该类的main()来启动SpringBoot应用 5 Quickstart Guide 使用initializr创建SpringBootProject,会自动创建一个springboot项目，只需要关注逻辑 Resources文件夹目录结构 static：保存所有静态资源（js css image） templates：保存所有的模板页面（SpringBoot默认jar包嵌入tomcat,默认不支持jsp页面），可以使用模板引擎（freemaker,thymeleaf） application.properties：SpringBoot应用的配置文件，可以修改一些配置 二 配置文件配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的 application.properties application.yml/application.yaml ==配置文件作用==：修改SpringBoot自动配置的默认值 YAML(YAML Ain’t a Markup Language)以数据为中心 YAML 不是一种标记语言 YAML 仍是一种标记语言 YAML配置实例 12server: port: 8000 XML: 123&lt;server&gt; &lt;port&gt;8000&lt;/port&gt;&lt;/server&gt; YAML语法 基本语法 12port: 8080path: /hello ==冒号后面有空格== 值的写法 字面量： ​ Key: Value ​ 字符串默认不用加上单引号或双引号 ​ 双引号：不会转义里面的特殊字符 ​ name: “zhangsan \\n lisi” 输出: zhangsan ​ lisi ​ 单引号：会转义特殊字符 ​ name: ‘zhangsan \\n lisi’ 输出:zhangsan \\n lisi 对象(Map)： ​ Key: Value 1234&gt;friends:&gt; lastname: zhangsan&gt; age: 20&gt; 行内写法 12&gt;friends: &#123;lastname: zhangsan,age: 20&#125;&gt; 数组（List,Set） 用-（空格）值来表示一个元素 12345678&gt;pets:&gt;&gt; - cat&gt;&gt; - dog&gt;&gt; - pig&gt; 行内写法 12&gt;pets: [cat,dog,pig]&gt; 配置文件值注入 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建要被注入的类 1234567891011@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; String name; Integer age; Boolean boss; Map&lt;String,Object&gt; map; List&lt;Object&gt; list; Dog dog;……………………&#125; @Component标注该类成为组件 @ConfigurationProperties(prefix = &quot;person&quot;)标注引入前缀为person的属性值 测试类 123456789@SpringBootTestclass DemoApplicationTests &#123; @Autowired Person person; @Test void contextLoads() &#123; System.out.println(person.toString()); &#125;&#125; @Value属性注入 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; 创建启动器引导类 创建java配置类 12345678910111213141516171819202122@Configuration//加载外部文件@PropertySource(\"classpath:db.properties\")public class jdbcConfig &#123; @Value(\"$&#123;db.driver&#125;\") String driver; @Value(\"$&#123;db.url&#125;\") String url; @Value(\"$&#123;db.username&#125;\") String username; @Value(\"$&#123;db.password&#125;\") String password; @Bean public DataSource dataSource()&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driver); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; &#125;&#125; 创建处理器类 12345678910@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping(\"hello\") public String hello()&#123; System.out.println(\"DataSource =\"+dataSource); return \"hello,SpringBoot\"+dataSource.toString(); &#125;&#125; @Value和@ConfigurationProperties区别 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个一个绑定 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂数据类型 支持 不支持 @PropertySource读取指定的配置文件1234567891011@Component@ConfigurationProperties(prefix = \"person\")@PropertySource(\"classpath:person.properties\")public class Person &#123; String name; Integer age; Boolean boss; Map&lt;String,Object&gt; map; List&lt;Object&gt; list; Dog dog;&#125; @PropertySource（value=路径）注解用来指定读取指定的配置文件，SpringBoot默认读取的配置文件是固定的（application.properties或者application.yml）通过该注解可以可以来读取其他的名称的配置文件，但是仍然需要和@ConfigurationProperties（prefix=”前缀”）注解来配合使用 @ImportResource导入spring配置文件 SpringBoot不识别spring的配置文件，当我们写spring的配置文件时候，需要在SpringBoot的主配置类上使用@ImportResource(location=”路径”)来导入我们所需要的spring配置文件，这样我们才可以在springboot中使用spring配置文件 @Bean给容器添加组件123456789101112** * @Configuration指明当前类为配置类 * 在配置文件中庸&lt;bean&gt;&lt;bean/&gt;添加组件 * 在配置类中用@Bean添加组件 */@Configurationpublic class MyConfig &#123; @Bean(\"configbean\") public SpringBean getSpringBean()&#123; return new SpringBean(); &#125;&#125; 配置文件占位符 随机数 12person.name=root$&#123;random.int&#125;person.list=1,2,3$&#123;random.uuid&#125; 占位符 12person.name=root$&#123;random.int&#125;person.map.k1=v1$&#123;person.name&#125; Profile多环境支持 多profile配置文件 配置文件名可以是application-(profile).properties/yml,需要在住配置文件中激活才可以使用 123&gt;#激活dev的配置，默认使用application.propreties配置文件内容，激活后使用激活的配置文件的配置&gt;spring.profiles.active=dev&gt; yml多文档块 yml支持多文档块，用—来区分文档块 123456789101112131415161718192021&gt;server:&gt; port: 8080&gt;&gt;#激活使用指定的配置pro的配置文件&gt;spring:&gt; profiles:&gt; active: pro&gt;&gt;---&gt;server:&gt; port: 8081&gt;&gt;spring:&gt; profiles: dev&gt;---&gt;server:&gt; port: 8083&gt;spring:&gt; profiles: pro&gt;&gt; 配置文件加载位置优先级优先级由高到低，高优先级会覆盖低优先级的配置，配置内容不同，SpringBoot会互补配置 conf文件，根目录，类路径conf文件，类路径根目录 自动配置原理 springboot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration 1234@EnableAutoConfiguration 利用selector给容器导入一些组件组件：将类路径下的META-INF/spring.factories里面的配置所有的EnableAutoConfiguration的值加入到了容器每一个xxxAutoConfiguration都是容器的一个组件，都加入到容器中，用他们来自动配置，每一个自动配置类进行相应的自动配置功能 精髓： SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有springboot默认写好配置类 再看自动配置类中到底配置哪些组件（只有有我们要用组件有，我们就不需要配置了） 给容器自动配置类添加组件的时候，会从properties类中获取属性，我们可以在配置文件中指定这些属性的值 细节： @Conditional 作用：指定条件成立，才给容器添加组件，配置类里面的内容才生效 扩展注解 1.class条件注解 @ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。 @ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。 2.Bean条件注解 @ConditionalOnBean：当容器中有指定Bean的条件下进行实例化。 @ConditionalOnMissingBean：当容器里没有指定Bean的条件下进行实例化。 3.属性条件注解 @ConditionalOnProperty：当指定的属性有指定的值时进行实例化。 4.Resource条件注解 @ConditionalOnResource：当类路径下有指定的资源时触发实例化。 5.web条件注解 @ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。 @ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。 6.表达式条件注解 @ConditionalOnExpression：基于SpEL表达式的条件判断，当表达式为true的时候，才会实例化一个Bean。 @ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。 @ConditionalOnJndi：在JNDI存在的条件下触发实例化。 @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。 自动配置报告 1debug=true 在主配置文件中开启springboot的debug,使用该代码启用，生效后运行springboot应用会在控制台打印自动配置报告 三 日志日志框架==SpringBoot选用：SLF4j+logback== SlF4j使用SpringBoot属性注入类上使用@ConfigurationProperties 实现SpringBoot配置文件读取和应用 步骤： 创建配置项类jdbcProperties,在该类上使用注解@ConfigurationProperties 123456789101112131415161718192021222324252627282930313233343536/** * ConfigurationProperties从application配置文件中读取配置项 * prefix表示前缀 * 配置类的变量名必须要与前缀之后的配置项名保持相同 */@ConfigurationProperties(prefix = \"db\")public class jdbcProperties &#123; String diverClassName; String url; String username; String password; public String getDiverClassName() &#123; return diverClassName; &#125; public void setDiverClassName(String diverClassName) &#123; this.diverClassName = diverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 将db.properties修改为application.properties 将jdbcProperties对象注入到jdbcConfig中 123456789101112@Configuration@EnableConfigurationProperties(jdbcProperties.class)public class jdbcConfig &#123; @Bean public DataSource dataSource(jdbcProperties db)&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(db.getDiver()); druidDataSource.setUrl(db.getUrl()); druidDataSource.setUsername(db.getUsername()); druidDataSource.setPassword(db.getPassword()); return druidDataSource;&#125; 方法上使用@ConfigurationProperties 12345678@Configurationpublic class jdbcConfig &#123; @Bean @ConfigurationProperties(prefix = \"db\") public DataSource dataSource()&#123; return new DruidDataSource(); &#125;&#125; 此方法采用自动注入，需要将后缀和配置类变量名保持一致 多个yml文件配置配置文件可以使用application.properties以外，还可以使用application.yml或者application.yaml yaml与properties配置文件除了展示形式不相同以外，其他功能和作用都是一样的，在项目中原路读取方式不需要改变 yml配置文件特征 树状层级结构展示配置项 配置项之间如果有关系的话需要分行空两格 配置项如果有值，需要在：之后空一格再写配置值 将application.properties修改为为application.yml 12345db: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/lyb?serverTimezone=UTC username: root password: 123456 2）多个yml配置文件，在SpringBoot中是被允许的，这些配置文件的名称必须为application-***.yml,并且这些配置文件必须在总的application.yml配置文件激活才可以使用 1234#激活配置文件，需要指定其他配置文件的名称spring: profiles: active: 另一个配置文件的-后面的名字 3）如果properties和yml配置文件同时存在springboot项目中，那么这两类配置文件都有效。在两个配置文件中存在同名的配置项会以properties为主 自动配置原理五 Docker","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/SpringBoot/","category":""},{"title":"Spring","link":"https://augus-liuzhi.github.io/2020/10/06/Spring/","description":"1 Spring概述1.1 Spring是什么？Spring框架是针对bean的生命周期进行管理的轻量级容器（lightweight container）以ioc（控制反转）和aop（面向切片编程）为内核。 1.2 Spring的优势方便解耦，简化开发 AOP编程 声明事务支持 方便程序的测试 方便集成各种优秀框架 降低JavaEE API的使用难度 java源代码经典学习示范 1.3 Spring体系结构Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。 2 spring的第一个核心功能控制反转（IoC）：把对象的创建，赋值，管理工作都交给的容器处理，也就是对象的创建由Ioc容器完成。 控制：创建对象，对象属性的赋值，对象之间的关系管理。 反转：把原来的开发人员创建对象的控制权，转交给Ioc容器来控制 正转：有开发人员通过new 构造方法创建对象，并由开发人员主动控制对象。 Ioc目的(作用)：减少对代码的改动，也能实现不同的功能，实现解耦合。 Ioc的技术实现 ​ DI是Ioc的技术实现 ​ DI：依赖注入，只需要提供对象的名称就可以了，至于对象的创建，查找，赋值都是由容器内部实现的 Spring Ioc实现 Spring使用DI实现了Ioc的功能，spring底层的创建对象，采用了反射机制。 3 一般属性注入Setter-based 依赖注入 实体类 1234567891011121314151617181920212223242526272829package com.baidu.Dao;public class Person &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \"]\"; &#125; &#125; 创建bean 1234&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt; id : bean的唯一标识，通过getBean（）获取对像的时候，通过bean的id来指定具体要获取哪个bean的对象 class ：指定你要创建哪个类bean 注意：该方法主要是通过实体类的setXXX方法实现的，因此实体类必须得有set方法，还要注意属性的命名规范，以免造成找不到该set方法 Constructor-based 依赖注入 实体类 123456789101112131415161718192021222324package com.baidu.Dao;public class Person &#123; private String username; private String password; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; public Person(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \"]\"; &#125; &#125; 创建bean 1234&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"123456\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 构造方法重载 3.1 相同个数参数 1234567891011121314151617181920212223242526272829303132package com.baidu.Dao;public class Person &#123; private String username; private String password; private int age; public Person() &#123; super(); &#125; public Person(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; public Person(String username, int age) &#123; super(); this.username = username; this.age = age; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \", age=\" + age + \"]\"; &#125; &#125; 1234567891011121314151617 &lt;bean id=\"person1\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"123456\" type=\"String\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"person2\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"22\" type=\"int\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;或者 &lt;bean id=\"person1\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"123456\" type=\"String\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"person2\" class=\"com.baidu.Dao.Person\"&gt; &lt;constructor-arg value=\"root\" index=\"0\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"2\" index=\"1\" type=\"int\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 通过type来指定该位置的参数类型 index主要来指定参数的顺序 3.2 不同参数个数 不同参数个数构造方法，会自动匹配 4 特殊属性注入4.1 对象注入4.1.1 内部bean方式 1234567891011&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt;&lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;&lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;&lt;property name=\"teacher\" &gt;&lt;bean class=\"com.baidu.Dao.Teacher\"&gt;&lt;property name=\"tusername\" value=\"laoshi\"&gt;&lt;/property&gt;&lt;property name=\"tid\" value=\"1000\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/property&gt;&lt;/bean&gt; 4.1.2 ref引用bean 1234567891011&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\"&gt;&lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;&lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;&lt;property name=\"teacher\" ref=\"teacher\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"teacher\" class=\"com.baidu.Dao.Teacher\"&gt;&lt;property name=\"tusername\" value=\"laoshi\"&gt;&lt;/property&gt;&lt;property name=\"tid\" value=\"1001\"&gt;&lt;/property&gt;&lt;/bean&gt; 1注意：内部bean只能通过先访问外部bean然后才能再次访问内部bean，外部bean可以单独使用 4.2 数组注入123456&lt;property name=\"hobby\"&gt;&lt;array&gt; &lt;value&gt;play&lt;/value&gt; &lt;value&gt;games&lt;/value&gt;&lt;/array&gt;&lt;/property&gt; 4.3 List注入1234567&lt;property name=\"list\"&gt;&lt;list&gt; &lt;value&gt;list1&lt;/value&gt; &lt;value&gt;list2&lt;/value&gt; &lt;value&gt;list3&lt;/value&gt;&lt;/list&gt;&lt;/property&gt; 4.4 Map注入1234567&lt;property name=\"map\"&gt;&lt;map&gt; &lt;entry key=\"key1\" value=\"result1\"&gt;&lt;/entry&gt; &lt;entry key=\"key2\" value=\"result2\"&gt;&lt;/entry&gt;&lt;/map&gt;&lt;/property&gt;&lt;/bean&gt; 4.5 Set注入123456&lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 4.6 Properties注入123456&lt;property name=\"properties\"&gt;&lt;props&gt; &lt;prop key=\"pkey1\"&gt;p1&lt;/prop&gt; &lt;prop key=\"pkey2\"&gt;p2&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt; 4.7 实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.baidu.Dao;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Person &#123; private String username; private String password; private int age; private Teacher teacher; private String[] hobby; private List&lt;String&gt; list; private Map&lt;String,String&gt; map; private Set&lt;String&gt; set; private Properties properties; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public Map&lt;String, String&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public Set&lt;String&gt; getSet() &#123; return set; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public String[] getHobby() &#123; return hobby; &#125; public void setHobby(String[] hobby) &#123; this.hobby = hobby; &#125; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; public Person(String username, String password, int age, Teacher teacher) &#123; super(); this.username = username; this.password = password; this.age = age; this.teacher = teacher; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125; @Override public String toString() &#123; return \"Person [username=\" + username + \", password=\" + password + \", age=\" + age + \", teacher=\" + teacher + \", hobby=\" + Arrays.toString(hobby) + \", list=\" + list + \", map=\" + map + \", set=\" + set + \", properties=\" + properties + \"]\"; &#125;&#125; 5 FactoryBean注入5.1 applicationContext.xml1&lt;bean id=\"factory\" class=\"com.baidu.Dao.Myfactory\"&gt;&lt;/bean&gt; 5.2 实体类1234567891011121314151617181920212223package com.baidu.Dao;public class Car &#123; private String bround; private double price; public String getBround() &#123; return bround; &#125; public void setBround(String bround) &#123; this.bround = bround; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return \"Car [bround=\" + bround + \", price=\" + price + \"]\"; &#125; &#125; 5.3 Factory类123456789101112131415161718192021222324252627package com.baidu.Dao;import org.springframework.beans.factory.FactoryBean;public class Myfactory implements FactoryBean&lt;Car&gt; &#123; @Override public Car getObject() throws Exception &#123; Car car=new Car(); car.setBround(\"OOOO\"); car.setPrice(50.0); return car; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // TODO Auto-generated method stub return Car.class; &#125; @Override public boolean isSingleton() &#123; // TODO Auto-generated method stub return false; &#125;&#125; 5.4 测试类1234567891011public class Test &#123; public static void main(String[] args) &#123; //1 初始化容器 ApplicationContext applicationContext=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 通过getBean获取对象 Object object = applicationContext.getBean(\"factory\"); System.out.println(object); &#125;&#125; 5.5 测试结果1Car [bround=OOOO, price=50.0] 6 Bean的作用域6.1 singleton（单例模式）1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"singleton\"&gt; scope来指定作用域 singleton作为单例模式 单例模式下，只会创建一次对象，且在容器初始化的时候就已经执行了 6.2 prototype（原型模式）1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"prototype\"&gt; prototype作为原型模式 原型模式下，每次创建对象都是不同的 6.3 request在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。 1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"request\"/&gt; 针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。 6.4 session在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。 1&lt;bean id=\"person\" class=\"com.baidu.Dao.Person\" scope=\"session\"/&gt; 同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。 7 Bean的生命周期7.1 bean的生命周期 实例化Bean对象 依赖注入 初始化 使用 容器关闭时，销毁 1234&lt;bean id=\"life\" class=\"com.baidu.Dao.life\" init-method=\"init\" destroy-method=\"destroy\"&gt;&lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;&lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;&lt;/bean&gt; init-method 用来指定初始化方法 destroy-method用来指定销毁方法 注意：只有当容器关闭是，才会调用销毁方法 7.2 bean的后置处理器后置处理器加在初始化前后进行操作 12345678910public class AfterHanddler implements BeanPostProcessor&#123; public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; //初始化之后的操作 return null; &#125; public Object postProcessBeforeInitialization(Object arg0, String arg1) throws BeansException &#123; //初始化之前的操作 return null; &#125;&#125; 12&lt;bean class=\"com.baidu.Dao.AfterHanddler\"&gt;&lt;/bean&gt;在xml文件中能够直接引用就行了 8 自动装配手动装配：以valu或者ref的方式明确指定属性值都是手动装配手段 自动装配：根据指定的装配规则，不需要明确指定，spring自动匹配的属性值注入bean中 123456789101112131415手动装配： &lt;bean id=\"emp\" class=\"com.baidu.Dao.Emp\"&gt; &lt;property name=\"name\" value=\"zhangsan\"&gt;&lt;/property&gt; &lt;property name=\"id\" value=\"1001\"&gt;&lt;/property&gt; &lt;property name=\"car\" ref=\"car\"&gt;&lt;/property&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"car\" class=\"com.baidu.Dao.Car\"&gt; &lt;property name=\"cid\" value=\"666\"&gt;&lt;/property&gt; &lt;property name=\"cname\" value=\"cccc\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept\" class=\"com.baidu.Dao.Dept\"&gt; &lt;property name=\"did\" value=\"11111\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"dpart\"&gt;&lt;/property&gt; &lt;/bean&gt; 123456789101112131415161718192021222324252627自动装配： &lt;bean id=\"emp\" class=\"com.baidu.Dao.Emp\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"zhangsan\"&gt;&lt;/property&gt; &lt;property name=\"id\" value=\"1001\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"car\" class=\"com.baidu.Dao.Car\"&gt; &lt;property name=\"cid\" value=\"666\"&gt;&lt;/property&gt; &lt;property name=\"cname\" value=\"cccc\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept\" class=\"com.baidu.Dao.Dept\"&gt; &lt;property name=\"did\" value=\"11111\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"dpart\"&gt;&lt;/property&gt; &lt;/bean&gt;保持bean id和属性名一致，采用byName就可以了 &lt;bean id=\"emp\" class=\"com.baidu.Dao.Emp\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"zhangsan\"&gt;&lt;/property&gt; &lt;property name=\"id\" value=\"1001\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"car1\" class=\"com.baidu.Dao.Car\"&gt; &lt;property name=\"cid\" value=\"666\"&gt;&lt;/property&gt; &lt;property name=\"cname\" value=\"cccc\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept1\" class=\"com.baidu.Dao.Dept\"&gt; &lt;property name=\"did\" value=\"11111\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"dpart\"&gt;&lt;/property&gt; &lt;/bean&gt;当属性名和id不一致时，采用byType就行了 autowire 根据某种策略自动装配 9 注解 注解 说明 @Configuration 指定该类为Spring配置类 @ComponentScan 启用组件扫描，同xml中配置context:component-scan @Controller 控制层Bean @Service 业务层Bean @ Repository Dao层Bean @Component 实例化Bean @Bean 返回一个对象 @Autowired 自动装配Bean @Qualifier(“id”) 根据Id装配 @Resource 相当于@Autowired+@Qualifier(“id”)根据id装配 @Import 导入其他配置类 @Conditional 放在类上，当满足条件时，这个类中配置的所有bean注册才能生效，放在方法上，当满足条件时，才向容器中注册当前bean @Profile 前环境，动态的激活和切换一系列组件的功能；指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件，加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中 123456789101112131415161718192021222324252627282930@Repository@Scope(\"prototype\")public class User &#123; @Value(\"root\") String username; @Value(\"123456\") String password; @Value(\"20\") Integer age; @Autowired Teacher teacher; @PostConstruct public void init()&#123; System.out.println(\"初始化方法执行\"); &#125; @PreDestroy public void dest()&#123; System.out.println(\"销毁方法执行\"); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", age=\" + age + \", teacher=\" + teacher + '&#125;'; &#125;&#125; 123456789101112131415@Componentpublic class Teacher &#123; @Value(\"张三\") String Username; @Value(\"老师\") String Job; @Override public String toString() &#123; return \"Teacher&#123;\" + \"Username=\" + Username + \", Job='\" + Job + '\\'' + '&#125;'; &#125;&#125; 1234567public class AnnoTest &#123; public static void main(String[] args) &#123; ApplicationContext ac=new AnnotationConfigApplicationContext(SpringConfig.class); Person person = (Person) ac.getBean(\"person\"); System.out.println(person); &#125;&#125; 10 AOP什么是AOP AOP为Aspect Oriented Progranmming的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 aop的作用及优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复的代码，提高开发效率，并且便于维护 aop底层实现 动态代理技术 aop的动态代理技术 JDK动态代理：基于接口的动态的代理技术 cglib动态代理：基于父类的动态代理技术 基于XML的AOP开发开发步骤： 导入坐标（spring-context,aspectjweaver） 12345678910&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建目标类以及目标接口 12345public class Target implements TargetInterface&#123; public void save()&#123; System.out.println(\"Save Running……\"); &#125;&#125; 123public interface TargetInterface &#123; public void save();&#125; 创建切面类 1234567891011121314151617181920212223public class MyAspect &#123; public void before()&#123; System.out.println(\"前置增强\"); &#125; public void afterReturning()&#123; System.out.println(\"后置增强\"); &#125; public void afterThrowing()&#123; System.out.println(\"抛出异常\"); &#125; public void around(ProceedingJoinPoint proceedingJoinPoint)&#123; System.out.println(\"环绕前增强\"); try &#123; proceedingJoinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.println(\"还绕后增加\"); &#125; public void after()&#123; System.out.println(\"最终增强\"); &#125;&#125; 切面类和目标类交给Spring容器 1234&lt;!--目标类--&gt; &lt;bean id=\"target\" class=\"com.ccut.aop.Target\"/&gt; &lt;!--切面类--&gt; &lt;bean id=\"myAspect\" class=\"com.ccut.aop.MyAspect\"/&gt; 配置织入 123456789101112131415161718&lt;!--配置织入--&gt; &lt;aop:config&gt; &lt;!--声明切面=切点+通知--&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!--切点表达式，指定被增强的方法--&gt; &lt;aop:pointcut id=\"mypointcut\" expression=\"execution(public void com.ccut.aop.Target.save())\"/&gt; &lt;!--前置增强--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"mypointcut\" /&gt; &lt;!--最终增强--&gt; &lt;aop:after method=\"after\" pointcut-ref=\"mypointcut\"/&gt; &lt;!--后置增强--&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"mypointcut\"/&gt; &lt;!--抛出异常--&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"mypointcut\"/&gt; &lt;!--环绕增强--&gt; &lt;aop:around method=\"around\" pointcut-ref=\"mypointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 配置织入需要先导入aop命名空间 基于注解的AOP开发 导入坐标 配置自动代理和扫描包 12&lt;context:component-scan base-package=\"com.ccut.aop\"/&gt;&lt;aop:aspectj-autoproxy/&gt; 创建切面类和目标类 123456@Component(\"target\")public class Target implements TargetInterface&#123; public void save()&#123; System.out.println(\"Save Running……\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@Component@Aspectpublic class MyAspect &#123; @Before(\"pointcut()\") public void before()&#123; System.out.println(\"前置增强\"); &#125; @AfterReturning(\"pointcut()\") public void afterReturning()&#123; System.out.println(\"后置增强\"); &#125; @AfterThrowing(\"pointcut()\") public void afterThrowing()&#123; System.out.println(\"抛出异常\"); &#125; @Around(\"pointcut()\") public void around(ProceedingJoinPoint proceedingJoinPoint)&#123; System.out.println(\"环绕前增强\"); try &#123; proceedingJoinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.println(\"还绕后增加\"); &#125; @After(\"pointcut()\") public void after()&#123; System.out.println(\"最终增强\"); &#125; /*定义切点*/ @Pointcut(\"execution(public void com.ccut.aop.Target.save())\") public void pointcut()&#123;&#125;&#125; 11 Spring jdbcTemplateJdbcTemplate开发步骤 导入spring-jdbc和Spring-tx 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--控制事务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建数据库表和实体 1创建数据库和实体类相对应 创建JdbcTemplate对象 1234567891011&lt;context:property-placeholder location=\"db.properties\"/&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"druid\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"druid\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"$&#123;db.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;db.password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;db.url&#125;\"/&gt; &lt;property name=\"driverClassName\" value=\"$&#123;db.driver&#125;\"/&gt; &lt;/bean&gt; 执行数据库操作 1234567891011121314151617181920212223242526272829303132333435@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcTemplateCRUDTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test public void testInsert()&#123; int row=jdbcTemplate.update(\"INSERT INTO testmybatis(NAME,age,address,cid) VALUE(?,?,?,?)\",\"liuzhi\",22,\"shandong\",\"1\"); System.out.println(row); &#125; @Test public void testUpdate()&#123; jdbcTemplate.update(\"UPDATE testmybatis SET age=? WHERE id=?\",20,17); &#125; @Test public void testDelete()&#123; jdbcTemplate.update(\"DELETE FROM testmybatis WHERE id=?\",16); &#125; @Test public void testQueryAll()&#123; List&lt;User&gt; list=jdbcTemplate.query(\"select * from testmybatis\",new BeanPropertyRowMapper&lt;User&gt;(User.class)); System.out.println(list); &#125; @Test public void testQueryOne()&#123; User user = jdbcTemplate.queryForObject(\"select * from testmybatis where id=?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), 1); System.out.println(user); &#125; @Test public void testQueryCount()&#123; int num = jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM testmybatis\",int.class); System.out.println(num); &#125;&#125; 12 Spring事务Spring支持的事务类型 编程式事务 声明式事务 Spring实现事务的方式和原理spring实现事务实质是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务，真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的 Spring事务隔离级别 默认 未提交读 提交读 可重复读 序列化 事务问题 脏读：读取另一个未提交的事务 不可重复读：同一个事务，多次读取同一个数据 幻读：同一个事务多次查询返回的结果集不一样","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/Spring/","category":""},{"title":"Mybatis","link":"https://augus-liuzhi.github.io/2020/10/06/mybatis/","description":"MybatisMybatis概念MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。 ORMORM：对象关系映射，它是一种思想，主要是指数据库中每行数据用对象表示 Mybatis是半自动ORM映射工具，与全自动的区别Hibernate属于全自动ORM映射工具，进行级联查询时，根据对象模型可以直接获取。 Mybatis属于半自动ORM映射工具，进行级联查询，要手动写sql来完成。 JDBC存在的问题问题：大量代码冗余 数据库连接 ​ 数据库链接创建，释放频繁造成资源浪费 ​ 解决：mybatis-config.xml文件配置数据库连接池，使用数连接池管理数据库连接。 Sql语句 ​ sql语句和java代码高耦合 解决：mybatis把sql语句配置在Mapper文件中与java代码分离 结果集 ​ 传统jdbc需要遍历，手动封装对象 ​ 解决：mybatis自动映射成对象 Mybatis优缺点优点： 简化代码，提高效率 sql放在配置文件，提高可维护性 自带连接池功能 自带缓存（提高查询效率） 缺点： 1. 当字段多时，查询多表时，sql语句编写量过大 2. sql语句依赖数据库，可移植性差 Hibernate和mybatis区别 Sql优化和移植性 Mybatis需要手动编写sql语句，移植性较差，可优化行好 hibernate封装了sql语句，移植性比较好，但是可优化性差 映射关系 mybatis半自动orm框架，配置对象和结果集关系映射 Hibernate全自动orm框架，配置对象和数据表的对应关系 环境搭建 导入jar(lib+mybatis-3.5.2.jar) 引入配置文件 mybatis-config.xml ​ driverClassNme ​ url ​ username ​ password ​ 连接池（pooled） 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 选取要使用哪个环境配置 ，选取enviroment id --&gt; &lt;environments default=\"development\"&gt; &lt;!-- 给环境配置一个名称，名称随意 --&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事物控制，类型是采用jdbc方式手动控制事物 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 开启连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 驱动名，url,用户名，密码 --&gt; &lt;property name=\"driver\" value=\"数据库驱动器名（com.mysql.cj.jdbc.Driver）\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/（数据库名）?serverTimezone=UTC\" /&gt; &lt;property name=\"username\" value=\"数据库用户名\" /&gt; &lt;property name=\"password\" value=\"数据库密码\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"实现类的xml文件的路径\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; xxxMapper.xml(相当于dao的实现类) 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.baidu.demo.PersonDao\"&gt;&lt;insert id=\"抽象类中insert方法\" parameterType=\"有参方法的参数类型\"&gt;insert into messages value(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;address&#125;,#&#123;hobby&#125;)&lt;/insert&gt;&lt;select id=\"抽象类中select方法\" parameterType=\"有参方法的参数类型\" resultType=\"返回值参数类型\" &gt;select * from messages where id=#&#123;id&#125;&lt;/select&gt;&lt;delete id=\"抽象类中delete方法\" parameterType=\"有参方法的参数类型\"&gt;delete from messages where id=#&#123;id&#125;&lt;/delete&gt;&lt;update id=\"抽象类中update方法\" parameterType=\"有参方法的参数类型\"&gt;写update的sql语句&lt;/update&gt;&lt;/mapper&gt; Mybatis常用API12345678910111213141516目的：使用Dao 获得Dao对象 使用Dao方法常用的类：SqlSession 1. 获得Dao对象 XXXDao dao=SqlSession.getMapper(接口.class) 2. 相当于Connection 对象，提交事务，事物回滚，关闭资源SqlSeesionFactory 1. 获得sqlSession SqlSession sqlsession=sqlSessionFactory.opensession() 2. 保存封装mybatis-config.xml SqlSeesionFactory sqlSessionFactory=new SqlSeesionFactoryBulider().build(is)SqlSeesionFactoryBulider():读取配置文件Resources:获得读取配置文件的输入流InputStream is=Resources. Mybatis编程步骤 获得mybatis-config.xml的输入流 读取mybatis-config.xml配置文件，构造SqlSessionFactory对象 通过构造SqlSessionFactory对象，调用opensession(),获得Sqlsession 通过SqlSession对象获得Dao接口对象 调用方法匹配 提交事务 释放资源 Mybatis编程示例抽象类 1234567public interface PersonDao &#123; public void insert(Person person); public Person select(int id); public void delete(int id); public void update(Person person); &#125; 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Person &#123; int id; String username; String password; int sex; String address; String hobby; public Person() &#123; super(); &#125; public Person(int id, String username, String password, int sex, String address, String hobby) &#123; super(); this.id = id; this.username = username; this.password = password; this.sex = sex; this.address = address; this.hobby = hobby; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125; public Person(String username, String password, int sex, String address, String hobby) &#123; super(); this.username = username; this.password = password; this.sex = sex; this.address = address; this.hobby = hobby; &#125; @Override public String toString() &#123; return \"Person [id=\" + id + \", username=\" + username + \", password=\" + password + \", sex=\" + sex + \", address=\" + address + \", hobby=\" + hobby + \"]\"; &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Testpublic void insert() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); Person person=new Person(\"zhong\", \"250\", 1, \"jinan\", \"play\"); personDao.insert(person); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125;@Testpublic void select() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); Person person=personDao.select(2); System.out.println(person.toString()); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125;@Testpublic void delete() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); personDao.delete(1); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125;@Testpublic void update() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); Person person=new Person(2, \"小二\", \"123456\", 1, \"jinan\", \"play\"); personDao.update(person); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125; Myabtis的执行器有哪些，以及他们的区别 simpleExcutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。就是单次使用statement对象. reuserExcutor : 执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。 bathExcutor : 执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 执行器的设置方式有两种A:在配置文件中通过setting设置B:在构建sqlsession对象时，通过opensession(执行器)指定执行器类型 Mybatis是否支持延迟加载？Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 1&lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; 作用：映射查询结果的列封装成实体的属性 要求：查询结果的列明必须和实体属性名一致 表名和实体属性名不一致 通过sql别名的关键字，把sql语句和属性名保持一致 查询多个只需要知道每一行数据的封装的类型，mybatis会自动把多个数据封装成一个list 1.书写Dao接口 2.书写Mapper文件 3.注册Mapper文件 参数绑定 单个参数 在mapper文件中直接指定parameterType就可以了 多个参数 方法一：注解方式 123public interface UserDao &#123; public User select(@Param(\"username\")String username,@Param(\"password\")String password);&#125; 123&lt;select id=\"select\" resultType=\"com.baidu.demo.User\" &gt;SELECT * FROM messages WHERE username=#&#123;username&#125; AND PASSWORD=#&#123;password&#125;&lt;/select&gt; 方法二：参数序号 123public interface UserDao &#123; public User select(String username,String password);&#125; 123&lt;select id=\"select\" resultType=\"com.baidu.demo1.User\" &gt;SELECT * FROM messages WHERE username=#&#123;param1&#125; AND PASSWORD=#&#123;param2&#125;&lt;/select&gt; 分页1public List&lt;Person&gt; queryPage(int start, int pagesize); 123&lt;select id=\"queryPage\" resultType=\"com.baidu.demo.Person\" &gt;select * from messages limit #&#123;para1&#125;,#&#123;para2&#125;&lt;/select&gt; 12345678910111213141516171819202122@Test public void page() throws IOException &#123; SqlSession sqlSession = null; InputStream is = null; try &#123; is=Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); sqlSession=sqlSessionFactory.openSession(); PersonDao personDao=sqlSession.getMapper(PersonDao.class); int start=3; int pagesize=2; List&lt;Person&gt; list=personDao.queryPage(pagesize*(start-1), pagesize); System.out.println(list); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally &#123; sqlSession.close(); is.close(); &#125; &#125; 分页插件PageHelperpom.xml中 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt; &lt;/dependency&gt; mybatis-config,xml中 12345&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt; &lt;property name=\"dialect\" value=\"mysql\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 测试类 123456789101112131415@Test public void selectall()&#123; SqlSession sqlSession= MybatisUtil.getSqlSession(); UserDao userDao=sqlSession.getMapper(UserDao.class); PageHelper.startPage(1,3); List&lt;User&gt; list=userDao.SelectAll(); for(User user:list)&#123; System.out.println(user); &#125; PageInfo pageInfo=new PageInfo(list); System.out.println(\"共\"+pageInfo.getTotal()+\"条数据\"); System.out.println(\"当前页\"+pageInfo.getPageNum()); System.out.println(\"上一页\"+pageInfo.getPrePage()); System.out.println(\"下一页\"+pageInfo.getNextPage()); &#125; MybatisUtil的封装mybatis的核心api SqlSession 相当于Connection commit() rollback() close() 轻量级对象，每次操作创建一个新的。 SqlSeesionFactory ​ 作用：封装Mybatis-config配置信息 ​ 重量级对象，整个web应用只创建一个，对象的创建比较消耗资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.baidu.util;import java.io.IOException;import java.io.InputStream;import javax.management.RuntimeErrorException;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.baidu.demo.PersonDao;public class MybatisUtil2 &#123; //定义重量级对象SqlSessionFactory，减轻消耗资源。 private static SqlSessionFactory sqlSessionFactory; //从线程中获取sqlSession对象 private static ThreadLocal&lt;SqlSession&gt; tdl=new ThreadLocal&lt;SqlSession&gt;(); //载入配置文件，构建SqlSessionFactory static &#123; InputStream is = null; try &#123; is = Resources.getResourceAsStream(\"mybatis-config.xml\"); sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); &#125; catch (IOException e) &#123; throw new RuntimeException(\"读取配置文件失败\",e); &#125;finally &#123; if(is!=null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //获得SqlSession对象 public static SqlSession getSqlSession() &#123; SqlSession sqlSession=null; sqlSession=tdl.get(); if(sqlSession==null) &#123; sqlSession=sqlSessionFactory.openSession(); tdl.set(sqlSession); &#125; return sqlSession; &#125; //获得XXXDAO实体对象 public static &lt;T&gt; T getMapper(Class&lt;T&gt; clssa)&#123; SqlSession sqlSession=getSqlSession(); T t=sqlSession.getMapper(clssa); return t; &#125; //提交事务 public static void commit() &#123; SqlSession sqlSession=getSqlSession(); sqlSession.commit(); &#125; //回滚事务 public static void rollback() &#123; SqlSession sqlSession=getSqlSession(); sqlSession.rollback(); &#125; //关闭资源 public static void close() &#123; SqlSession sqlSession=getSqlSession(); if(sqlSession!=null) &#123; sqlSession.close(); tdl.remove(); &#125; &#125; &#125; 日志log4j.properties 12345678910111213在pom.xml中配置&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; mybatis-config.xml 123&lt;settings &gt; &lt;setting name=\"logImpl\" value=\"LOG4J\" /&gt; &lt;/settings&gt; 实体类名简化 给实体类的权限定名取别名 1\"com.baidu.demo.Person\" ====&gt; 别名 \"Person\" Mapper文件中 12345parameterType=\"com.baidu.demo.Person\" ==&gt;parameterType=\"Person\"resultType=\"com.baidu.demo.Person\" ==&gt;resultType=\"Person\" 使用方法 在mybatis-config.xml中 123&lt;typeAliases&gt;&lt;typeAlias type=\"com.baidu.demo.Person\" alias=\"Person\"/&gt;&lt;/typeAliases&gt; 在mapper文件中 123&lt;select id=\"select\" parameterType=\"int\" resultType=\"com.baidu.demo.Person\" &gt; ======&gt;&gt;&gt;直接采用别名就可以了&lt;select id=\"select\" parameterType=\"int\" resultType=\"Person\" &gt; Mybatis底层绑定参数的底层原理 123456789101112131415161 默认mapper文件绑定参数 #&#123;参数&#125; 底层使用的是PreparedStatment对象 使用 sql ? 预编译的方式执行 优点： 预编译，防止sql注入，效率高 缺点： 只能绑定数据值，sql关键字 列 非数据无法绑定2 使用sql字符串拼接可以绑定任何参数 优点：可以绑定任何内容（关键词，列） 缺点：sql注入 缓存12一级缓存：它指的是Mybatis对象中的SqlSession对象的缓存，当我们执行查询后，查询结果会存入到SqlSession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询相同的数据，mybatis会先去SqlSession中去找，如果有拿来直接使用，当SqlSession对象执行commit()或者close()以及增删改操作，缓存会被默认清空，默认打开一级缓存二级缓存：它指的是Mybatis中SqlSessionFactory对象缓存，同一个SqlSessionFactory创建SqlSession对象共享SqlSessionFactory对象的缓存(二级缓存存储的是数据，不是对象) 使用： 1 mybatis框架支持二级缓存（mybatis-config.xml配置） 123&lt;settings&gt; &lt;setting name=\"cachedEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 2 让当前的映射文件支持二级缓存（Mapper文件中配置） 1&lt;cache/&gt; 3 让当前的操作支持二级缓存（在Select标签中配置） 1&lt;select id=\"SelectByPage\" resultType=\"com.ccut.mybtais.User\" useCache=\"true\"&gt; 注解1234567@Select(\"SELECT * FROM testmybatis\")public List&lt;User&gt; SelectAll();@Insert(\"INSERT INTO testmybatis(NAME,age,address,cid) VALUE(#&#123;name&#125;,#&#123;age&#125;,#&#123;address&#125;,#&#123;cid&#125;)\")@SelectKey(statement =\"SELECT LAST_INSERT_ID()\", keyProperty = \"id\",before = false, resultType = int.class)public int InsertUser(User user);@Select(\"SELECT * FROM testmybatis WHERE NAME LIKE '%$&#123;value&#125;%'\")List&lt;User&gt; SelectByName(String name); 多表操作一对一 1234567891011121314&lt;resultMap id=\"MyResultMap\" type=\"com.ccut.mybtais.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"age\" property=\"age\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;result column=\"cid\" property=\"cid\"&gt;&lt;/result&gt; &lt;association property=\"userClass\" javaType=\"com.ccut.mybtais.UserClass\"&gt; &lt;id column=\"cid\" property=\"cid\"&gt;&lt;/id&gt; &lt;result column=\"part\" property=\"part\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"SelectAll\" resultMap=\"MyResultMap\"&gt; SELECT * FROM testmybatis t ,class c WHERE t.`cid`=c.`cid` &lt;/select&gt; 一对多 1234&lt;collection property=\"userClass\" ofType=\"com.ccut.mybtais.UserClass\"&gt; &lt;id column=\"cid\" property=\"cid\"&gt;&lt;/id&gt; &lt;result column=\"part\" property=\"part\"&gt;&lt;/result&gt;&lt;/collection&gt;","pubDate":"Tue, 06 Oct 2020 14:05:43 GMT","guid":"https://augus-liuzhi.github.io/2020/10/06/mybatis/","category":""},{"title":"集合类","link":"https://augus-liuzhi.github.io/2019/11/26/集合类/","description":"集合简介1. 集合类概述集合类又称为容器 集合类和数组的区别： 集合类长度可变，存放对象的引用。 数组长度是固定的，存放数据的基本类型。 常用集合类： List集合（继承Collection类） Set集合（继承Collection类） Map集合 2. Collection接口Collection接口是层次结构中的根接口，构成Collection的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将对象添加到集合 remove(Object o) 将对象从集合中删除 isEmpty() 返回boolean值，判空操作 iterator() 遍历集合对象 size() 获取集合中元素的个数，返回值int ​ 遍历的使用 12345678910public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();//创建集合类对象 list.add(\"a\");//往集合中添加对象 list.add(\"b\"); list.add(\"c\"); Iterator&lt;String&gt; it=list.iterator();//创建迭代器 while(it.hasNext()) &#123;//判断是否有下一元素，返回值为布尔类型 System.out.println(it.next());//next()方法返回Object &#125; &#125; 3. List集合List集合包括List接口以及List接口所实现的类。 List集合中元素允许重复，各元素顺序就是对象的插入的顺序。 用户可以通过索引（元素在集合中的位置）来访问集合中的元素 3.1 List接口重要方法： get(int index): 获取指定索引位置的元素 set(int index,object):将集合中指定索引位置，修改为指定对象（修改操作） 1234567891011public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();//创建集合类对象 list.add(\"a\");//往集合中添加对象 list.add(\"b\"); list.add(\"c\"); System.out.println(list.get(0));//得到索引值为0的对象 System.out.println(list.get(1)); System.out.println(list.get(2)); list.set(0,\"c\");//把索引值0处对象修改成c,修改不是交换，对象a消失 System.out.println(list.get(0)); &#125; 3.2 List接口的实现类实现类一：ArrayList类 优点：实现可变数组，允许保存所有元素，包括Null，并可以根据索引位置对集合进行随机访问 缺点：向指定的索引位置插入对象或删除对象的速度缓慢。 实现类二：LinkedList类 优点：采用链表保存对象，便于向集合中插入和删除对象，插入删除效率高。 缺点：随机访问效率低 实例化用法： 123List&lt;E&gt; arraylist=new ArrayList&lt;&gt;();List&lt;E&gt; linkedList=new LinkedList&lt;&gt;();E为合法的Java数据类型 实例 123456789101112public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();//创建集合类对象 list.add(\"a\");//往集合中添加对象 list.add(\"b\"); list.add(\"c\"); int i=(int) (Math.random()*list.size()-1);//随机获取0-2 list.remove(2);//删除索引为2的元素。 Iterator&lt;String&gt; it=list.iterator(); while(it.hasNext()) &#123;//遍历输出 System.out.println(it.next()); &#125; &#125; 注意：与数组相同，集合的索引也是从0开始的。 4. Set集合set集合对象不按特定方式排序，只是简单的把对象加入集合，set集合不能包含重复的元素。 set集合由set接口和set接口实现类组成。 Set接口的实现类 实现类一：HashSet类实现Set接口，由哈希表支持，不保证迭代顺序，允许使用Null元素 实现类二：TreeSet类不仅实现Set接口，还实现了java.util.SortedSet接口。TreeSet类实现的Set集合在便利中按照自然顺序递增排序，也可以按照指定比较器递增排序。 TreeSet类增加方法 方法 功能描述 first() 返回第一个（最低）元素 last() 返回最后一个（最高）元素 comparator() 返回排序比较器，如果自然排序，返回NUll headSet(E toElement) 返回一个新集合，包含从头到toElement所有的元素 subSet(E fromElemnet,E toElement【不包含】) 返回一个新集合，包含从fromElement到toElement所有的元素 tailSet(E fromElement) 返回一个新集合，包含fromElement到之后的所有的对象 实例用法： 12345678910111213public static void main(String[] args) &#123; TreeSet &lt;String&gt; set=new TreeSet&lt;&gt;();//创建一个Set集合对象 set.add(\"a\");//添加对象 set.add(\"b\"); set.add(\"c\"); System.out.println(set.size());//输出个数 System.out.println(set.first());//输出集合第一个 System.out.println(set.last());//输出集合最后一个 System.out.println(set.comparator());//返回排序比较器 System.out.println(set.headSet(\"c\"));//从头到C，不包含C System.out.println(set.subSet(\"a\", \"c\"));C//从a到c,不包含c System.out.println(set.tailSet(\"b\"));//从b往后 &#125; HashSet类方法 方法 功能 HashSet() 构造一个默认的散列集合 HashSet(Collection c) 创建一个散列集合，并用类c中的元素初始化 HashSet(int capacity) 创建一个容量为capacity的散列集合 Hash(int capacity,float fillTadio) 创建一个容量为capacity的散列集合，填充比为fillTadio 用法： 12345678public static void main(String[] args) &#123; HashSet&lt;Object&gt; hs=new HashSet&lt;&gt;(); hs.add(\"A\"); hs.add(\"B\"); hs.add(\"C\"); hs.add(\"D\"); System.out.println(hs); &#125; 注意：散列集合的元素是无序的 5. Map集合Map集合中没有继承Collection接口，它提供的是Key到Value的映射。Map中不能包含相同的Key,每个Key只能映射一个Value. Map集合包含：Map接口以及Map接口所实现类。 5.1 Map接口Map接口的常用方法： 方法 功能 put(K key,V value) 向集合中添加Key和Value的映射关系 containsKey(object key) 包含指定Key的映射关系，返回true containsKey(object value) 映射一个或多个Key映射到指定值，返回true get(object key) 存在指定key对象，返回该对象的值，否则返回null keySet() 返回该集合中所有Key对象形成的Set集合 values() 返回该对象所有值对象形成的Collection集合 用法 1234567891011121314151617public static void main(String[] args) &#123; Map&lt;String,String&gt;map=new HashMap&lt;&gt;();//创建Map实例 map.put(\"0\", \"我\");//添加key和value映射关系 map.put(\"1\", \"是\"); map.put(\"2\", \"学\"); map.put(\"3\", \"生\"); Set&lt;String&gt; set=map.keySet();//构建map里面的所有key集合 Iterator &lt;String&gt; it=set.iterator();//创建迭代器 while(it.hasNext()) &#123;//判断是否还有下一个元素 System.out.println(it.next());//遍历集合 &#125; Collection&lt;String&gt; coll=map.values();//构建map里面的所有Value集合 it=coll.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125; 注意：map集合允许对象添加对象为Null值，而且没有个数限制。（这里的值对象value,不是key） 5.2 Map接口的实现类实现类一：HashMap类，允许使用null值null健，添加和删除映射关系效率更高，不保证映射的顺序。 实现类二：TreeMap类，映射关系具有一定的顺序，删除，添加，定位映射效率低，不允许null值。 用法： 123456789101112131415161718192021import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class day01 &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map=new HashMap&lt;&gt;(); map.put(\"面向对象程序设计\", \"100\"); map.put(\"软件工程导论\", \"80\"); map.put(\"高数\", \"60\"); Iterator&lt;String&gt;it=map.keySet().iterator(); while(it.hasNext()) &#123; String key=it.next(); String value=map.get(key); System.out.println(key+\" \"+value); &#125; &#125;&#125;结果：面向对象程序设计 100软件工程导论 80高数 60 集合面试题集合是什么？用来存储数据的容器 集合和数组的区别？数组的长度固定，集合的长度是可变的 数组存储的数据类型可以是基本数据，也可是引用数据类型 数组存储的数据元素是同一种类型，集合存储的数据元素可以是不同的数据类型 集合有哪些？list和set继承collection list的实现类：ArryList Vector LinkedList set的实现类：HashSet,LinkedHashSet(继承hashset) TreeSet Map的实现类：HashMap TreeMap HashTable LinkedHashMap ConcurrentHashMap 三者的区别？List 元素有序，可重复，可以插入多个null元素 Set 元素无序，不可重复，可以插入一个null元素 Map 键值对的形式存在 ArryList Vector LinkedList三者区别？arraylist底层是数组，查找效率快，增删慢，非线程安全，效率高 Vector 底层是数组，查找效率快，增删慢，线程安全，效率低(类中方法都是同步方法，通过同步方法来保证线程安全) LinkedList底层是双向链表，查找慢，增删块，非线程安全，效率高 List遍历方式for循环 foreach 迭代器 ArrayList扩容机制核心：grow()方法 首先创建Arraylist的时候初始的容量为0，当我们为arraylist添加第一个元素后，会扩容到10，当我们添加的元素大于10的时候，比如添加第11个元素，会进行1.5倍扩容neweCapacity=oldeCapacity+(oldeCapacity&gt;&gt;1) HashSet LinkedHashSet TreeSet的数据结构HashSet ：基于HashMap实现，底层用HashMap保存元素 LinkedHashSet ：linkedHashSet继承HashSet,内部通过LinkedHashMap实现的 TreeSet ：红黑树 HashMap LinkedHashMap HashTable TreeMap的数据结构HashMap : Jdk1.8之前HashMap由数组和链表组成，数组是HashMap的主体，链表主要是为了解决它的哈希冲突而存在，在jdk1.8以后，为了解决这种哈希冲突有了改变，当链表长度大于阈值（默认8）时，将链表转化成红黑树，减少搜索时间 LinkedHashMap : linkedhashmap继承了hashmap在此基础上加了一条双向循环的链表。 HashTable ： 数组和链表组成，数组是主体，链表主要解决哈希冲突 TreeMap : 红黑树 HashMap和HashTable的区别HashMap的key和Value可以为null,HashTable不可以为null HashMap不是线程安全，HashTable是线程安全（s’y’nchronized） HashMap的迭代器是Iterator,HashTable迭代器是enumerator HashTable是线程安全并且synchronized,单线程环境下HashMap的效率 集合的快速失败机制fail-fast 线程A通过迭代器遍历集合，同时线程B对集合的内容进行修改，在遍历的过程中，会使用一个modCount变量，集合在遍历的时候内容发生了改变，此时modCount的值就会发生改变，当迭代器进行下一次遍历的时候会检验modCount的值是否为expectmodCount值，是的话返回遍历，否则就会抛出CourrentModificationException，终止遍历。 解决方法： 对涉及的改变modCount的值的线程加上synchronized 使用CopyOnwriteArrayList来替换ArrayList 如何确保一个基本不能被修改12Collection collection = Collections.unmodifiableCollection(GetArr.arrayList);collection.add(10); 使用Collections.unmodifiabledCollection(Collection c)方法来创建一个只读集合，这样只要改变集合就会报出java.lang.UnsupportedOperationException的异常。 List接口迭代器IteratorIterator接口提供遍历任何Collection的接口，迭代器取代了java集合框架中Enumeration,迭代器允许调用者在迭代过程中移除元素。 Iterator的使用 12345Iterator iterator=GetArr.arrayList.iterator(); while (iterator.hasNext())&#123; System.out.print(\"线程1:\"); System.out.println(iterator.next()); &#125; Iterator迭代器原理 通过集合的itreator()方法来获得迭代器对象 使用迭代器的hasNext()判断集合中是否存在下一个元素 如果存在，使用迭代器的next()方法获得当前的元素 Iterator迭代器的特点 单向遍历，安全 边遍历边移除 边遍历边移除元素，唯一正确的方法就是使用迭代器的remove()方法 1234567891011ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); arrayList.add(4); Iterator&lt;Integer&gt; iterator=arrayList.iterator(); while (iterator.hasNext())&#123; if(iterator.next()%2==0)&#123; iterator.remove(); &#125; &#125; 使用foreach会报CourrentModificationException异常，因为是用此种方法会自动生成一个iterator来遍历list,但是边遍历边修改会抛出异常。 Iterator和Listiterator的区别 Iterator可以遍历Set和List集合，Listiterator只可以遍历List ListIterator可以双向遍历（向前向后遍历），Iterator只可以单向遍历 ListIterator实现了Iterator接口，添加的额外的功能，比如：替换一个元素，获取前面的元素或后面的元素的索引位置 遍历一个List的有哪些不同方式，每种方法的实现原理 for循环，基于计数器 迭代器遍历Iterator，Itertor是面向对象的一种设计模式。 foreach循环遍历。foreach内部也是采用iterator的方式实现。 java中list遍历的最佳实践 java collections框架中提供了一个RandomAccess，用来标记list是否支持RandomAccess接口 如果支持该接口，按位置读取数据元素的平均时间复杂度为O(1),如arraylist，可用for循环遍历 如果不支持，如linkedlist建议使用Iterator和foreach遍历 ArrayList的优缺点 优点： arrayList底层以数组实现，是一种随机访问模式，实现了RandomAccess接口，查找非常快 顺序添加一个元素特别快 缺点： ​ 删除元素或者插入元素，需要做一次复制操作，如果复制的元素很多，效率慢 数组和List之间的转换 数组转List：Arrays.asList() List转数组：List.toArray() ArrayList和LinkedList的区别 数据结构：ArrayList底层是数组，LinkedList底层是双向链表。 效率：ArrayList随机访问效率高，LinkedList的删除插入效率高 内存空间：LinkedList的内存空间更大(有头尾指针) 线程安全：都不是线程安全 ArrayList和Vector的区别 线程安全：Vector实现了线程安全 性能：Vector有同步方法，性能不如ArrayList的性能好 扩容：Vector是两倍扩容，ArrayList是1.5倍扩容 插入数据谁的速度快 Vector&lt;ArrayList&lt;LinkedList 多线程场景下如何使用ArrayList ArrayList不是线程安全，如果遇到多线程可以使用Collections的synchronizedList方法将其转换成线程安全的容器后，再使用。 1List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(arrayList); List和Set的区别 相同点：List和set都是继承Collection接口 不同点： List有序，元素可以重复，允许插入多个null，set无序，元素不可以重复，只允许插入一个null Set遍历只能使用迭代器遍历 List查找快，Set插入删除块 Set接口HashSet实现原理 HashSet是基于HashMap实现的，HashSet的值存放于HashMap的key上，HashMap的的Value统一为PRESENT,hashSet实现比较简单，相关HashSet得操作都是调用HashMap的方法进行完成的，HashSet不允许有重复的值。 HashSet如何检查数据不重复的 hash值和equals()方法 HashSet是如何保证数据不可重复 HashSet通过add（）方法添加元素时，会调用HashMap的put的方法，将HashSet的值存放到HashMap的key上，在hashMap中如果k/v相同时，会用新的v覆盖旧的V,由于V全部为PRESENT所以不会重复。 注意：HashMap的key是否相等，先比较的是hashcode再比较equals hashCode与equals（）的相关规定 如果两个对象相等，hashcode也相等 两个对象相等，equals返回true 两个对象有相同的hashcode,他们的值不一定相等 euqals方法被覆盖，hashcode方法也必须覆盖 hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashcode()方法，该类的两个对象无论如何都不会相等 ==与equals的区别 ==判断内存地址是否相等，equals判断值是否相等 HashSet和HashMap的区别 HashMap HashSet 实现了Map接口 实现了Set接口 存储键值对象 仅存储对象 put()添加元素 add()添加元素 HashMap通过key计算hashcode HashSet使用成员对象计算hashcode Map接口hashmap实现原理 hashmap的数据结构：数组+链表 hashmap是基于Hash算法实现的 当我们put元素时，会根据key的hashcode重新hash计算出当前对象的元素的数组下标 存储时如果hash值相同的key此时又两种情况1）如果key相同覆盖原始值2）如果key不同放入链表中 获取时，通过hash值来确定下标位置，进一步判断key是否相同，从而找到对应值 Jdk1.7和jdk1.8比较 jdk1.8改动 resize扩容优化 引入红黑树，避免单链表过长而影响效率 解决了多线程死循环的问题，但仍是非线程安全，多线程可能造成数据丢失 不同 jdk1.7 jdk1.8 存储结构 数组+链表 数组+链表+红黑树 初始化方式 inflateTable函数 直接集成到resize函数 hash值计算 9次扰动=4次位运算+5次异或运算 2次扰动=1次异或+1次位运算 存放数据原则 无冲突放数组，有冲突的话放链表 无冲突放数组，有冲突的话放链表，链表长度大于8，数组长度大于64存放到红黑树 插入数据方式 头插法 尾插法 扩容后存储位置计算 HashMap的具体流程 进行put的时候会首先计算key的hash值，这里调用了hash方法，hash方法实际是让key.hashcode()与key.hashcode()&gt;&gt;&gt;16进行异或操作，所以hash函数的作用是高16位不变，低16位与高16位进行异或操作。 数组下标的计算方式：index=(table.length-1)&amp;hash 什么是Hash hash一般翻译为散列，也叫哈希，就是把固定长度的输入，通过散列算法，变成固定长度的输出，该输出就是散列值，哈希值 什么是哈希冲突 当两个不同的输入值，根据同一个散列函数计算出具有相同散列值得现象，我们把它叫做碰撞，也叫哈希碰撞 解决Hashmap冲突 使用链地址法，来链接拥有相同hash值得数据 使用两次扰动函数（hash函数）来降低hash冲突，使数据分布更加平均 引入红黑树降低遍历时间复杂度，使遍历更快 能否用类作为HashMap的key 重写equals()方法，也要重写hashCode()方法 为什么HashMap中String,Integer这样的包装类更适合做key 都是final类型，都保证了不可变性，保证key的不可更改性 内部重写了equals（）和hashCode（）遵循hashmap规范 如果使用Object作为key,应该怎么办。 重写equal()方法和hashCOde()方法 重写hashcode（）因为要计算存储数据的存储位置 重写equals（）保证key在哈希表中的唯一性 HashMap和HashTable的区别 线程安全：HashMap是非线程安全，HashTable是线程安全，内部方法用来synchronized修饰 效率：HashMap比HashTable效率高 空键空值的支持：HashMap允许有一个空键，多个空值，HashTable不允许有空键 底层数据结构：HashMap数组+链表+红黑树 HashTable数组+链表 HashMap和TreeMap的选择 TreeMap可以对key进行有序集合遍历 ConcurrentHashMap ConcurrentHashMap不允许null值null键 jdk1.7Concurrenthashmap采用的是分段数组+链表，对整个桶数组进行分割分段（Segment），在每个分段上加上一个lock锁，相对于HashTable的sychronized锁更加精密，默认是16个segment，效率比hashtable提高16倍。 一个segment包含一个hashentry数组，每个hashentry是链表的结构的元素，每个segment守护一个hasnentry里的数组，当对hashentry数组的数据修改时，应该首先获得对应的segment锁 jdk1.8ConcurrentHashMap采用的是Node数组+链表+红黑树，通过sychronized和cas保证并发安全 Collection和Collections的区别collection是一个集合的接口 Collections是集合类的一个辅助工具类，包含了很多静态方法 Collections工具类sort方法的两种重载形式 实现 Comparable接口 传入第二个参数为Comparator接口的子类型。","pubDate":"Tue, 26 Nov 2019 05:27:56 GMT","guid":"https://augus-liuzhi.github.io/2019/11/26/集合类/","category":""},{"title":"字符串","link":"https://augus-liuzhi.github.io/2019/11/18/String/","description":"String类 声明字符串 java中有一对” “号包围的都是字符串 声明字符串语法：String s 注意：声明字符串必须经过初始化才能使用 创建字符串 方法一 String (char a[]) 1234char a[]=&#123;'a','b','c'&#125;;String s=new String(a);等价于String s=new String(\"abc\"); 方法二String(char a[],int offset,int length) 1234char a[]=&#123;'s','t','u','d','e','n','t'&#125;;String s=new String(a,2,4);等价于String s=new String(\"uden\") 方法三 1234String str1,str2;str1=\"we are student\";str2=\"we are student\";str1与str2引用相同的的字符串常量，具有相同的实体。 连接多个字符串 使用+运算符可以将多个字符串连接在一起 123456public static void main(String[] args) &#123; String str1=\"hello\"; String str2=\"world\"; String s=str1+\" \"+str2; System.out.println(s); &#125; 连接其他数据类型 字符串也可以和其他数据类连接，会自动将其他的数据类型转换成字符串 1234567public static void main(String[] args) &#123; String str1=\"10\"; int a=10; char b='a'; System.out.println(a+str1+b); &#125;结果：1010a 其他数据类型和字符串相连接的时候，会自动调用toString()方法，将其转换成字符串。 获取字符串长度 使用String类的length()方法获取声明字符串对象的长度 语法：str.length() 12String s=\"we are student\";int size=s.length(); 空格也算字符串的一位。 字符串查找 indexOf(String s)查找s在字符串第一次出现的位置 lastIndexOf(String s)查找s在字符串中最后一次出现的位置 查找成功，返回当前字符所在字符串的位置，查找失败，返回-1 1234567public static void main(String[] args) &#123; String s=\"we are student\"; System.out.println(s.indexOf(\"e\")); System.out.println(s.lastIndexOf(\"e\")); System.out.println(s.indexOf(\"l\")); System.out.println(s.indexOf('w')); &#125; 获取索引位置的字符 使用charAt()方法可以将指定索引处的字符返回 语法：s.charAt(int index) 12String s=\"we are student\";System.out.println(\"返回第5个位置\"+s.charAt(5)); 获取子字符串 方法一 ：substring(int beginIndex)从当前位置到结束 方法二 ：substring(int beginIndex,int endIndex)从当前开始，到指定结束 123String s=\"we are student\";System.out.println(s.substring(3));System.out.println(s.substring(2,6)); 去除空格 忽略前导空格和尾部空格 12345public static void main(String[] args) &#123; String s=\" String 123 \"; System.out.println(\"字符串长度为：\"+s.length()); System.out.println(\"去除空格后的长度为：\"+s.trim().length());&#125; 字符串替换 将指定字符或者字符串转换成新的字符或者字符串 语法：s.replace(old,new) s.replaceAll(regex,replacment) 123456public static void main(String[] args) &#123; String s=\"abcdefg\"; System.out.println(s.replace('a', 'A')); System.out.println(s.replaceAll(\"ab\", \"ccccccc\")); System.out.println(s.replaceAll(s, \"ccccccc\")); &#125; 判断字符串的开始与结尾 startWith()方法与endWith()方法分别用于判断字符串是否以指定内容开始或者结束，返回值为boolean类型 语法：s.startWith(String prefix) 语法：s.endWith(String suffix) 1234567public static void main(String[] args) &#123; String num=\"220123456789330\"; boolean a=num.startsWith(\"220\"); boolean b=num.endsWith(\"330\"); System.out.println(\"字符串是220开头么？\"+a); System.out.println(\"字符串是330结尾么？\"+b); &#125; 判断字符串是否相等 运算符==用于判断两个字符串的内存地址是否相同 如果两个字符串具有相同的字符和长度可以使用equals()进行比较 语法：s1.equals(s2) 语法：s1.equalsIgnoreCase()忽略大小写 123456789101112131415161718192021222324public static void main(String[] args) &#123; String a=\"123\";//将123字符串指向a String b=\"123\";//将123字符串指向b String c=new String(\"123\");//新开辟一个内存空间，存储123字符串 if(a==b) &#123; System.out.println(\"两个字符串内存地址一样\"); &#125; if(a==c) &#123; System.out.println(\"两个字符串内存地址一样\"); &#125; else &#123; System.out.println(\"两个内存地址不一样\"); &#125; if(a.equals(b)) &#123; System.out.println(\"两个字符串相同\"); &#125; else &#123; System.out.println(\"两个字符串不相同\"); &#125; &#125;输出结果： 两个字符串内存地址一样 两个内存地址不一样 两个字符串相同 按字典比较两个字符串 compareTo()方法按字典顺序比较两个字符串 s1&lt;s2返回小于0的值 s1=s2返回0 s1&gt;s2返回大于0的值 123456789101112public static void main(String[] args) &#123; String s1=\"abc\"; String s2=\"efg\"; String s3=\"abc\"; System.out.println(s1.compareTo(s3)); System.out.println(s1.compareTo(s2)); System.out.println(s2.compareTo(s3)); &#125;输出结果：0-44 字母大小写转换 toLowerCase():将所有字符转换成小写 toUpperCase() 将所有字符转换成大写 123456789public static void main(String[] args) &#123; String s1=\"abc\"; String s2=\"ABC\"; System.out.println(s1.toUpperCase()); System.out.println(s2.toLowerCase()); &#125;输出结果：ABCabc 字符串分割 split()方法可以使字符串按照指定的分割字符或字符串对内容进行分割，指定多个分隔符,|= split(String sign,int limit)指定分割次数 12345678910111213141516171819202122public static void main(String[] args) &#123; String s=\"123,456,789=789=123123123\"; String[] news1=s.split(\",|=\"); for(String i:news1) &#123; System.out.println(i); &#125; System.out.println(); String[] news2=s.split(\",|=\",3); for(String i:news2) &#123; System.out.println(i); &#125; &#125;结果：123456789789123123123123456789=789=123123123 日期和时间的字符串格式化 日期格式化 12345Date date=new Date(); String year=String.format(\"%tY\", date); String month=String.format(\"%tm\", date); String day=String.format(\"%td\", date); System.out.println(year+\"年\"+month+\"月\"+day+\"日\"); 时间格式化 12345Date date=new Date(); String hour=String.format(\"%tH\", date); String minute=String.format(\"%tM\", date); String sec=String.format(\"%tS\", date); System.out.println(hour+\"点\"+minute+\"分钟\"+sec+\"秒\"); 简单 12System.out.println(String.format(\"%tF\", new Date()));System.out.println(String.format(\"%tT\", new Date())); 正则表达式 元字符 意义 . 代表任意一个字符 \\d 0-9任意一个 \\D 非数字字符 \\s 空白字符 \\S 非空白字符 \\w 可用作标识符的字符不包括$ \\W 代表不可用于标识符的字符 通配符 ？ 0次或1次 * 0次或多次 + 一次或多次 {n} X=n {n,} n&lt;=X {n,m} n&lt;=X&lt;=m [abc] abc中的一个 [^abc] abc之外的任意字符 [a-zA-Z] 任何一个英文字母 [a-e[g-z]] 并运算 [a-z&amp;&amp;[def]] 交运算 字符串生成器 StringBuffer类提高频繁添加字符串的效率 12345678StringBuffer buffer=new StringBuffer(\"abcd\"); System.out.println(buffer); buffer.append(10); System.out.println(buffer); buffer.insert(6, \"hello\"); System.out.println(buffer); buffer.delete(6,11); System.out.println(buffer);","pubDate":"Mon, 18 Nov 2019 03:32:46 GMT","guid":"https://augus-liuzhi.github.io/2019/11/18/String/","category":""},{"title":"java面向对象基础","link":"https://augus-liuzhi.github.io/2019/10/28/面向对象/","description":"1 面向对象基础1.1 对象 概念：世间万物皆为对象，具有一定的属性和行为 1.2 类 概念：类是具有相同属性和行为的对象的抽象 1.3 属性 概念：描述对象的状态，在java中就是变量 1.4 行为 概念：描述对象的行为，在java中就是函数 1.5 面向对象编程的三大特点 1.5.1 封装 封装：将对象的属性和行为封装起来，对外的载体就是类【核心思想】 隐藏对象的属性和实现细节，仅对外提供公共访问方式 好处： 将转化提高 便于使用 提高重用性 提高安全性 封装原则 将不需要的对外提供的内容隐藏起来，把属性都隐藏，提供公共方法对其访问。 12345678910111213141516171819public class cardemo &#123; public static void main(String[] args) &#123; car c=new car(); c.setAge(0); System.out.println(c.getAge()); &#125;&#125;class car&#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age&gt;0&amp;&amp;age&lt;100) this.age = age; else System.out.println(\"age 错误！！！！\"); &#125;&#125; 1.5.2 继承 继承：子类有父类的属性和行为，子类也可以定义自己独有的属性和行为 1.5.3 多态 多态： 2 类2.1 成员变量和局部变量 成员变量定义在类中，整个类中都有访问。局部变量定义在函数、语句、局部代码块中，只有在所属区域有效 成员变量存在于堆内存的对象中，局部变量存在于栈内存的对象中 成员变量随着对象的创建而存在，随着对象的消失而消失。局部变量随着所属区域的执行而存在，随着所属区域结束而释放 成员变量都有默认初始值，局部变量必须初始化。 局部变量和成员变量同名，局部变量优先原则 注意：类类型的参数一定指向对象，否则为NULL 匿名对象 ​ 没有名字的对象new car(); 定义对象的简写格式 当对象对方法进行一次调用，可以使用匿名对象 new car().num=5; new car().color=”red”; new car().run(); 匿名对象可以作为实际参数传递 show(new car()); 构造函数 函数名和类名相同 没有返回值 作用: 给对象初始化 创建对象都必须通过构造函数初始化 一个类中如果没有定义过构造函数，那么该类中就会有一个默认无参的构造函数 如果类中指定了构造函数，那么类中默认的构造函数就没有了 构造函数和一般函数的区别 调用时间： 构造函数对象创建时调用，对对象初始化，一般函数，对象创建后，才可以调用 调用次数： 构造函数只调用一次且是自动调用，一般函数可以调用多次且手动调用 123456789101112131415161718192021222324252627282930public class cardemo &#123; public static void main(String[] args) &#123; person p = new person(); p.speak(); person p1 = new person(\"旺旺\"); p1.speak(); person p2 = new person(\"强强\",10); p2.speak(); &#125;&#125;class person &#123; private String name; private int age; person() &#123; name = \"baby\"; age = 1; System.out.println(\"person run\"); &#125; person(String n) &#123; name = n; &#125; person(String n, int a) &#123; name = n; age = a; &#125; void speak() &#123; System.out.println(name + \" \" + age); &#125;&#125; 多个构造函数出现，必须按照重载方式【参数类型，参数个数，参数顺序】对不同的对象进行初始化 2.2 成员方法 权限修饰符 返回值类型 方法名（参数1，参数2，……参数N）{ ​ //方法体（可以为空） ​ //返回值 } 构造方法 特点：1 无返回值 ​ 2 方法名和类名相同 权限修饰符 方法名（）{ //构造方法体 } 如果没有构造方法，系统会自动创建一个，如果有自己写的，系统将不会创建构造无参构造方法 2.3 权限修饰符 private protected public 本类 可见 可见 可见 同包其他类或者子类 不可见 可见 可见 其他包的类或者子类 不可见 不可见 可见 如果没有设置权限修饰符，默认为本包可见，类的权限决定变量和方法的权限 2.4 this关键字 调用成员的变量和成员的方法 当成员变量和局部变量同名时 用this区分 this表示当前对象的引用 this可以在构造函数中调用其它构造函数，但是必须放在当前调用构造函数的第一行，即this函数放置在第一行 2.5 静态变量、常量和方法 用static修饰的成员被所有对象共享 static优于对象存在，因为static的成员随着类的加载就已经存在了 用关键字static修饰的变量，常量，方法称为静态变量，常量，方法 static修饰的成员多了一种调用方式，使用语法：类名.静态类成员 static修饰的数据是共享数据（静态/类变量，静态方法），对象中存储的数据是特有数据（叫成员/实例变量，成员方法） 静态放法中不可以使用this关键字 在静态方法中不可以直接调用非静态方法 局部变量不可以声明static 成员变量和静态变量的区别 1 两个变量的生命周期的时间不一样，成员变量随着对象的创建而存在，随着对象的释放被回收，静态变量随着类的加载而实现，随着类的消失而消失 2 调用方式不同 成员变量只能被对象调用，然而静态变量可以用类名和对象调用【尽量使用类名调用】 3 别名不同 成员变量也叫实例变量 静态变量也叫类变量 4 存储位置不同 成员变量的数据存储在堆内存的对象中，所以也叫对象的特有数据 静态变量存储在方法区的静态区【共享数据区】，所以也叫对象的共享数据 静态的注意事项： 静态方法只能访问静态成员。【访问局限性】 非静态即可以访问静态，又可以访问静态 静态方法中不可以使用this和super关键字 主函数是静态的 主函数： 格式是固定的 被JVM识别和调用 public：权限是最大的 static : 虚拟机调用主函数，不需要对象，直接用类名调用 void : 无返回值 main : 函数名，JVM识别的一个名字 String[] args: 参数列表，是一个数组类型的参数，元素都是字符串【==&gt;new String[0]】 3 对象3.1 对象的创建 语法： Test test=new Test(); Test test=new Test(a); 注意：每创建一个对象，就会调用一次构造方法 3.2 访问对象的属性和行为 类名.行为 类名.属性 4. super关键字 调用构造方法 调用隐藏变量 调用重写方法 注意：super调用的都是父类 super使用代码 1234567891011121314151617181920212223242526272829303132333435class A &#123; int num = 10; A() &#123; System.out.println(\"父类无参构造方法执行了\"); &#125; A(int x) &#123; System.out.println(\"父类有参构造方法执行了\"); &#125; void show() &#123; System.out.println(\"父类show方法\"); &#125;&#125;class B extends A &#123; B() &#123; super();// 调用父类无参构造方法 System.out.println(\"隐藏变量已经调用:\"+super.num);// 调用隐藏变量 System.out.println(\"B子类的构造方法执行了\"); &#125; void show() &#123; super.show();// 调用父类被重写的方法 System.out.println(\"子类show方法\"); &#125;&#125;class C extends A &#123; C() &#123; super(4);// 调用父类中的有参构造方法 System.out.println(\"C子类的构造方法执行了\"); &#125;&#125; 5. final关键字继承的弊端：打破封装性 final关键字可以修饰类、方法、变量 5.1 final修饰类123final class A &#123;&#125; final修饰的类不能被继承，即不能有子类 2.2 final修饰方法123final void show() &#123; &#125; final修饰的方法不允许被子类重写 2.3 final变量final修饰的变量为常量，常量一般同时使用时final和static修饰，只能被赋值一次（常量大写） 1static final int a=10; 3. 抽象类6.1 抽象定义 抽象：模糊，不具体，看不懂 12345678910111213141516171819abstract class Animal &#123;// 定义抽象动物类 abstract void eat();// 定义抽象方法 void sleep() &#123;//定义实例方法 System.out.println(\"can sleep\"); &#125;&#125;class Person extends Animal &#123; void eat() &#123; System.out.println(\"用筷子拿着吃\"); &#125;&#125;class Bird extends Animal &#123; void eat() &#123; System.out.println(\"用嘴叼着吃\"); &#125;&#125; 6.2 抽象特点方法只有声明没有实现时，该方法就是抽象方法，被abstract修饰，抽象方法必须定义在抽象类中。 抽象类不可以被实例化【调用抽象方法没有意义】 抽象类的子类，必须重写抽象类的所有抽象方法才可以实例化，否则，子类还是抽象类 6.3 抽象细节 抽象类有构造函数，给子类对象进行初始化 抽象类可以不定义抽象方法【一般这种类主要是不让创建对象】 抽象关键字不可以和哪些关键字共存【private不行，static不行，final不行】 抽象类和一般类的异同 ​ 相同：描述事物，都在内部定了成员 ​ 不同点： ​ 1 一般类中有足够的信息用来描述事物，抽象类描述不足 ​ 2 一般类中，不可以定义抽象方法，但是抽象类中可以定义，也可以定义非抽象 ​ 3 一般类类可以被实例化，抽象类不可以被实例化 抽象类一定是父类【子类覆盖其方法后才可以对子类实例化】","pubDate":"Mon, 28 Oct 2019 01:02:24 GMT","guid":"https://augus-liuzhi.github.io/2019/10/28/面向对象/","category":"--satic关键字 --this关键字"},{"title":"java接口","link":"https://augus-liuzhi.github.io/2019/10/17/接口/","description":"1. 接口定义 当一个抽象类的所有方法是抽象方法的时候，这时可以将该抽象类用另一种形式和定义来表示，那就是接口 interface【接口和抽象类似，必须全部覆盖接口类的所有抽象方法】 定义接口关键字：interface 123456interface demo &#123; abstract void show(); abstract void show1();&#125; 对于接口中常见的成员，这些成员都有固定修饰符 全局常量：public static final 抽象方法：public abstract void show(); 结论：接口的成员都是公共权限 2. 接口的实现 类与接口之间的关系是实现，类与类之间是继承关系 接口不能实例化，只能由实现类覆盖接口类的所有方法，实现类才可以实例化 1234567891011121314151617181920212223242526272829public class Implementtext &#123; public static void main(String[] args) &#123; demoimpl d = new demoimpl(); System.out.println(d.num); System.out.println(demo.num);//静态类名调用 System.out.println(demoimpl.num);//静态类名调用 d.show(); d.show1(); &#125;&#125;interface demo &#123; public static final int num = 10;//按照格式写 public abstract void show();//按照格式写 public abstract void show1();//按照格式写&#125;class demoimpl implements demo &#123; public void show() &#123; System.out.println(\"show\"); &#125; public void show1() &#123; System.out.println(\"show1\"); &#125;&#125; java不支持多继承，会出现不确定调用，进行多继承改良，采用多实现 多实现：一个类可以实现多个接口 123456789101112131415161718interface A &#123; public abstract int add(int a, int b);&#125;interface B &#123; public abstract void show();&#125;class Text implements A, B &#123; public void show() &#123; System.out.println(\"show方法执行\"); &#125; public int add(int a, int b) &#123; return a + b + 3; &#125;&#125; 一个类继承另一类的时候还可以实现多个接口 接口的出现避免单继承的局限性 123456789101112131415161718192021222324252627282930interface gg &#123;//接口gg public void show();&#125;interface mm &#123;//接口mm public void see();&#125;interface Person extends gg, mm &#123;// 接口和接口之间是继承关系，而且还是多继承 public void fun();&#125;class Q implements Person &#123;//类Q有3个方法 @Override public void show() &#123; &#125; @Override public void see() &#123; &#125; @Override public void fun() &#123; &#125;&#125; 接口和抽象类的区别 相同点：都是向上抽取来的 不同点： ​ 抽象类需要被继承，而且单继承，接口需要被实现，可以多实现 ​ 抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法，但是接口中只能 定义抽象方法必须有子类去实现 ​ 抽象类的继承是 is a 关系，定义体系内共性内容，接口的实现是like a关系，定义的体系额外功能 用一个例子来说明 1234567891011121314151617181920212223242526272829303132333435363738abstract class dog &#123;//定义犬类 String name;//有名字 int age;//有年龄 void eat() &#123;//能吃 System.out.println(\"can eat\"); &#125; abstract void sleep();//能睡，不同狗睡的地方不一样&#125;interface fun_seek &#123;//定义额外功能接口 public abstract void seekroad();//认路&#125;interface fun_look //定义额外功能接口 public abstract void lookfor();//查毒&#125;class eyedog extends dog implements fun_seek &#123;//定义导盲犬继承犬类的共性，并添加认路的功能 void sleep() &#123;//重写抽象类睡觉的方式 System.out.println(\"在主人家睡觉\"); &#125; public void seekroad() &#123;//重写添加的认路功能 System.out.println(\"俺认识路\"); &#125;&#125;class lookdog extends dog implements fun_look &#123;//定义缉毒犬继承犬类共性，并添加找毒的功能 void sleep() //重写抽象类睡觉的方式 System.out.println(\"在警察局睡觉\"); &#125; public void lookfor() &#123;//重写添加找毒的功能 System.out.println(\"俺可以查毒\"); &#125;&#125;","pubDate":"Thu, 17 Oct 2019 10:46:14 GMT","guid":"https://augus-liuzhi.github.io/2019/10/17/接口/","category":""},{"title":"Java面向对象——继承","link":"https://augus-liuzhi.github.io/2019/10/15/继承/","description":"1. 继承的概述 继承就是子类继承父类的变量和方法，下面用代码解释一下： 1234567891011121314151617class Student &#123;// 定义学生类 String name; int age; void study() &#123; System.out.println(name + \"studay good\" + age); &#125;&#125;class Work &#123;// 定义工人类 String name; int age; void work() &#123; System.out.println(name + \"work good\" + age); &#125;&#125; 从上述例子中可以看到，学生类和工人类都有共同的特征，为了实现代码复用性，进行抽取，java中抽取用类表示将共有的的行为或特征进行抽取，然后原来的来类也要可以用，我们就需要用原来类继承我们抽取的类，用extends关键字进行调用，如： 12345678910111213141516class Student extends Person &#123;// 定义学生类 void study() &#123; System.out.println(name + \"studay good\" + age); &#125;&#125;class Work extends Person &#123;// 定义工人类 void work() &#123; System.out.println(name + \"work good\" + age); &#125;&#125;class Person &#123;// 定义我们抽取的类 String name; int age;&#125; 通常称Person（被继承的类）类为父类（也叫操类，基类），称Work和Student（继承类）称为子类。 2. 继承的优点 提高代码复用性 让类与类产生关系，给多态提供了前提 java支持单继承，不支持多继承，对C++多继承进行改良 单继承：一个子类只能有一个直接父类 1234567891011class A &#123;&#125;class B &#123;&#125;class C extends A &#123;&#125; 或者 1234567891011class A &#123;&#125;class B &#123;&#125;class C extends B &#123;&#125; 多继承：一个子类能有多个直接父类(为什么不能多继承)【不直接支持，会产生调用的不确定性】 123456789101112131415class A &#123; void show() &#123; System.out.println(a); &#125;&#125;class B &#123; void show() &#123; System.out.println(b); &#125;&#125;class C extends A,B &#123;&#125; 当我们new c();调用show方法，调用的是A的还是B的？为了区分java对此进行了改良，不用多继承，用接口 java支持多层（多重继承）=&gt;传递性 1234567891011class A &#123; &#125;class B extends A &#123; &#125;class C extends B &#123;&#125; 3. 类的继承原则 单继承 继承具有传递性 继承不能循环 除Object类，所有类都有父类 4. 继承的使用当要使用一个继承体系时，如何使用 ? 查看该体系中顶层类，了解该体系的基本功能。 创建该体系中最子类的对象，完成功能的使用。 什么时候写继承？ 当类存在所属关系，就定义继承，A属于B,则A继承B 5. 继承中的成员变量当本类局部和成员变量名相同时用this区分 当子父类中成员变量相同时用super区分 this和super的用法很相似 this：代表一个本类对象的引用 super：代表一个父类空间 1234567891011class A &#123; int num = 5;&#125;class B extends A &#123; int num = 10; void show() &#123; System.out.println(this.num + \"……\" + super.num);//调用子类和父类的成员变量 &#125;&#125; 注意：子类不能直接访问父类的私有成员 6. 继承中的成员方法1234567891011121314151617181920212223class A &#123; int num = 5; void show1() &#123; System.out.println(num); &#125;&#125;class B extends A &#123; int num = 10; void show2() &#123; System.out.println(num); &#125;&#125;public class Extendstext &#123; public static void main(String[] args) &#123; B b = new B(); b.show1(); b.show2(); &#125;&#125; 当子父类中函数一样，将会运行子类的函数，称为覆盖操作 12345678910111213141516171819202122class A &#123; int num = 5; void show() &#123; System.out.println(num); &#125;&#125;class B extends A &#123; int num = 10; void show() &#123; System.out.println(num); &#125;&#125;public class Extendstext &#123; public static void main(String[] args) &#123; B b = new B(); b.show(); &#125;&#125; 6.1 函数的两个特性 重载：同一个类 覆盖：子类中，覆盖也叫重写 6.2 注意事项 子类的方法覆盖父类方法时，子类的权限必须大于父类的权限 静态只能覆盖静态，或被静态覆盖 6.3 什么时候使用覆盖操作当对一个类进行子类扩展时，子类需要保留父类的功能声明，但要定义子类中功能的特有内容时，就用覆盖操作完成。(修改方法，添加功能)如： 12345678910111213141516171819202122232425class Phone &#123;// 定义一个手机类 void call() &#123;// 通话功能 &#125; void show() &#123;// 展示功能 System.out.println(\"number\"); &#125;&#125;class newphone extends Phone &#123; void show() &#123;// 展示功能重写 System.out.println(\"name\"); System.out.println(\"jpg\"); System.out.println(\"number\"); &#125;&#125;或者class newphone extends Phone &#123; void show() &#123;// 展示功能重写 System.out.println(\"name\"); System.out.println(\"jpg\"); super.show();//调用父类show方法 &#125;&#125; 7. 继承中的构造函数在子类构造对象时，访问子类构造函数时，父类也运行，在子类的构造函数中，有一个默认的隐士语句，super();调用父类中空参数的构造函数，无覆盖，无继承 无参数 123456789101112class fu &#123; fu() &#123; System.out.println(\"fu run\"); &#125;&#125;class zi extends fu &#123; zi() &#123; super();//隐士自带的调用父类空参数构造函数 System.out.println(\"zi run\"); &#125;&#125; 有参数 123456789101112class fu &#123; fu(int x) &#123; System.out.println(\"fu run\"); &#125;&#125;class zi extends fu &#123; zi() &#123; super(4);//隐士自带的调用父类空参数构造函数 System.out.println(\"zi run\"); &#125;&#125; 子类的实例化过程，子类中的每个构造函数都会访问父类中空参数的构造函数 结果：AC AD 123456789101112131415161718192021222324public class Extendstext &#123; public static void main(String[] args) &#123; new zi(); new zi(6); &#125;&#125;class fu &#123; fu()&#123; System.out.println(\"A\"); &#125; fu(int x) &#123; System.out.println(\"B\"); &#125;&#125;class zi extends fu &#123; zi() &#123; System.out.println(\"C\"); &#125; zi(int x)&#123; System.out.println(\"D\"); &#125;&#125; 结果：BD 123456789101112131415161718192021222324public class Extendstext &#123; public static void main(String[] args) &#123; new zi(6); &#125;&#125;class fu &#123; fu()&#123; System.out.println(\"A\"); &#125; fu(int x) &#123; System.out.println(\"B\"); &#125;&#125;class zi extends fu &#123; zi() &#123; System.out.println(\"C\"); &#125; zi(int x)&#123; super(x);//覆盖隐式super(); System.out.println(\"D\"); &#125;&#125; 为什么自子类实例化的时候，会调用父类构造方法？ 子类继承父类，所以子类有父类的属性，在使用父类内容前，要先看父类如何对自己的内容进行初始化，所以子类构造函数初始化的时候，必须调用父类构造函数，所以在子类的构造函数默认加了super(); 如果父类中没有定义无参构造函数或者说是父类中定义了有参，没有定义无参，那么必须用super();来指定调用父类的构造函数 如果子类的构造函数中使用了this();调用本类的构造函数，那么super();就没有了，因为super和this只能定义在第一行，所以只能有一个，但是可以保证的是，子类中肯定会有其他构造方法来访问父类的构造函数。 注意：super();语句必须要定义在子类构造函数的第一行，因为父类的初始化要先完成","pubDate":"Tue, 15 Oct 2019 12:08:31 GMT","guid":"https://augus-liuzhi.github.io/2019/10/15/继承/","category":""}]}