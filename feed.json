{"title":"哈哈，你不行","description":"my blog","language":"en","link":"https://augus-liuzhi.github.io","pubDate":"Fri, 30 Apr 2021 08:02:44 GMT","lastBuildDate":"Tue, 04 May 2021 08:13:58 GMT","generator":"hexo-generator-json-feed","webMaster":"哈哈，你不行","items":[{"title":"","link":"https://augus-liuzhi.github.io/2021/04/30/网络编程/","description":"http响应码301和302代表什么，有什么区别？ 301：永久重定向 302：暂时重定向 区别：301对搜索引擎优化更加有利，302有被提示网络拦截的风险 forward和redirect的区别 forward是转发发生在服务器内部，redirect是重定向 区别 forward的地址栏url不会发生变化，redirect地址栏url会发生变化 数据共享：forward可以共享Request的数据，redirect不能共享 效率： forward比redirect效率高 TCP和UDP的区别 TCP是面向连接传输数据，UDP是面向无连接发送数据 TCP提供可靠的服务，UDP无法保证 TCP面向字节流，UDP面向报文 TCP数据传输慢，UDP数据传输快 OSI的七层模型 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 Get和Post的请求的区别 get请求会被浏览器缓存，post请求不会 get请求传递参数有大小限制，post请求没有 post传输参数更加安全，get请求传递参数是以明文形式传递会显示在url上","pubDate":"Fri, 30 Apr 2021 08:02:44 GMT","guid":"https://augus-liuzhi.github.io/2021/04/30/网络编程/","category":""},{"title":"","link":"https://augus-liuzhi.github.io/2021/04/30/设计模式/","description":"设计模式设计模式的核心是分工，通过分工将对象与职责进行更细的划分，从而提高系统设计的可扩展性，使其更容易维护。 开放封闭原则：对扩展开放，对修改封闭。要添加新的逻辑，可以创建一个新的类，而不是在旧类上进行修改。 依赖倒置原则： 通常A类中调用B类的方法，是通过调用B的实现类进行实现的，而是依赖B的接口实现。 迪米特法则：又叫最少知识原则，一个类尽量与其他类发生关系，或者产生依赖，以此来使扩展更加容易。 工厂模式 三种工厂模式：简单工厂模式，工厂方法模式，抽象工厂模式 简单工厂模式 实质：工厂类根据输入参数的类型，动态的决定生成相对应参数类型的对象 也叫静态工厂模式 自定义实现1234//抽象类public abstract class Product &#123; public abstract void Create();&#125; 123456789101112//产品类Apublic class AProduct extends Product&#123; public void Create() &#123; System.out.println(\"A产品开始生产了\"); &#125;&#125;//产品类Bpublic class BProduct extends Product&#123; public void Create() &#123; System.out.println(\"B产品开始生产了\"); &#125;&#125; 1234567891011//工厂类public class Factory &#123; public static Product FactProduct(char type)&#123; Product product=null; switch (type)&#123; case 'A': product=new AProduct(); break; case 'B': product=new BProduct(); break; &#125; return product; &#125;&#125; 123456789//测试类public class Test &#123; public static void main(String[] args) &#123; Product product = Factory.FactProduct('A'); product.Create(); &#125;&#125;输出结果：A产品开始生产了 实际用途Spring中BeanFactory BeanFactory实现原理Bean容器启动阶段 读取XML配置文件，将Bean元素的分别转换成一个BeanDefinition对象 通过BeanDefinitionRegistry将这些Bean注册到beanFactory中，保存到一个co’ncurrentHashMap BeanDefinition注册到beanFactory之后，spring为我们提供了一个扩展切口，允许我们通过实现接口BeanFactoryPostProceessor在此处插入自定义代码。 Bean的实例化阶段 实例化阶段主要是通过反射或者CGlib对bean进行实例化。 工厂方法模式 实现方式：FactoryBean接口 实现原理：实现了FactoryBean接口的bean是一类叫做factory的bean,特点是：spring会在使用getBean的时候获得该bean时，会调用该bean的getobject()方法，所以返回的不是factory这个bean,而是这个bean.getObject()方法的返回值。 例子： spring和mybatis的整合 举例代码： 12345&lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:/Mapper/*.xml\"/&gt; &lt;/bean&gt; 123456public SqlSessionFactory getObject() throws Exception &#123; if (this.sqlSessionFactory == null) &#123; this.afterPropertiesSet(); &#125; return this.sqlSessionFactory; &#125; 说明： 实现了BeanFactory的接口，所以返回值不是SqlSessionFactoryBean的实例，而是SqlSessionFactoryBean的getObject()的返回值。 单例模式Spring的依赖注入默认是单例模式 设计要素 一个私有构造函数（确保只能自己创建实例） 一个静态变量（确保只有一个实例） 一个公共静态函数，提供对外的访问方式。 手写单例12345678910//饿汉式，线程安全public class Singleton &#123; private static Singleton singleton=new Singleton(); private Singleton()&#123;&#125; public static Singleton getSingleton()&#123; return singleton; &#125;&#125;优点：提前实例化好一个实例，避免了线程不安全问题出现。缺点：先实例化好了，如果系统很少使用，或者不使用造成系统资源浪费。 123456789101112//懒汉式，线程不安全public class Singleton &#123; private static Singleton singleton=null; private Singleton()&#123;&#125; public static Singleton getSingleton()&#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125;&#125;缺点：多线程环境下，如果多个线程同时进入if(singleton==null),那么就会有多个线程执行singleton=new Singleton()，造成多个对象实例化。 1234567891011//懒汉式，线程安全public class Singleton &#123; private static Singleton singleton=null; private Singleton()&#123;&#125; public static synchronized Singleton getSingleton()&#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125;&#125; 1234567891011121314151617//双重检查锁实现，线程安全public class Singleton &#123; private volatile static Singleton singleton = null; private Singleton() &#123; &#125; public static synchronized Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125;优点： 懒汉式线程安全缺点： 使用volatile对性能造成一定影响。 1234567891011//静态内部类，线程安全public class Singleton &#123; private Singleton()&#123;&#125; public static class Single&#123; private static final Singleton Instance=new Singleton(); &#125; public static Singleton getInstance()&#123; return Single.Instance; &#125;&#125;优点：延迟了实例化，节约资源，切线程安全，性能也提高了。 适配器模式实现方式： SpringMVC中的适配器HandlerAdatper 实现原理： HandlerAdatper根据Handler规则执行不同Handler 实现过程： DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。 HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。 装饰器模式 代理模式 观察者模式 策略模式 模板方法","pubDate":"Fri, 30 Apr 2021 02:02:17 GMT","guid":"https://augus-liuzhi.github.io/2021/04/30/设计模式/","category":""},{"title":"SpringSecurity","link":"https://augus-liuzhi.github.io/2021/04/14/SpringSecurity/","description":"1 整合Security1.1 导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 指定用户名密码1234security: user: name: 用户名 password: 密码 2 自定义登陆UserDetailsService接口123public interface UserDetailsService &#123; UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;&#125; UserDetails接口12345678910111213141516public interface UserDetails extends Serializable &#123; //获取所有权限 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); //获取密码 String getPassword(); //获取用户名 String getUsername(); //账户是否过期 boolean isAccountNonExpired(); //账户是否被锁定 boolean isAccountNonLocked(); //凭证是否过期 boolean isCredentialsNonExpired(); //是否可用 boolean isEnabled();&#125; 自定义认证逻辑需要实现UserDetailsService接口，该接口返回一个 UserDetails接口，则需要返回UserDetail接口的实现类User User类1234package org.springframework.security.core.userdetails;public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; username: 前端传来的username password: 密码是从数据库中查询出来的密码,此处只关心数据库中的密码，前端的密码框架会自动获取并且完成比较。 springSecurity会根据前端传来的密码，和数据库中的密码进行比较，如果相同认证成功，不过失败，则认证失败。 authorities:用户权限，不允许为null PasswordEncoder接口12345678910public interface PasswordEncoder &#123; //把参数按照特定的规则进行解析，加密 String encode(CharSequence var1); //验证从存储中获取到的密码与编码后的提交的原始密码是否一致，第一个参数为前段密码，第二个为存储密码 boolean matches(CharSequence var1, String var2); //解析的密码能够再次解析，达到更安全的结果则返回true,否则返回false default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125;&#125; BCryptPasswordEncoder类 passwordEncoder接口的实现类 BCryptPasswordgEncoder是基于Hash算法的实现的单向加密 12345678910111213@SpringBootTestpublic class Password &#123; @Test public void testPassword()&#123; PasswordEncoder passwordEncoder=new BCryptPasswordEncoder(); //对123进行加密 String encode = passwordEncoder.encode(\"123\"); System.out.println(encode); //判断1234是否和123加密后的匹配 boolean matches=passwordEncoder.matches(\"1234\",encode); System.out.println(matches); &#125;&#125; ValidateCodeFilter类12345678910111213141516171819202122232425262728293031323334@Componentpublic class ValidateCodeFilter extends OncePerRequestFilter &#123; @Autowired LoginFailHandle loginFailHandle; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //不是登陆请求不过滤 if (!\"/login\".equals(request.getServletPath())) &#123; filterChain.doFilter(request, response); return; &#125; try &#123; doValidateCode(request); filterChain.doFilter(request, response); &#125;catch (ValidateCodeException e)&#123; loginFailHandle.onAuthenticationFailure(request,response,e); throw new ValidateCodeException(\"校验验证码失败\"); &#125;finally &#123; request.getSession().removeAttribute(\"verify_code\"); &#125; &#125; public void doValidateCode(HttpServletRequest request)&#123; //获取表单中提交验证码的值 String FormVerifyCode=request.getParameter(\"imageCode\"); String captcha= (String) request.getSession().getAttribute(\"verify_code\"); if(FormVerifyCode==null)&#123; throw new ValidateCodeException(\"验证码输入为空\"); &#125; if(!FormVerifyCode.toLowerCase().equals(captcha.toLowerCase()))&#123; throw new ValidateCodeException(\"验证码输入错误\"); &#125; &#125;&#125; ValidateCodeException类12345public class ValidateCodeException extends AuthenticationException &#123; public ValidateCodeException(String msg) &#123; super(msg); &#125;&#125;","pubDate":"Wed, 14 Apr 2021 02:56:38 GMT","guid":"https://augus-liuzhi.github.io/2021/04/14/SpringSecurity/","category":""},{"title":"Jvm","link":"https://augus-liuzhi.github.io/2021/04/13/JVM/","description":"类的加载机制1. 类的加载 类的加载是指将类的字节码文件中的二进制数据读取到内存中，将其放在运行时数据区方法区内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。 1 什么时候启动类加载器 类的预加载，jvm允许类加载器预料某个类将要被使用时就预先加载他，如果预加载的类有错误，只有当该类被主程序调用时才会报错。如果一直没有被主程序调用，则不会报错。 1.2 从哪里去加载.class文件 本地磁盘 网上加载.class文件 数据库 压缩文件（ZAR,jar） 从其他文件生成JSP 2. 类的生命周期加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载 类加载过程包括加载，验证，准备，解析，初始化 加载 加载是类加载机制的第一个过程，在加载阶段，虚拟机主要完成三件事 （1）通过一个类的全限定类名来获取其定义的二进制字节流。 （2）将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。 （3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问结构 验证 作用：确保被加载类的正确性，主要完成四个阶段的验证 文本格式验证 元数据验证 字节码验证 符号引用验证 准备 为类变量分配内存并设置初始值 （1）类（static）变量：类变量会分配内存，但实例变量不会，实例变量会随着对象的实例化分配到堆中。 （2）默认初始化，不是赋值 解析 解析阶段主要是虚拟机将常量池中的符号引用转换为直接引用的过程。 符号引用：用一组符号描述所引用的目标，可以是任何形式的字面量，只要是能无歧义定位到目标就好。 直接引用：直接引用是可以指向目标的指针，相对偏移量或者一个能直接或间接定位到目标的句柄。和虚拟机实现的内存一样，不同虚拟机直接引用不同。 初始化 为类的静态变量赋值，在java中对类变量进行初始值设定有两种形式。 声明类变量是指定初始值 静态代码块为类变量指定初始值 JVM初始化步骤 如果这个类还没有加载和连接，则程序先加载并连接该类 如果该类的父类没有被初始化，则先初始化其直接父类 如果类中有初始化语句，则系统依次执行这些初始化语句 类的初始化时机：只有当该类的主动使用的时候才会导致类的初始化 new 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射 初始化某个类的子类，则父类也会被初始化 结束生命周期 执行System.exit()方法 程序正常执行 程序在执行过程中遇到了异常或错误 由于操作系统出现错误导致java虚拟机进程终止 3. 类加载器12345678910public class Mytest &#123; public static void main(String[] args) &#123; ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); System.out.println(contextClassLoader); System.out.println(contextClassLoader.getParent()); System.out.println(contextClassLoader.getParent().getParent()); System.out.println(contextClassLoader.getParent().getParent().getParent()); &#125;&#125; 输出结果： sun.misc.Launcher$AppClassLoader@64fef26a sun.misc.Launcher$ExtClassLoader@1ddd40f3 null：bootstrap是由c写的，所以报null java提供了三种类加载器，应用程序都是由这三种类加载器相互配合加载的，如果有必要，可以加入自定义类加载器 4. 类加载的三种方式 命令行启动应用时由JVM初始化加载 通过Class.forName()方法动态加载：将字节码文件加载到jvm中，不会执行static中的内容，只有在newInstance的时候才会执行static 通过ClassLoader.loadClass()方法动态加载 : 将字节码文件加载到jvm中，还会对类进行解释，执行类中static块。 5. 双亲委派模型 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 当AppClasLoader加载一个class时，他首先不会自己加载，而是把类加载请求委派给ExtClassLoader去完成 当ExtClassLoader加载一个class文件，他首先不会自己加载，而是把类加载请求委派给BootStrapClassLoader去完成 当BootStrapClassLoader收到一个加载请求，他去所对应的目录查找该类，如果没有，则交给ExtClassLoader,他也会去对应目录去查找，如果没有，交给AppClassLoader,如果他也找不到抛出classNotFound异常 双亲委派的意义： 防止出现多份同样的字节码文件 保证java程序安全稳定运行 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 6. 自定义类加载器123456789/** * 继承ClassLoader,重写finaClass方法 */public class PersonClassLoader extends ClassLoader&#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; return super.findClass(name); &#125;&#125; 注意： 传入的是类的全限定性类名 不要重写loadClass会破坏双亲委派模型 内存结构 内存结构主要分为三大部分：堆内存，方法区和栈 堆内存是jvm中最大一块由年轻代和老年代组成，年轻代内存分为Eden空间，From Survior空间，to Survivor空间，默认比例为8：1：1分配 方法区存储类信息，常量，静态变量等数据，是线程共享区域，为了和堆区分，又叫非堆 栈分为虚拟机栈和本地方法栈。 方法区和堆是线程共享区域，栈是线程私有的内存区域。 1. Java堆（Heap）java堆是jvm管理的内存中最大的一块，被所有线程所共享，所有的对象实例都在这里分配内存，堆是垃圾收集器管理的主要区域，因此有时称为GC堆，从内存回收角度看，现在大部分收集器都是采用分代收集算法，所以java堆中可以细分为新生代，老年代，新生代又可以分为eden,s1,s2空间。 2. 方法区（Method Area）方法区和堆一样都是各个线程共享的内存区域，他用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据，在hotSpot虚拟机，很多人愿意把方法区称为永久代，本质上两者不等价。 3. 程序计数器作用：当前线程所执行字节码行号指示器。 如果线程执行java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的native方法，这个计数器值则为空。 4. 虚拟机栈和程序计数器一样，虚拟机栈也是线程私有的，它的生命周期和线程一样，虚拟机栈描述的是java方法执行的内存模型，每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程 5. 本地方法栈本地方法栈和虚拟机栈发挥作用一致，虚拟机栈为执行java方法，本地方法栈为虚拟机使用到的native方法服务，和jvm栈一样，也会抛出stackoverflowerror和outofmemoryerror 垃圾收集器1. 对象存活的判断引用计数器法：每个对象有一个引用计数属性，新增一个引用时计数+1，引用释放的时候计数-1，当计数为0时，可以回收。（无法解决循环依赖问题） 可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则此对象不可达。 GC Roots包括： 虚拟机栈中的引用对象 方法区中类静态属性实体引用的对象 方法区中常量引用的对象 本地方法栈中JNI的引用 2. 垃圾收集算法标记-清除算法 算法分为标记和清除阶段，首先先标记所有要被清除的对象，在标记完所有要清除的对象后，统一进行回收所有标记对象。 缺点：1 效率低 2 产生大量不连续的内存碎片 复制算法 将内存容量分成两个大小相等的两块，每次只使用其中的一块，当这一块用完以后，如果还有存活的对象，就将剩下存活的对象复制到另一块上面，然后把用完的那块内存空间一次清理掉。 缺点：将内存缩小为原来的一半，复制长期存活的对象导致效率低 标记-压缩（整理）算法 将所有存活的对象移动到一端，直接清除存活对象便捷以外的内存 分代收集算法 将java堆分为老年代和新生代，根据各个年代的特点采用适当的收集算法，在新生代中只有少量对象存活，采用复制算法，在老年代中，对象长期存活，没有额外的空间对他进行分配担保，就必须使用标记-清除或标记-整理算法进行回收。 3. 垃圾收集器3.1 serial收集器 串行收集器最古老，最稳定以及效率最高，可能会产生停顿，只使用一个线程去回收，新生代，老年代采用串行收集器，新生代复制算法，老年代标记-压缩，垃圾收集的过程会stop the world(服务暂停) 3.2 parNew收集器 parNew收集器是serial的多线程版本。新生代并行，老年代串行，新生代复制算法，老年代标记-整理算法 3.3 parallel收集器 parallel scavenge收集器类似于parNew，parallel更关注于系统的吞吐量，可以通过参数来打开自适应调节策略，虚拟机会根据当前系统运行的情况收集性能监控信息，动态调整这些参数，以提供合适的停顿时间或者最大吞吐量，也可以通过参数控制gc时间不大于多少毫秒或者比例，新生代复制算法，老年代标记-整理算法 3.4 parallel old 收集器 parallel old 是parallel scavenge收集器的老年代版本，使用多线程和标记-整理算法 3.5 CMS收集器 获取最短停顿时间为目标的收集器，目前很大一部分的java应用都集中互联网或B/S系统的服务端，这类服务尤其重视服务的响应速度，希望系统停顿时间最短，给用户带来较好的体验。 初始标记 —&gt;停止服务 标记一下GC roots能够直接关联到的对象，速度很快 并发标记 进行GC roots Trancing 的过程 重新标记 —&gt;停止服务 修改并发标记期间，因用户程序运作而导致标记产生变动的那一部分对象 并发清除 这个阶段停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。 收集器线程都可以与用户线程一起工作，所以总体来说，CMS收集器的内存回收过程与用户线程一起并发执行。老年代收集器，新生代使用parNew 优点：并发收集，低停顿 缺点：产生大量碎片，并发阶段降低吞吐量 3.6 G1收集器 特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片，分配大对象时不会因为无法找到连续空间提前出发下一次GC 可预测停顿,降低停顿时间是G1和CMS共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集的时间不得超过N毫秒 收集步骤： 标记阶段 首先初始标记，这个阶段是停顿的，并且会触发一次普通mintor gc Root region Scanning 程序运行过程会回收survivor区，这一过程必须在young gc之前完成 Concurrent marking：在整个堆中进行并发标记，此过程可能被young gc中打断，在并发标记阶段，若该区域中的对象都是垃圾，立刻回收该区域，同时并发阶段会计算每个区域的对象的存活性 Remark 再标记，再标记阶段用来收集并发阶段产生新的垃圾。 copy/clean up 多线程清楚失活对象 调优1. JDK监控故障处理命令 jps [options] [hostid] jstat [options] LVMID [interval] [count] 2. 获取GC日志 使用命令查看 jstat -gc 在容器中设置相关参数打印日志 -xx: printGc 3. GC分析工具 GChisto 4. JVM监控分析工具 jconsole 5. 内存溢出和内存泄漏内存溢出：程序在申请内存时，没有足够空间供其使用出现out of memory 内存泄漏： 程序申请内存后，无法释放已经申请的内存空间，一次内存泄漏危害可以忽略，但是内存泄漏堆积，无论多少内存，迟早会被占光，导致内存溢出。","pubDate":"Tue, 13 Apr 2021 10:06:09 GMT","guid":"https://augus-liuzhi.github.io/2021/04/13/JVM/","category":""},{"title":"axios","link":"https://augus-liuzhi.github.io/2021/04/12/axios/","description":"Axios基于promise对ajax的一种封装。 安装npm安装1npm install axios CDN1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 基本使用123456#默认方式，默认使用Get方式请求 axios(&#123; url:'https://autumnfish.cn/api/joke', &#125;).then(res=&gt;&#123; console.log(res); &#125;) 1234567#Get请求，无参数请求axios(&#123; url:'https://autumnfish.cn/api/joke', method:'get', &#125;).then(res=&gt;&#123; console.log(res); &#125;) 123456789101112#Get请求，有参数请求axios(&#123; url:'https://autumnfish.cn/api/joke', method:'get', params:&#123; id:'1', name:'haha', ……………… &#125; &#125;).then(res=&gt;&#123; console.log(res); &#125;) 123456789101112#Post请求，有参数axios(&#123; url:'https://autumnfish.cn/api/joke', method:'post', params:&#123; id:'1', name:'haha', ……………… &#125; &#125;).then(res=&gt;&#123; console.log(res); &#125;) 请求方式Get请求123456789101112#Get无参数请求axios.get('https://autumnfish.cn/api/joke111').then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(\"timeout\"); &#125;)#Get有参数请求 axios.get('https://autumnfish.cn/api/joke', &#123;params:&#123;id:3&#125;&#125;).then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(\"timeout\"); &#125;) Post请求123456789101112#post请求，无参数 axios.post('https://autumnfish.cn/api/joke').then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(\"timeout\") &#125;)#post请求，有参数，使用data传递参数，后台要使用@RequestBody注解axios.post('https://autumnfish.cn/api/joke',\"id=1\").then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(\"timeout\") &#125;) 并发请求123456789101112131415161718192021axios.all([ axios.get('https://autumnfish.cn/api/joke'), axios.get('https://autumnfish.cn/api/joke'), ]).then(res=&gt;&#123; console.log(res[0]); console.log(res[1]); &#125;).catch(err=&gt;&#123; console.log(\"timeout\"); &#125;)===== axios.all([ axios.get('https://autumnfish.cn/api/joke'), axios.get('https://autumnfish.cn/api/joke'), ]).then( axios.spread((res1,res2)=&gt;&#123; console.log(res1); console.log(res2); &#125;) ).catch(err=&gt;&#123; console.log(\"timeout\"); &#125;) 全局配置12345678axios.defaults.baseURL='https://autumnfish.cn/api'; axios.defaults.timeout=5;//全局配置基础上，进行网络请求 axios.get('/joke').then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(err); &#125;) 实例123456789let newVar =axios.create(&#123; baseeURL:'https://autumnfish.cn/api', timeout:5, &#125;) newVar.get('/joke').then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(err); &#125;) 拦截器请求方向的拦截，成功请求，失败请求。 响应方向的拦截。 主要用于在网络请求的时候，发起请求或者响应时对操作进行相应的进行处理。 发起请求时可以添加网页加载的动画，token认证的时候，强制登陆。 响应的时候进行相应的数据处理。 1234567891011121314151617181920212223242526#请求方向 axios.interceptors.request.use(config=&gt;&#123; console.log(\"进入拦截器\"); console.log(config); return config;//放行 &#125;,err=&gt;&#123; console.log(\"请求失败\"); &#125;) axios.get('https://autumnfish.cn/api/joke').then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(err); &#125;)#响应方向 axios.interceptors.response.use(config=&gt;&#123; console.log(\"进入拦截器\"); console.log(config); return config;//放行 &#125;,err=&gt;&#123; console.log(\"响应失败\"); &#125;) axios.get('https://autumnfish.cn/api/joke').then(res=&gt;&#123; console.log(res); &#125;).catch(err=&gt;&#123; console.log(err); &#125;)","pubDate":"Mon, 12 Apr 2021 01:15:30 GMT","guid":"https://augus-liuzhi.github.io/2021/04/12/axios/","category":""},{"title":"Docker","link":"https://augus-liuzhi.github.io/2021/03/31/Docker/","description":"Docker安装环境： Centos7 1. 设置仓库1234yum install -y yum-utilsyum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 2. 安装Docker引擎1yum install docker-ce docker-ce-cli containerd.io 默认安装最新版 如果安装指定版本 1234#查看docker的版本yum list docker-ce --showduplicates | sort -r#安装指定版本号的dockeryum install docker-ce-&lt;版本号&gt; docker-ce-cli-&lt;版本号&gt; containerd.io 3. 运行Docker1systemctl start docker 4. Hello-world1docker run hello-world 显示Hello from Docker!到这就安装成功了 5. docker镜像加速12345vim /etc/docker/deamon.json #编辑此文件，写deamon.json为阿里云镜像源，为镜像加速&#123; \"registry-mirrors\": [\"https://alzgoonw.mirror.aliyuncs.com\"] &#125; Docker使用1. 查看已有的镜像列表1docker images 2. 查找镜像1docker search 镜像名 3. 下载镜像1docker pull 镜像名 4. 删除镜像1docker rmi 镜像名 5. 运行容器1docker run -d 后台运行 --name 给容器起个名 -p 容器端口映射到外部端口 镜像:版本 6. 关闭容器1docker stop 容器id 7. 运行以后再次启动容器1docker start 容器id 8. 进入容器后台1docker exec -it 容器id /bin/bash 9. 退出交互模式1exit","pubDate":"Wed, 31 Mar 2021 08:34:09 GMT","guid":"https://augus-liuzhi.github.io/2021/03/31/Docker/","category":""},{"title":"SpringBoot数据访问","link":"https://augus-liuzhi.github.io/2021/03/31/springboot整合数据/","description":"SpringBoot数据访问数据访问jdbc1. 导入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 2. 配置文件 123456spring: datasource: url: jdbc:mysql://localhost:3306/ssm0306?useSSL=false&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 3. 原理 123456789101112131415org.springframework.boot.autoconfigure.jdbc.DataSourceConfigurationDataSourceConfiguration根据properties文件配置数据源信息，根据环境中有哪些类型，并自动选取类型，也可以自定义类型常见的数据源类型： oracle.ucp.jdbc.PoolDataSource org.apache.commons.dbcp2.BasicDataSource com.zaxxer.hikari.HikariDataSource org.apache.tomcat.jdbc.pool.DataSource自定义类型：protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) &#123; return properties.initializeDataSourceBuilder().type(type).build(); &#125;通过initializeDataSourceBuilder()创建自定义的数据源类型public DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123; return DataSourceBuilder.create(this.getClassLoader()).type(this.getType()).driverClassName(this.determineDriverClassName()).url(this.determineUrl()).username(this.determineUsername()).password(this.determinePassword()); &#125; 4. 启动执行SQL脚本 12345678910配置文件将schema-*.sql放到resource路径下，*代表任意名schema: classpath:schema-*.sql连接的是mysql数据库 platform: mysql 初始化数据源：alwaya全部数据源 initialization-mode: always 数据库脚本文件的分隔符 separator: $ 执行完第一次以后，将此配置删除，否则再次启动项目，会重现创建表格导致启动失败。 5. 操作数据库 123456789101112131415Spring提供的JdbcTemplate操作数据库 @Bean @Primary JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); Template template = properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) &#123; jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds()); &#125; return jdbcTemplate; &#125;只要有数据源，和数据源信息，就可以自动注入直接使用jdbcTemplate 123456789101112@Controllerpublic class HelloController &#123; @Autowired JdbcTemplate jdbcTemplate; @GetMapping(\"/dep\") @ResponseBody public Map get()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(\"select * from dep\"); return maps.get(0); &#125;&#125; 整合Druid1. 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; 2. 配置文件 1234567spring: datasource: url: jdbc:mysql://localhost:3306/ssm0306?useSSL=false&amp;serverTimezone=UTC username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource 3. 配置数据库监控 12345678910111213141516171819202122232425262728293031@Configurationpublic class DruidConfig &#123; @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean getStatViewServlet()&#123; ServletRegistrationBean statViewServlet = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); //配置监控页面登陆的用户名和密码 statViewServlet.addInitParameter(\"loginUsername\",\"admin\"); statViewServlet.addInitParameter(\"loginPassword\",\"admin\"); //配置登陆监控网站的黑白名单 statViewServlet.addInitParameter(\"allow\", \"127.0.0.1\"); statViewServlet.addInitParameter(\"deny\", \"192.168.43.179\"); //是否允许重置 statViewServlet.addInitParameter(\"resetEnable\",\"false\"); return statViewServlet; &#125; @Bean public FilterRegistrationBean getStatFilter()&#123; FilterRegistrationBean statFilter=new FilterRegistrationBean(new WebStatFilter()); //添加过滤地址 statFilter.addUrlPatterns(\"/*\"); //设置过滤规则 statFilter.addInitParameter(\"exclusions\",\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/ *,\"); return statFilter; &#125;&#125; 整合Mybatis1. 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 1.1 注解配置 123456@Mapper@Componentpublic interface DepartmentMapper &#123; @Select(\"select * from dep where depid=#&#123;id&#125;\") public Department selectById(Integer id);&#125; 123public interface DeparmentService &#123; public Department selectById(Integer id);&#125; 123456789@Servicepublic class DepartmentServiceImpl implements DeparmentService &#123; @Autowired DepartmentMapper departmentMapper; @Override public Department selectById(Integer id) &#123; return departmentMapper.selectById(id); &#125;&#125; 123456789@RestControllerpublic class DepController &#123; @Autowired DepartmentServiceImpl departmentService; @GetMapping(\"/deparment/&#123;id&#125;\") public Department getDepartment(@PathVariable(\"id\") Integer id)&#123; return departmentService.selectById(id); &#125;&#125; 1.2 xml配置 1234mybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml指定主配置文件和mapper的映射文件 12345&lt;mapper namespace=\"com.ccut.springboot06.springboot06data.Mapper.DepartmentMapper\"&gt;&lt;select id=\"selectById\" parameterType=\"int\" resultType=\"com.ccut.springboot06.springboot06data.Bean.Department\"&gt; select * from dep where depid=#&#123;id&#125;&lt;/select&gt;&lt;/mapper&gt; 注意： @Mapper 配置类为mapper类 @MapperScan(value = “扫描包名”) 整合JPA导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件 12345678910111213spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm0306?useSSL=false&amp;serverTimezone=Asia/Shanghai username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource jpa: hibernate: #自动生成表 ddl-auto: update #控制台显示Sql show-sql: true 实体类 12345678910111213141516@JsonIgnoreProperties(value = &#123; \"hibernateLazyInitializer\", \"handler\" &#125;)@Entity@Table@Datapublic class User &#123; //指定主键 @Id //主键自增长 @GeneratedValue(strategy= GenerationType.IDENTITY) private Integer id; //指定列 @Column private String username; @Column private String password;&#125; Dao 123public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; Service 1234public interface UserService &#123; public User SelectUserById(Integer id);&#125; 123456789@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserRepository userRepository; @Override public User SelectUserById(Integer id) &#123; return userRepository.getOne(id); &#125;&#125; Controller 12345678910@RestControllerpublic class MyController &#123; @Autowired UserServiceImpl userService; @GetMapping(\"/user/&#123;id&#125;\") public User getUser(@PathVariable(\"id\") Integer id)&#123; User one = userService.SelectUserById(id); return one; &#125;&#125; JPA导入Repository两种方式 123456789101112131415/** * 方式1 * 继承JpaRepository给出实体类，以及主键类型 */public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125;/** * 方式2 * 继承给出实体类，以及主键类型 */@RepositoryDefinition(domainClass = User.class,idClass = Integer.class)public interface UserRepository &#123;&#125;","pubDate":"Wed, 31 Mar 2021 07:57:18 GMT","guid":"https://augus-liuzhi.github.io/2021/03/31/springboot整合数据/","category":""},{"title":"SpringCloudAlibaba","link":"https://augus-liuzhi.github.io/2021/03/02/SpringCloudAlibaba/","description":"","pubDate":"Tue, 02 Mar 2021 06:44:59 GMT","guid":"https://augus-liuzhi.github.io/2021/03/02/SpringCloudAlibaba/","category":""},{"title":"Redis","link":"https://augus-liuzhi.github.io/2021/02/19/redis/","description":"RedisRedis简介基于内存运行，并支持持久化，高性能的NoSql数据库，redis中的数据大部分都是存储在内存中，适合存储频繁访问数据量比较少的数据。 Redis特点 支持数据持久化 支持多种数据结构 支持数据备份 安装 Centos7下安装redis-6.0.6 12345$ wget http://download.redis.io/releases/redis-6.0.6.tar.gz$ tar xzf redis-6.0.6.tar.gz$ cd redis-6.0.6$ make MALLOC=libc$ make install make install 将redis安装目录下src目录中生成的一列可执行文件拷贝到/usr/local/bin,类似于放到环境变量中，可以在任意目录使用redis命令 启动redis 前台启动：redis-server 后台启动：redis-server &amp; 指定配置文件启动：redis-server redis.conf &amp; 关闭redis kill -9 pid redic-cli shutdown 客户端链接Redisredis-cli redis-cli -h 127.0.0.1 -p 6379 退出客户端 exit quit 基本常识 测试Redis性能 1$ redis-benchmark 查看redis是否正常运行 1234$ redis-cli127.0.0.1:6379&gt; pingPONG显示PONG则为正常 查看redis服务器统计信息 12345$ redis-cli#查看所有信息127.0.0.1:6379&gt; info#查看指定信息127.0.0.1:6379&gt; info [信息段] redis的数据库实例 作用类似于mysql的数据库实例，redis中的数据库实例只能由redis服务来创建和维护，开发人员没有权限修改和创建数据库实例，默认情况下，redis会自动创建16个数据库实例，并且给这些数据库实例进行编号，从0开始，一直到15，通过使用编号来使用数据库，可以通过配置文件，指定redis自动创建数据库的个数，redis每个数据库实例本身占用的存储空间是很少的，所以也不会造成太多浪费。redis客户端默认使用0号库，可以使用select index切换数据库。 查询数据中有几条数据：dbsize 查询数据库中所有的key：key * 清空当前数据库：flushdb 清空所有数据库：flshall 查看redis中的配置信息：config get * 查看redis中指定信息：config get [port] 数据结构字符串 列表 集合 哈希 有序集合 操作命令 redis中有关key的操作命令 keys 通配符 ：查看数据库中key keys * 查看数据库中所有的key keys k* 查看数据库中所有k开头后面有0个或多个字符的key keys k? 查看数据库中K开头，后面仅有一个字符的key keys k[0-9] 查看数据库中k开头，后面仅有一个字符，包含0-9的字符 判断key是否存在数据库中 exists key 如果存在返回1，如果不存在返回0 移动k到指定数据库 move key index key 为指定key index为指定的数据库 查看key的剩余ttl时间 ttl keyname 返回值 -2 key不存在 返回值-1 当前key未设置ttl时间 设置最大生存ttl时间 EXPIRE keyname ttl时间 查看key的数据类型 type keyname 重命名key rename oldkey newkey 删除key del keyname String操作命令设置指定key的值(如果key已经存在，会覆盖以前的value) set key value 获取指定key的值 get key 追加指定key的value(返回追加之后的字符串的长度，如果key不存在，则新创建一个key value) append key value 获取指定key的长度 strlen key 指定key+1运算 incr key 指定key加指定增量运算 incr key increment 指定key-1运算 decr key 指定key减指定减量运算 decrby key decrment 加减运算必须是数值 字符串截取 getrange key startindex endindex 修改部分字符串 setrange key startindex value 设置值的同时设置最大生命周期 setex key second value 当key不存在时设置值,key存在则设置失败 setnx key value 批量设置数据 mset key1 v1 key2 v2 key3 v3 批量获取key的值 mget k1 k2 k3 批量设置key不存在时再设置,有一个失败，全部失败 msetnx list操作命令单个key,多个有序的value,最左侧是表头，最右侧是表尾。每个元素都有下标，从0开始，也可以用负数表示，从表尾开始，元素的在列表中的顺序，由放入顺序决定。 将1个或多个值放入往表头插入 lpush key v1 v2 v3 获取列表中指定区间下标的元素 将1个或多个值放入往表尾插入 rpush key v1 v2 v3 删除表头的第一个元素并返回该元素 lpop key 删除表尾的元素，并返回该元素 rpop key 获取列表的长度 llen key 通过索引获取列表的值 lindex key index 移除并获取列表的第一个元素 blpop key timeout 移除并获取列表的最后一个元素 brpop key timeout 在列表的元素前或后插入元素 linsert key before/after 指定元素 value 给已存在的列表元素 rpushx key value 移除列表中某些数据 lrem key count value count&gt;0 从列表左侧移除count个数据 count&lt;0从列表右侧移除count个数据 修剪列表，删除不在区间之内的元素 LRANGE key startindex endindex Set操作命令单key有多个无序的value,一个key有多个value,value之间没有顺序，并且不能重复 将一个或多个存储到set sadd key value 获取指定集合中的元素 SMEMBERS key 判断元素是否存在集合中,存在返回1，不存在返回0 SISMEMBER key value 获取集合的长度 SCARD key 移除指定集合中的一个或多个元素,返回成功移除的个数 srem key vlaue value value 随机获取一个或多个元素 srandmember key count 随机移除一个或多个元素 spop key count 将一个集合的元素移动到另一个集合 smove source destination value 求差集key1中有，key2中没有 sdiff key1 key2…… 获取集合的交集 sinter key1 key2 获取集合的并集 sunion key1 key2 hash操作命令单key:field-value 将一个或多个单key:field-value设置到哈希表中 hset stu1001 id 1001 获取指定哈希表中的指定filed的值 hget key filed 批量获取哈希表中filed的值 hmget key filedname1 filedname2…… 获取指定哈希表所有filed和value hgetall key 删除哈希表中一个filed或多个filed hdel key filedname1 filedname2 获取哈希表中所有filed的个数 hlen key 判断哈希表中是否存在某一个filed hexists key files 获取哈希表中所有filed hkeys key 获取哈希表中所有的value hvals key 对指定哈希表中指定filed值进行整数加法运算 hincreby key filed increment 对指定哈希表中指定filed值进行浮点数加法运算 hincrebyfloat key filed increment 设置filed-value,当其不存在时设置 hsetnx key filed value Zset操作命令有序集合,元素有序，且不能重复，zset每个元素都会关联一个分数，分数可以重复，redis通过分数的大小进行排序，有序集合都有顺序，每个元素都有一个下标，和list排序规则不一样，list是放入顺序，zset是分数大小排序。 将一个或多个memeber及其分数值加入有序集合 zadd key score value score value 获取指定有序集合中指定下标区间的元素 zrange key srartindex endindex withscores 获取指定分数区间的有序集合的元素 zrangebyscore key min max withscores 删除指定有序集合元素 zrem key value 获取有序集合中元素的个数 zcard zset01 获取指定有序集合中指定的元素排名 zrank key value,排名从0开始 获取指定分数区间的有序集合的个数 zcount key startscore endscore 获取指定元素的分数 zscore key vlaue redis配置文件网络配置 port: 指定redis服务所使用的端口，默认使用6379 bind: 配置客户端连接redis服务时，所使用的ip地址 redis-cli -h 192.168.43.179 -p 6379 tcp-keepalieve：连接保活策略 常规配置 loglevel:配置日志级别，开发阶段配置debug,上线配置notcing和warning logfile:指定日志文件，redis运行过程会输出一些日志信息，默认情况信息会输出到控制台，我们可以使用logfile配置 database 16：默认配置16个数据库实例 安全配置 requirepass：设置redis服务时，所使用的密码，默认不使用。此参数protected-mode=yes时才起作用。 一旦设置密码验证，客户端连接redis服务时，必须使用密码连接，redis-cli -a pwd -h ip -p port redis持久化redis是内存数据库，他把数据存储到内存中，高效访问的同时带来了安全问题–宕机导致数据丢失，redis提供了持久化策略，适当的时候把内存的数据持久化到硬盘，每次redis服务启动时，都可以把磁盘上的数据再次加载到内存中使用。 RDB策略：在指定时间间隔内，redis服务执行指定次数写操作，会触发一次持久化操作。默认使用。 save second change 多少秒，进行多少次写操作，触发持久化。 dbfilename：持久化文件名称 dir : ./ 持久化文件保存目录 缺点：最后写的数据可能会丢失，不能完全持久化。 AOF策略：采用操作日志来记录每一次写操作。每次redis服务启动时，都会执行一遍操作。效率低，默认不开启。 appendonly ：配置是否开启AOF策略 appendfilename：配置操作日志文件 小结：根据数据的特点决定开启哪种策略，一般情况开启rdb足够 事务事务：把一组数据库写操作放到一起执行，保证操作的原子性，要么同时成功，要么同时失败。 redis事务，允许把一组redis命令放在一起执行，把命令进行序列化，按照顺序依次执行，保证部分原子性。 multi:标记一个事务的开启 exec:执行队列中事务 redis事务只能保证部分原子性，一组命令中，进入事务队列如果发生错误，则该事务的所用命令都不执行，保证事务的原子性。 一组命令中，进入队列过程正常，但是在执行队列任务命令发生了错误，则只会影响该命令的错误，不会影响其他命令执行，所以不能保证事务的原子性。 discard：放弃压入队列的命令。清楚所有已经压入队列中的命令，结束整个事务。 watch：监控某一个key-vlaue,当事务执行过程中，key-value发生改变，则事务放弃执行，否则正常执行。 unwatch : 放弃监控所有键 消息发布与订阅redis订阅频道，消息的发布者往频道上发布消息，所有订阅频道的客户端都能收到消息。 subscribe：订阅一个或多个频道消息 subscribe ch1 ch2，psubscribe也可以订阅，订阅的频道名支持通配符。 publish : 将消息发送到指定频道。 主从复制主少从多，主写从读，读写分离，主写同步复制到从。 搭建一主而从 搭建3台redis服务，用一个redis模拟三台redis服务，修改redis的配置文件，提供三份配置文件。 分别启动三个redis服务 查看redis服务的角色，info 先往6379写数据，三台redis服务相互独立，互不影响。 设置主从关系，设置6379主机，6380，6381从机 全量复制：主从关系确定，会将主机上已有的数据全部复制到从机。 增量复制 : 主机写数据，会自动同步到从机 主写从读，读写分离：6380和6381上写数据报错。 主机宕机：关闭6379服务，从机原地待命。 主机恢复：无影响 从机宕机：关闭6380服务，主机少一个从机，其他从机不变。 从机恢复：必须重新设置主从关系 从机上位：关闭主机，断开主从关系，SLAVEOF no one,重新设置主从关系 原主机恢复：可恢复成主机，也可以变成主机，从机也可以有从机，一台主机有多个从机，一个从机也可以有多个从机，主机数据会依次传递数据。 哨兵模式 搭建一主二从集群架构 提供一个哨兵配置文件 : redis_sentinel.conf 启动哨兵服务 主机宕机，哨兵自动选举从机上位 之前主机恢复","pubDate":"Fri, 19 Feb 2021 02:30:26 GMT","guid":"https://augus-liuzhi.github.io/2021/02/19/redis/","category":""},{"title":"微服务Gateway","link":"https://augus-liuzhi.github.io/2021/02/02/GateWay/","description":"Gateway SpringCloud Gateway 使用的webflux中的reactor-netty响应式编程组件，底层使用的Netty通讯框架 路由 断言 过滤","pubDate":"Tue, 02 Feb 2021 01:49:34 GMT","guid":"https://augus-liuzhi.github.io/2021/02/02/GateWay/","category":""},{"title":"Hystrix","link":"https://augus-liuzhi.github.io/2021/01/28/Hystrix/","description":"HYSTRIX服务降级服务器压力剧增，根据当前服务和流量对一些服务和页面进行有策略的降级，来保证服务器的高可用。 当出现问题时，它直接返回一个提前准备好的fallback(退路)错误处理信息，这样虽然提供了一个有损的服务但是保证了整个系统的稳定性和可用性。 服务熔断为了防止整个系统雪崩，暂停对该服务的调用。 熔断VS降级相同点： 目标一致都是从可用性和可靠性出发，为了防止系统崩溃 用户体验类似，最终都是让用户体验到某些功能暂时不可用 不同点： 触发原因不同，服务熔断是下游服务故障导致的，服务降级是保证服务的高可用 服务限流秒杀高并发等操作，为了保证服务不被大量请求冲垮，通过限制请求速度来保护系统","pubDate":"Thu, 28 Jan 2021 05:50:43 GMT","guid":"https://augus-liuzhi.github.io/2021/01/28/Hystrix/","category":""},{"title":"Ribbon","link":"https://augus-liuzhi.github.io/2021/01/26/Ribbon/","description":"RibbonRibbon客户端负载均衡工具","pubDate":"Tue, 26 Jan 2021 05:53:05 GMT","guid":"https://augus-liuzhi.github.io/2021/01/26/Ribbon/","category":""},{"title":"服务发现Consul","link":"https://augus-liuzhi.github.io/2021/01/25/Consul/","description":"ConsulconsulConsul是一个服务网格解决方案，它提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。这些特性中的每一个都可以根据需要单独使用，也可以一起用于构建全服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。领事船与一个简单的内置代理，使一切工作的开箱即用，但也支持第三方代理集成，如特使。 key featuresService Discovery Health Checking KV Store Secure Service Communication Multi Datacenter 启动命令 1docker run -d -p 8500:8500/tcp --name consulconsul consul agent -server -ui -bootstrap-expect=1 -client=0.0.0.0","pubDate":"Mon, 25 Jan 2021 07:48:55 GMT","guid":"https://augus-liuzhi.github.io/2021/01/25/Consul/","category":""},{"title":"ZooKeeper","link":"https://augus-liuzhi.github.io/2021/01/25/Zookeeper/","description":"Zookeeper","pubDate":"Mon, 25 Jan 2021 06:03:20 GMT","guid":"https://augus-liuzhi.github.io/2021/01/25/Zookeeper/","category":""},{"title":"微服务注册与发现中心Eureka","link":"https://augus-liuzhi.github.io/2021/01/22/Eureka/","description":"Eureka1. Eureka简介Eureka是一种基于REST服务，主要用在AWS云，用于定位服务，实现中间层服务器的负载平衡和故障转移。 在微服务中，Eureka是微服务的注册与发现中心，主管服务的注册与发现，使用简单的服务标识符，consumer微服务想要访问provider微服务,不需要修改服务调用的配置文件。 2. Eureka两大组件1.Eureka Server 提供服务注册服务，各个微服务启动后的会在Eureka Server进行服务的注册，Eureka Server会将各个可用微服务节点存储到服务注册表中。 Eureka Server功能 服务注册 服务提供者启动后，会通过Eureka Client向Eureka Server注册信息，Eureka Server会存储该服务信息，Eureka Server内部有两层缓存机制来维护整个注册表。 提供注册表 服务消费者调用服务时，如果Eureka Client没有缓存注册表，会从Eureka Server获取最新的注册表 同步状态 Eureka Client通过注册，心跳机制和Eureka Server同步当前客户端的状态 2.Eureka Client 是一个java客户端，用于简化和Eureka Server交互，客户端同时具有一个内置的，使用轮询算法的负载均衡器。客户端启动后会向Eureka Server发送心跳，默认周期30S,如果Eureka Server在3个心跳周期内(默认90S)没有收到该客户端发送心跳，Eureka Server将会在服务列表删除该节点信息。 3.创建Eureka Server pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213server: port: 7001eureka: instance: hostname: eureka7001.com client: #是否向注册中心注册自己 register-with-eureka: false #是否从Eureka Server获取注册实例信息 fetch-registry: false #设置注册中心地址 service-url: defaultZone: http://eureka7001.com:7001/eureka 主启动类 12345678@SpringBootApplication#开启Eureka Server服务@EnableEurekaServerpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class,args); &#125;&#125; 4. 创建Eureka Client pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 1234567891011spring: application: name: cloud-order-serviceserver: port: 8888eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka 主启动 12345678@SpringBootApplication#开启Eureka Client客户端@EnableEurekaClientpublic class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; 3. Eureka架构 Eureka Server：表示注册中心集群 us-east-xxx：表示集群所在的区域 Application Service：表示服务提供者 Application Client：表示服务消费者 Eureka Client：表示Eureka客户端 4. Eureka原理eureka server可以集群部署，多个节点之间会进行（异步方式）数据同步，保证数据最终一致性，Eureka Server作为一个开箱即用的服务注册中心，提供的功能包括：服务注册、接收服务心跳、服务剔除、服务下线等。需要注意的是，Eureka Server同时也是一个Eureka Client，在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server进行拉取注册表、服务注册和发送心跳等操作。 5. 自我保护默认情况下，如果 Eureka Server 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。 Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 Eureka 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。 1eureka.server.enable-self-preservation=true 6. Eureka和Zookeeper对比CAP理论一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 两者区别zookeeper优先保证CP，当服务发生故障会进行leader的选举，整个期间服务处在不可用状态，如果选举时间过长势必会大幅度降低性能，另外就用途来说zookeeper偏向于服务的协调，当然含有注册中心的作用。 eureka优先保证AP, 即服务的节点各个都是平等的，没有leader不leader一说， 当服务发生故障时，其余的节点仍然可以提供服务，因此在出现故障时，性能表现优于zookeeper，但是可能会造成数据不一致的情况。 Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。","pubDate":"Fri, 22 Jan 2021 06:33:55 GMT","guid":"https://augus-liuzhi.github.io/2021/01/22/Eureka/","category":""},{"title":"SpringCloud","link":"https://augus-liuzhi.github.io/2021/01/20/SpringCloud-md/","description":"springcloud环境搭建 创建项目 名称为springcloud002，删除SRC文件夹，隐藏无关紧要的其他文件。 ​ 工程下只有POM.xml文件。 修改pom.xml文件 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springcloud002&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--父项目传递依赖--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--指定依赖版本号--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.cloud-version&gt;Hoxton.SR9&lt;/spring.cloud-version&gt; &lt;spring.boot-version&gt;2.3.5.RELEASE&lt;/spring.boot-version&gt; &lt;/properties&gt; &lt;!--父项目管理依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.boot-version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud-version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;/project&gt; ​ springcloud和springboot版本的选择参见官网。 ​ https://spring.io/projects/spring-cloud#learn ​ 添加子工程 通过maven创建Module ​","pubDate":"Wed, 20 Jan 2021 08:44:15 GMT","guid":"https://augus-liuzhi.github.io/2021/01/20/SpringCloud-md/","category":""},{"title":"RabbitMQ","link":"https://augus-liuzhi.github.io/2021/01/14/RabbitMQ/","description":"工作模式简单模式 P : 生产者，发送消息 queue : 队列 C : 消费者，接收消息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class publisher &#123; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\");//设置虚拟机 //3.获取Connection Connection connectionPub=factory.newConnection(); //4.获取channel Channel channel=connectionPub.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"hello\",true,false,false,null); //6.发送消息 /* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数: exchange:交换机,简单模式默认为”“ routingKey:路由名称,简单模式默认和队列名字一致 props:配置信息 body:发送消息的内容 */ String body=\"hello rabbitMQ\"; channel.basicPublish(\"\",\"hello\",null,body.getBytes()); //7.释放资源 channel.close(); connectionPub.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class consumer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connection=factory.newConnection(); //4.获取channel Channel channel=connection.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"hello\",true,false,false,null); //6 接收消息 /* (String queue, boolean autoAck, Consumer callback) */ DefaultConsumer defaultConsumer=new DefaultConsumer(channel)&#123; /** * 回调方法，当收到消息后会自动执行 * @param consumerTag 标识 * @param envelope 获取一些信息 * @param properties 配置信息 * @param body 真实数据 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"consumerTag\"+consumerTag); System.out.println(\"Exchange\"+envelope.getExchange()); System.out.println(\"RoutingKey\"+envelope.getRoutingKey()); System.out.println(\"properties\"+properties); System.out.println(\"body\"+new String(body)); &#125; &#125;; channel.basicConsume(\"hello\",true,defaultConsumer); &#125;&#125; work queue工作队列模式work queus 与简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个对列的消息 应用场景： 任务过重或者任务过多情况下使用工作队列提高任务处理速度 C1 C2都是消费者 一个队列对应多个消费者，消费者之间对于同一消息是竞争关系 两个消费者对于任务过重或者任务过多情况下使用工作队列提高任务处理速度 P 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class work_queues &#123; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connectionPub=factory.newConnection(); //4.获取channel Channel channel=connectionPub.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"work_queues\",true,false,false,null); //6.发送消息 /* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数: exchange:交换机,简单模式默认为”“ routingKey:路由名称,workqueue模式默认和队列名字一致 props:配置信息 body:发送消息的内容 */ //发送多条消息 for (int i = 1; i &lt;= 10; i++) &#123; String body=\"hello rabbitMQ\"+i; channel.basicPublish(\"\",\"work_queues\",null,body.getBytes()); &#125; //7.释放资源 channel.close(); connectionPub.close(); &#125;&#125; C1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class work_queues1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connection=factory.newConnection(); //4.获取channel Channel channel=connection.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"work_queues\",true,false,false,null); //6 接收消息 /* (String queue, boolean autoAck, Consumer callback) */ DefaultConsumer defaultConsumer=new DefaultConsumer(channel)&#123; /** * 回调方法，当收到消息后会自动执行 * @param consumerTag 标识 * @param envelope 获取一些信息 * @param properties 配置信息 * @param body 真实数据 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body\"+new String(body)); &#125; &#125;; channel.basicConsume(\"work_queues\",true,defaultConsumer); &#125;&#125; C2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class work_queues2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.工厂模式创建连接 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setHost(\"192.168.43.179\");//设置ip，默认localhost factory.setPort(5672);//设置端口号，默认5672 factory.setUsername(\"admin\");//设置用户名 factory.setPassword(\"admin\");//设置密码 factory.setVirtualHost(\"virtual\"); //3.获取Connection Connection connection=factory.newConnection(); //4.获取channel Channel channel=connection.createChannel(); //5.声明队列 /* (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数: queue:队列名,如果不存在就会创建指定的队列名 durable:是否持久化，默认是false,当mq重启以后还在 exclusive: 是否独占，只能有一个消费者监听这个队列 当Connection关闭时，是否删除队列 autoDelete:是否自动删除,当没有consumer的时候，自动删除 arguments：参数 */ channel.queueDeclare(\"work_queues\",true,false,false,null); //6 接收消息 /* (String queue, boolean autoAck, Consumer callback) */ DefaultConsumer defaultConsumer=new DefaultConsumer(channel)&#123; /** * 回调方法，当收到消息后会自动执行 * @param consumerTag 标识 * @param envelope 获取一些信息 * @param properties 配置信息 * @param body 真实数据 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body\"+new String(body)); &#125; &#125;; channel.basicConsume(\"work_queues\",true,defaultConsumer); &#125;&#125; Pub/Sub订阅模式 在订阅模式中，多了一个Exchange角色,多个消费者接收不同队列的信息 Exchange类型： fanout广播 Direct:定向 Topic通配符 生产者 12345678910111213141516171819202122232425262728293031323334353637383940public class pubsubMode &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.channel声明交换机 String exchangeName=\"firstExchange\"; /** * (String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments) */ channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,true,false,false,null); //6.channel声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(\"queue3\",true,false,false,null); channel.queueDeclare(\"queue4\",true,false,false,null); //7.交换机绑定队列 channel.queueBind(\"queue3\",exchangeName,\"\",null); channel.queueBind(\"queue4\",exchangeName,\"\",null); //8.发送消息 String hello=\"hello,RabbitMQ1111\"; channel.basicPublish(exchangeName,\"\",null,hello.getBytes()); //9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 1234567891011121314151617181920212223242526272829303132333435363738public class pubsubModeCousumer1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setVirtualHost(\"virtual\"); factory.setPort(5672); //3.创建连接 Connection connection = factory.newConnection(); //4.创建channel Channel channel = connection.createChannel(); String exchangeName=\"firstExchange\"; channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,true,false,false,null); //5.声明队列 String queue3=\"queue3\"; /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(queue3,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; channel.basicConsume(queue3,true,defaultConsumer); &#125;&#125; 消费者2 1234567891011121314151617181920212223242526272829303132333435public class pubhubModeConsumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setVirtualHost(\"virtual\"); factory.setPort(5672); //3.创建连接 Connection connection = factory.newConnection(); //4.创建channel Channel channel = connection.createChannel(); //5.声明队列 String queue4=\"queue4\"; /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(queue4,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; super.handleDelivery(consumerTag, envelope, properties, body); System.out.println(\"body \"+new String(body)); &#125; &#125;; channel.basicConsume(queue4,true,defaultConsumer);&#125;&#125; Routing路由模式 队列和交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey(路由key) 消息的发送发在向Exchange发送消息的时候也要指定消息的RoutingKey Exchange不再把消息交给每一个绑定的队列，而是根据消息的RoutingKey进行判断，只有队列的routingKey和消息的RoutingKey保持一致才会接收到消息 生产者 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RoutingModelPublisher &#123; private static final String EXCHANGE_NAME = \"direct_logs\"; private static final String QUEUE_NAME1 = \"RoutingQueue1\"; private static final String QUEUE_NAME2 = \"RoutingQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.channel声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT,true,false,false,null); //6.channel声明队列 channel.queueDeclare(QUEUE_NAME1,true,false,false,null); channel.queueDeclare(QUEUE_NAME2,true,false,false,null); //7.交换机绑定队列 channel.queueBind(QUEUE_NAME1,EXCHANGE_NAME,\"RoutingKey1\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"RoutingKey2\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"RoutingKey3\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"RoutingKey4\"); //8.发送消息 String data1=\"RoutingKey1从队列1来\"; String data2=\"RoutingKey2从队列2来\"; String data3=\"RoutingKey3从队列2来\"; String data4=\"RoutingKey4从队列2来\"; String data5=\"RoutingKey5从队列2来\"; channel.basicPublish(EXCHANGE_NAME,\"RoutingKey1\",null,data1.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data2.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data3.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data4.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"RoutingKey2\",null,data5.getBytes()); //9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 1234567891011121314151617181920212223242526272829303132333435363738public class RoutingModelConsumer1 &#123; private static final String QUEUE_NAME1 = \"RoutingQueue1\"; private static final String QUEUE_NAME2 = \"RoutingQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(QUEUE_NAME1,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; /** * (String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) */ channel.basicConsume(QUEUE_NAME1,defaultConsumer); &#125;&#125; 消费者2 1234567891011121314151617181920212223242526272829303132333435public class pubhubModeConsumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setVirtualHost(\"virtual\"); factory.setPort(5672); //3.创建连接 Connection connection = factory.newConnection(); //4.创建channel Channel channel = connection.createChannel(); //5.声明队列 String queue4=\"queue4\"; /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(queue4,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; super.handleDelivery(consumerTag, envelope, properties, body); System.out.println(\"body \"+new String(body)); &#125; &#125;; channel.basicConsume(queue4,true,defaultConsumer);&#125;&#125; Topics通配符模式生产者 12345678910111213141516171819202122232425262728293031323334353637383940public class TopicModelPublisher &#123; private static final String EXCHANGE_NAME = \"Topic_logs\"; private static final String QUEUE_NAME1 = \"TopicQueue1\"; private static final String QUEUE_NAME2 = \"TopicQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.channel声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC,true,false,false,null); //6.channel声明队列 channel.queueDeclare(QUEUE_NAME1,true,false,false,null); channel.queueDeclare(QUEUE_NAME2,true,false,false,null); //7.交换机绑定队列 channel.queueBind(QUEUE_NAME1,EXCHANGE_NAME,\"#.error\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"*.order\"); channel.queueBind(QUEUE_NAME2,EXCHANGE_NAME,\"*.*\"); //8.发送消息 String data1=\"my.error\"; String data2=\"123456.order\"; String data3=\"topic\"; channel.basicPublish(EXCHANGE_NAME,\"#.error\",null,data1.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"*.order\",null,data2.getBytes()); channel.basicPublish(EXCHANGE_NAME,\"*.*\",null,data3.getBytes()); //9.释放资源 channel.close(); connection.close(); &#125;&#125; 消费者1 12345678910111213141516171819202122232425262728293031323334353637public class TopicModelConsumer1 &#123; private static final String QUEUE_NAME1 = \"TopicQueue1\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(QUEUE_NAME1,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; /** * (String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) */ channel.basicConsume(QUEUE_NAME1,defaultConsumer); &#125;&#125; 消费者2 12345678910111213141516171819202122232425262728293031323334353637public class TopicModelConsumer2 &#123; private static final String QUEUE_NAME2 = \"TopicQueue2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.获取创建connection的的工厂对象 ConnectionFactory factory=new ConnectionFactory(); //2.设置工厂参数 factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setHost(\"192.168.43.179\"); factory.setPort(5672); factory.setVirtualHost(\"virtual\"); //3.创建Connection Connection connection=factory.newConnection(); //4.创建channel Channel channel=connection.createChannel(); //5.声明队列 /** * (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) */ channel.queueDeclare(QUEUE_NAME2,true,false,false,null); //6.接收消息 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"body \"+new String(body)); &#125; &#125;; /** * (String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) */ channel.basicConsume(QUEUE_NAME2,defaultConsumer); &#125;&#125; 消息的可靠性传递confirm模式 return回退模式 Consumer ACKack(Acknowledge) 确认，表示消费端收到消息后的确认方式。 三种方式： 自动确认 acknowledge=”none” 手动确认 acknowledge=”manual” 根据异常确认 acknowledge=”auto” 配置文件 12345678910111213spring: rabbitmq: username: admin password: admin virtual-host: virtual host: 192.168.43.179 port: 5672 #开启消费者手动确认 listener: direct: acknowledge-mode: manual simple: acknowledge-mode: manual 消费者代码 1234567891011121314151617181920212223242526272829303132333435@Componentpublic class Consumer &#123; @RabbitListener(queues = \"TopicQueue\") public void getMessage(Message message, Channel channel) &#123; try &#123; //1.接收转换消息 System.out.println(new String(message.getBody())); //2.处理业务逻辑 System.out.println(\"处理业务\"); //int i=3/0; //3.签收消息 /** * (long deliveryTag, boolean multiple) * deliveryTag: 标签 * multiple: true签收所有消息 */ //3.1 手动签收消息 channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); System.out.println(\"手动签收成功\"); &#125; catch (Exception e) &#123; //3.2 如果签收失败 /** * (long deliveryTag, boolean multiple, boolean requeue) * requeue:设置为true，消息会重回队列，broker会重新发送给消费者这条消息 */ try &#123; System.out.println(\"手动签收失败，正在回退到队列\"); channel.basicNack(message.getMessageProperties().getDeliveryTag(),true,true); &#125; catch (IOException ioException) &#123; System.out.println(\"消息回退失败\"); &#125; &#125; &#125;&#125; 消息可靠性总结 持久化 exchange持久化 queue持久化 message持久化 生产方确认Confirm 消费方确认ACK Broker高可用 消费端限流 consumer ack为手动确认 配置属性prefetch 1234567891011121314spring: rabbitmq: username: admin password: admin virtual-host: virtual host: 192.168.43.179 port: 5672 listener: direct: acknowledge-mode: manual prefetch: 1 simple: acknowledge-mode: manual prefetch: 1 12345678910@Componentpublic class Consumer &#123; @RabbitListener(queues = \"TopicQueue\") public void getMessage(Message message, Channel channel) throws IOException, InterruptedException &#123; //Thread.sleep(1000); System.out.println(new String(message.getBody())); //channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); &#125;&#125; TTL存活时间，过期时间 当消息到达存活时间，还没有被消费，会被自动清除 RabbitMQ可以对消息设置过期时间，也可以对整个队列设置过期时间 队列消息过期 1234@Bean(\"queue\") public Queue getQueue()&#123; return QueueBuilder.durable(QueueName).ttl(100000).build(); &#125; 消息过期 123456789rabbitTemplate.convertAndSend(Producer.ExchangeName, \"boot.aaaa\", meaaage, new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; //设置消息过期时间 message.getMessageProperties().setExpiration(\"5000\"); return message; &#125; &#125;); 队列消息过期后，会将队列里所有的消息移除 消息过期后，会将在队列顶端的消息进行判断是否过期，过期的话移除 两者同时设置，按照时间最短的 死信队列DLX dead Letter Exchange(死信交换机)，当消息成为dead message后，可以被重新发往另一个交换机，这个交换机就是DLX. 消息成为死信的三种情况 队列消息长度到达限制 消费者拒收消息，basicNack不在把消息重新放入目标队列，requeue=FALSE 原队列存在消息过期设置，消费到达超时时间未被消费。 创建死信交换机和队列 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class Producer &#123; public static final String ExchangeName=\"topicExchange\"; public static final String DlxExchangeName=\"DlxTopicExchange\"; public static final String QueueName=\"TopicQueue\"; public static final String DlxQueueName=\"DlxTopicQueue\"; @Bean(\"dlxExchange\") public Exchange getDlxExchange()&#123; return ExchangeBuilder.topicExchange(DlxExchangeName).durable(true).build(); &#125; @Bean(\"dlxQueue\") public Queue getDlxQueue()&#123; return QueueBuilder.durable(DlxQueueName).build(); &#125; @Bean public Binding getDlxBinding(@Qualifier(\"dlxQueue\")Queue dlxQueue,@Qualifier(\"dlxExchange\")Exchange dlxExchange)&#123; return BindingBuilder.bind(dlxQueue).to(dlxExchange).with(\"#.dlx\").noargs(); &#125; @Bean(\"exchange\") public Exchange getExchange()&#123; return ExchangeBuilder.topicExchange(ExchangeName).durable(true).build(); &#125; @Bean(\"queue\") public Queue getQueue()&#123; return QueueBuilder.durable(QueueName).deadLetterExchange(DlxExchangeName).deadLetterRoutingKey(\"haha.dlx\").ttl(10000).maxLength(10).build(); &#125; @Bean public Binding getBinding(@Qualifier(\"queue\")Queue queue,@Qualifier(\"exchange\")Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(\"boot.#\").noargs(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class DlxTest &#123; @Autowired RabbitTemplate rabbitTemplate; /** * 发送死信消息 * 1.过期时间 * 2.长度限制 * 3.消息拒收 */ //测试过期时间 @Test public void test()&#123; String letter=\"我是消息\"; rabbitTemplate.convertAndSend(Producer.ExchangeName,\"boot.haha\",letter); &#125; //测试长度限制 @Test public void lengthTest()&#123; String letter=\"我是消息\"; for (int i = 0; i &lt; 20; i++) &#123; rabbitTemplate.convertAndSend(Producer.ExchangeName,\"boot.haha\",letter+i); &#125; &#125; //测试消息拒收 @Test public void rejectTest()&#123; String letter=\"拒收消息\"; rabbitTemplate.convertAndSend(Producer.ExchangeName,\"boot.haha\",letter); &#125;&#125; 123456789101112131415161718//测试消息拒收的消费者@Componentpublic class RejectConsumer &#123; @RabbitListener(queues = \"TopicQueue\") public void getMessage(Message message, Channel channel) &#123; try &#123; System.out.println(\"执行业务\"); int i=3/0; channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); &#125;catch (Exception e)&#123; try &#123; System.out.println(\"拒收消息\"); channel.basicNack(message.getMessageProperties().getDeliveryTag(),true,false); &#125; catch (IOException ioException) &#123; System.out.println(\"回退失败\"); &#125; &#125; &#125;&#125; 死信交换机和死信队列和普通的没有区别 当消息称为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列 消息称为死信的三种情况 消息长度限制 消息达到过期时间 消费者拒收消息 延迟队列延迟队列：消息进入队列后不会被立即消费，只有达到指定时间才会被消费。 TTL+死信队列实现延迟队列 日记与监控默认日志存放：/var/log/rabbitmq/ 消息追踪rabbitmqctl trace_on rabbitmq-plugins enable rabbitmq_tracing 应用问题消息可靠性保障 消息幂等性保障 集群搭建","pubDate":"Thu, 14 Jan 2021 10:47:43 GMT","guid":"https://augus-liuzhi.github.io/2021/01/14/RabbitMQ/","category":""},{"title":"Thymeleaf","link":"https://augus-liuzhi.github.io/2021/01/13/Thymeleaf/","description":"","pubDate":"Wed, 13 Jan 2021 08:13:58 GMT","guid":"https://augus-liuzhi.github.io/2021/01/13/Thymeleaf/","category":""},{"title":"单链表","link":"https://augus-liuzhi.github.io/2021/01/12/单链表/","description":"链表的结构数据域+指针域 头指针指向链表的第一个节点的位置。 头节点链表第一个节点前额外设置的一个节点，数据域不存放数据，指针域指向第一个节点的指针（存储位置），引入头节点使得开始节点可以和其他的元素一样，方便进行删除和插入操作。 单链表的基本操作增 add删 delete改 update查 find插 insert 创建节点123456789101112131415/** * 创建一个节点类 * @param &lt;String&gt; */public class Node&lt;String&gt; &#123; //数据域 public String data; //指针域 public Node&lt;String&gt; next; //有参构造函数 public Node(String data, Node&lt;String&gt; next) &#123; this.data = data; this.next = next; &#125;&#125; 初始化链表123456789101112131415161718public class SingleLinkedList &#123; //头节点 private Node head; //首元节点，链表中真正第一个元素 private Node first; //链表长度 int listSize; //初始化链表 public boolean initList()&#123; //链表长度为0 listSize=0; //头指针指向首元节点 first=new Node(null,null); head=new Node(null,first); return true; &#125;&#125; 其他操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//判断单链表是否为空 public boolean isEmpty()&#123; if(listSize==0)&#123; return true; &#125; return false; &#125; //获取节点 public Node&lt;String&gt; getNode(int i)&#123; if(i&lt;0||i&gt;=listSize)&#123; throw new IllegalArgumentException(\"非法参数\"); &#125; Node&lt;String&gt; currNode=head; for(int j=0;j&lt;i;j++)&#123; currNode= currNode.next; &#125; return currNode; &#125; //在末尾添加元素 public void add(Node&lt;String&gt; node)&#123; getNode(listSize-1).next=node; listSize++; &#125; //删除i位置的节点，并返回删除的数据。 public String remove(int i)&#123; if(i==listSize-1)&#123; String s=getNode(i).data; getNode(i-2).next=null; return s; &#125; Node&lt;String&gt; node=getNode(i-1); String s=node.next.data; node.next=node.next.next; return s; &#125; //在i位置插入新节点 public void insert(int i,String a)&#123; Node&lt;String&gt; preNode=getNode(i-1); Node&lt;String&gt; newNode=new Node&lt;&gt;(a,null); newNode.next=preNode.next; preNode.next=newNode; listSize++; &#125; //获取i位置的数据 public String getData(int i)&#123; return getNode(i).data; &#125; //为i位置元素重新赋值 public void setData(int i,String newData)&#123; getNode(i).data=newData; &#125; //返回链表节点的个数 public int length()&#123; return listSize; &#125; //清空链表 public void clear()&#123; initList(); &#125; //打印链表 public void print()&#123; for (int i=0;i&lt;listSize;i++)&#123; System.out.println(getNode(i).data); &#125; &#125; //查找链表中是否有元素e public boolean contains(String s)&#123; Node currNode=head.next; while (currNode.next!=null)&#123; if(currNode.data.equals(s))&#123; return true; &#125; currNode=currNode.next; &#125; return false; &#125;","pubDate":"Tue, 12 Jan 2021 06:26:48 GMT","guid":"https://augus-liuzhi.github.io/2021/01/12/单链表/","category":""},{"title":"SpringBoot-Web开发","link":"https://augus-liuzhi.github.io/2021/01/01/SpringBoot-Web开发/","description":"SpringBoot-Web开发1 简单功能分析1.1 静态资源目录springBoot默认将类路径下的/static (or /public or /resources or /META-INF/resources)作为静态资源目录，静态资源只要放在以上目录，访问路径为localhost:8080/+静态资源名，就可以直接访问静态资源。 当静态资源名和controller包的映射名一致时，优先进行controller进行处理，当请求进来时，先去找controller看看能不能处理，如果controller处理不了，再交给静态资源处理，这是因为静态资源它的映射也是/**，一般默认使用static作为存放静态资源的路径。可以通过访问前缀进行区分 1.2 静态资源访问前缀springboot默认访问静态资源是没有前缀的，访问路径直接localhost:8080/+静态资源名 设置访问前缀 1234#配置访问前缀spring: mvc: static-path-pattern: /res/** 此时访问路径：localhost:8080/+前缀+静态资源名。 1.3 设置静态资源路径springboot默认是那4个静态资源路径，一旦自定义访问静态资源的路径，其他的将会失效。[meta-inf/resources还是生效why] 设置静态资源路径 1234spring: web: resources: static-locations: classpath:/haha 1.4 访问webjars访问webjars时，例如jquery,首先添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 访问路径为：localhost:8080/webjars/jquery/版本号/静态资源名 1.5 welcome欢迎页index.html存放在默认的静态目录下，或者我们指定的静态文件下，即可默认直达欢迎页面，当我们设置前缀的时候，必须加上前缀才可以访问欢迎页面。 1.6 favicon配置favicon.ico,只需要在静态资源路径放置favicon.ico图片，springboot会自动配置。 1.7 静态资源配置原理 2 请求参数处理表单rest风格rest风格是指以不同的请求方式，来区分用户的增删改查操作，表单提交默认只有post,get请求，通过修改隐藏域的_method参数，可以添加springboot2支持的put,delete,patch请求。 以前增删改查，/addUser,/DeleteUser,/UpdateUser,/SelectUser Rest风格，处理增删改查，url映射统一为/User,用不同的请求方法，进行区分增删改查操作 rest开发步骤 创建表单，修改隐藏域，添加put,delete请求方式 创建Controller,用SpringBoot新注解进行区分请求方式 springboot开启rest风格配置 12345678910111213141516171819&lt;h4&gt;REST风格测试&lt;/h4&gt;&lt;form action=\"/user\" method=\"get\"&gt; &lt;input type=\"submit\" value=\"get测试\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"post测试\"&gt;&lt;/form&gt;添加隐藏域的_method的值，表单必须为post请求才可以&lt;form action=\"/user\" method=\"post\"&gt; &lt;input name=\"_method\" type=\"hidden\" value=\"put\"&gt; &lt;input type=\"submit\" value=\"put测试\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\"&gt; &lt;input name=\"_method\" type=\"hidden\" value=\"delete\"&gt; &lt;input type=\"submit\" value=\"delete测试\"&gt;&lt;/form&gt; 1234567891011121314151617181920//使用不同请求方式的注解，进行区分增删改查@RestControllerpublic class HelloController &#123; @GetMapping(\"/user\") public String helloRest1()&#123; return \"get\"; &#125; @PostMapping(\"/user\") public String helloRest2()&#123; return \"request\"; &#125; @PutMapping(\"/user\") public String helloRest3()&#123; return \"put\"; &#125; @DeleteMapping(\"/user\") public String helloRest4()&#123; return \"delete\"; &#125;&#125; 123456#开启REST风格spring: mvc: hiddenmethod: filter: enabled: true 请求参数注解@PathVariable(“参数名”) 绑定url占位符参数到Controller localhost:8080/user/{占位符1}/{占位符2} 12345678@RestControllerpublic class ParameterController &#123; @GetMapping(\"/variable/&#123;username&#125;/&#123;password&#125;\") public String parameter(@PathVariable(\"username\")String username,@PathVariable(\"password\") String password)&#123; String variable=username+\"--\"+password; return variable; &#125;&#125; @RequestHeader 获取请求头中的数据，通过指定参数，来获取请求头中指定参数的值 1234567@GetMapping(\"/RequestHeader\") public Map ReqHeader(@RequestHeader(\"User-Agent\") String UserAgent,@RequestHeader(\"Accept-Language\") String language)&#123; Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"UserAgent\",UserAgent); map.put(\"Accept-Language\",language); return map; &#125; @RequestParam 获取请求的指定参数，通过制定参数的名称来获取请求参数的值 http://localhost:8080/RequestParam?id=3 123456@GetMapping(\"/RequestParam\") public Map ReqParam(@RequestParam(\"id\")Integer id)&#123; Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); map.put(\"id\",id); return map; &#125; @CookieValue 获取请求的Cookies的值，通过指定参数的值来获取cookies的值 123456@PostMapping(\"/cookies\") public Map getCookies(@CookieValue(value = \"JSESSIONID\",required = false,defaultValue = \"null\") String JSESSIONID)&#123; Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"JSESSIONID\",JSESSIONID); return map; &#125; @RequestBody 该注解可以用来接收从前端传入的json数据 @RequestAttribute 获取request域中指定参数的值 12345678910111213@PostMapping(\"/ReqAt\") public String Reqat(HttpServletRequest httpServletRequest)&#123; HttpServletRequest request=httpServletRequest; request.setAttribute(\"user\",\"root\"); return \"forward:/requestAttribute\"; &#125; @PostMapping(\"/requestAttribute\") @ResponseBody public Map getrequestAttribute(@RequestAttribute(\"user\")String user)&#123; Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"User\",user); return map; &#125; ​ @MatrixVariable","pubDate":"Fri, 01 Jan 2021 12:46:43 GMT","guid":"https://augus-liuzhi.github.io/2021/01/01/SpringBoot-Web开发/","category":""},{"title":"Lombok","link":"https://augus-liuzhi.github.io/2020/12/30/lombok/","description":"Lombok简介lombok通过注解消除POJO的冗余代码，如POJO的Setter,Getter,ToString等方法，使用对应的注解，可以在编译的时候生成相应的方法，减少代码量的书写。 Lombok的安装Maven安装123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.14&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 插件安装IDEA-File-Setting-Plugins 搜索lombok,安装后重启IDEA Lombok常用注解123456789101112131415161718构造方法注解@NoArgsConstructor@AllArgsConstructor@RequiredArgsConstructorToString注解@ToStringSetter/Getter注解@Getter@Setter整合注解@Value@DataSetter注解@Builder日志注解@Slf4jEquals和HashCode注解@EqualsAndHashCode Lombok注解的使用@Setter/@Getter 生成对应的setter和getter方法 12345678910111213141516171819202122232425262728使用注解@Getter@Setterpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Integer getPrice() &#123; return price; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125;&#125; @ToString 生成对应的ToString方法 12345678910111213141516171819使用注解@ToStringpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; @Override public String toString() &#123; return \"Car&#123;\" + \"brand='\" + brand + '\\'' + \", price=\" + price + '&#125;'; &#125;&#125; @NoArgsConstructor 生成无参构造方法 123456789101112131415使用注解@NoArgsConstructorpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; public Car() &#123; &#125;&#125; @AllArgsConstructor 生成全部参数的构造方法 1234567891011121314151617使用注解@AllArgsConstructorpublic class Car &#123; String brand; Integer price; &#125;相当于不使用注解public class Car &#123; String brand; Integer price; public Car(String brand, Integer price) &#123; this.brand = brand; this.price = price; &#125;&#125; @RequiredArgsConstructor 生成特定参数的构造方法，此处指生成被final修饰的属性的构造方法，如果没有final修饰的属性，生成的默认是无参构造方法 12345678910111213141516使用注解@RequiredArgsConstructorpublic class Car &#123; final String brand; Integer price; &#125;相当于不使用注解public class Car &#123; final String brand; Integer price; public Car(String brand) &#123; this.brand = brand; &#125;&#125; @Builder 仅生成属性的setter方法 1234567891011121314151617181920使用注解@Builderpublic class Car &#123; String brand; Integer price;&#125;相当于不使用注解public class Car &#123; String brand; Integer price; public void setBrand(String brand) &#123; this.brand = brand; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125;&#125; @Data 整合注解@Data=@Getter+@Setter+@ToString+@EqualsAndHashCode+@RequiredArgsConstructor 适用在pojo上 123456789101112131415161718使用注解@Datapublic class Car &#123; String brand; Integer price;&#125;@Getter@Setter@ToString@EqualsAndHashCode@RequiredArgsConstructorpublic class Car &#123; String brand; Integer price;&#125; @Value 整合注解@Value=@RequiredArgsConstructor+@Getter+@EqualsAndHashCode+@ToString 适合用于类的属性值不更改，只有可读操作 此@Value为lombok包下的，区分Spring包下的@Value注解 1234567891011121314151617使用注解@Valuepublic class Car &#123; String brand; Integer price;&#125;@RequiredArgsConstructor@Getter@EqualsAndHashCode@ToStringpublic class Car &#123; String brand; Integer price;&#125; @Slf4j 自动生成该类的log静态变量 1234567891011121314使用注解@Slf4jpublic class Car &#123; public static void main(String[] args) &#123; log.info(\"hello\"); &#125;&#125;相当于不使用注解public class Car &#123; private static Logger log= LoggerFactory.getLogger(Car.class); public static void main(String[] args) &#123; log.info(\"hello\"); &#125;&#125; @EqualsAndHashCode 生成对应的equals方法和hashCode方法 123456789101112131415161718192021222324252627282930使用注解@EqualsAndHashCodepublic class Car &#123; String brand; Integer price; &#125;相当于不使用注解public class Car &#123; String brand; Integer price; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Car car = (Car) o; if (brand != null ? !brand.equals(car.brand) : car.brand != null) return false; return price != null ? price.equals(car.price) : car.price == null; &#125; @Override public int hashCode() &#123; int result = brand != null ? brand.hashCode() : 0; result = 31 * result + (price != null ? price.hashCode() : 0); return result; &#125;&#125;","pubDate":"Wed, 30 Dec 2020 07:50:08 GMT","guid":"https://augus-liuzhi.github.io/2020/12/30/lombok/","category":""},{"title":"","link":"https://augus-liuzhi.github.io/2020/11/16/Mysql技术内幕/","description":"一 MySql体系结构和存储引擎1.1 定义数据库和实例数据库：物理操作系统文件或其他形式文件的类型的集合。 实例：Mysql数据库由后台线程以及一个共享内存区组成。（数据库实例操作数据库文件） 实例和数据库的对应关系是一一对应的，一个实例对应一个数据库，一个数据库对应一个实例。集群情况下，存在一个数据库被多个实例操作。 1.2 Mysql体系结构 连接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 缓冲组件 插件式存储引擎 物理文件 Mysql区别于其他数据库的特点：插件式的表存储引擎 存储引擎是基于表的，不是数据库 1.3 Mysql存储引擎 InnoDB存储引擎 提供了对数据库ACID的事务支持，并且提供了行级锁和外键约束。 它的目标：处理大数据容量的数据库系统。 Mysql的默认引擎 MyISAM存储引擎 不提供事务支持，也不支持行级锁和外键约束 NDB存储引擎 Memory存储引擎 所有数据都在内存中，数据的处理速度快，但是安全性不高。 Archive存储引擎 Federated存储引擎 Maria存储引擎 1.4 各存储引擎的比较 MyISAM Innodb 存储结构 每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB 存储空间 MyISAM可被压缩，存储空间较小 InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 可移植性、备份及恢复 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 文件格式 数据和索引是分别存储的，数据.MYD，索引.MYI 数据和索引是集中存储的，.ibd 记录存储顺序 按记录插入顺序保存 按主键大小有序插入 外键 不支持 支持 事务 不支持 支持 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） 表级锁定 行级锁定、表级锁定，锁定力度小并发能力高 SELECT MyISAM更优 INSERT、UPDATE、DELETE InnoDB更优 select count(*) myisam更快，因为myisam内部维护了一个计数器，可以直接调取。 索引的实现方式 B+树索引，myisam 是堆表 B+树索引，Innodb 是索引组织表 哈希索引 不支持 支持 全文索引 支持 不支持 1.5 连接Mysql 连接Mysql操作是一个连接进程和Mysql数据库实例进行通信。（本质：进程通信） 进程通信方式： TCP/IP套接字 如：客户端和服务器不在同一个服务器上，在windows下，可以使用 12&gt; mysql -h 服务器地址 -u 用户名 -p 密码&gt; 命名管道和共享内存 UNIX套接字 二 InnoDB存储引擎","pubDate":"Mon, 16 Nov 2020 11:15:45 GMT","guid":"https://augus-liuzhi.github.io/2020/11/16/Mysql技术内幕/","category":""},{"title":"LeetCode","link":"https://augus-liuzhi.github.io/2020/11/16/LeetCode/","description":"11.12922.按照奇偶排序数组 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 123456789101112131415161718class Solution &#123; public int[] sortArrayByParityII(int[] A) &#123; int[] B=new int[A.length]; int c=0; int d=1; for (int i=0;i&lt;A.length;i++)&#123; if(A[i]%2==0)&#123; B[c]=A[i]; c+=2; &#125; else &#123; B[d]=A[i]; d+=2; &#125; &#125; return B; &#125;&#125; 解题思路 新创建一个数组，作为排序后的数组返回。 遍历数组中的每个数据元素，判断是奇数还是偶数。 如果是奇数，将其赋值给新数组的下标为1，切下标值加2，依次进行。 如果是偶数，将其赋值给新数组的下标为0，且下标值加2，依次进行。 字符串中字符出现的频次 给定一个字符串，统计字符串中各个字符出现的次数，如String s=”abbcccdddd”,则a出现一次，b出现两次，c出现3次，d出现4次。 1234567891011121314public HashMap countChar(String s)&#123; HashMap&lt;Character,Integer&gt; hashMap=new HashMap&lt;Character,Integer&gt;(); for (int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); Integer count = hashMap.get(c); if(count==null)&#123; hashMap.put(c,1); &#125; else &#123; hashMap.put(c,count+1); &#125; &#125; return hashMap; &#125; 解题思路 把字符串变成字符数组。 出现的字符作为key,出现的次数为value，将其存入HashMap中。 count作为计数，也就是作为hashmap中的value,出现重复的key,直接count+1,覆盖上次的value 11.13遍历数组12345678910111213141516public class ArrayTraversal &#123; public static void main(String[] args) &#123; Integer[] items = &#123; 1, 2, 3 &#125;; //1.for循环 for (int i=0;i&lt;items.length;i++)&#123; System.out.print(items[i]); &#125; //2.foreach循环 for (int a:items) &#123; System.out.print(a); &#125; //3.lambda表达式 Arrays.asList(items).forEach(System.out::print); Arrays.asList(items).forEach(item-&gt;System.out.print(item)); &#125;&#125; 7 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 输入：123 输出：321 12345678910111213public int reverse(int x)&#123; int y=0; while (x!=0)&#123; if (y &gt; 214748364 || y &lt; -214748364)&#123; return 0; &#125; else&#123; y=y*10+x%10; x=x/10; &#125; &#125; return y; &#125; 解题思路 定义一个参数y,作为反转后的数字返回 X/10操作得到去除个位数的数字，X%10得到个位数 y&gt; 214748364 || y &lt; -214748364 指定参数为整形范围 11.16","pubDate":"Mon, 16 Nov 2020 11:15:33 GMT","guid":"https://augus-liuzhi.github.io/2020/11/16/LeetCode/","category":""},{"title":"并发编程","link":"https://augus-liuzhi.github.io/2020/10/28/并发编程/","description":"创建多线程方法1:继承Thread类12345678910111213141516171819202122232425262728293031public class ExtendThread extends Thread&#123; static Logger logger=Logger.getLogger(ExtendThread.class); @Override public void run() &#123; logger.info(\"running\"); &#125; public static void main(String[] args) &#123; ExtendThread thread=new ExtendThread(); thread.setName(\"线程T\"); thread.start(); logger.info(\"running\"); &#125;&#125;//使用匿名内部类public class Test &#123; public static void main(String[] args) &#123; final Logger logger=Logger.getLogger(Test.class); //创建线程 Thread thread=new Thread()&#123; @Override public void run() &#123; logger.info(\"111\"); &#125; &#125;; //设置线程名 thread.setName(\"线程T\"); //启动线程 thread.start(); logger.info(\"2222\"); &#125;&#125; 方法2:实现Runnable接口12345678910111213public class Run implements Runnable &#123; static Logger logger=Logger.getLogger(Run.class); public void run() &#123; logger.info(\"1111\"); &#125; public static void main(String[] args) &#123; Run run=new Run(); Thread thread=new Thread(run); thread.setName(\"线程T\"); thread.start(); logger.info(\"22222\"); &#125;&#125; 12使用lambda表达式 Runnable runnable1= () -&gt; logger.info(\"1111\"); 方法3:实现Callable接口1234567891011121314public class Call implements Callable&lt;String&gt;&#123; Logger logger=Logger.getLogger(Call.class); @Override public String call() throws Exception &#123; String s=\"123\"; logger.info(s); return s ; &#125; public static void main(String[] args) &#123; Call call=new Call(); FutureTask futureTask=new FutureTask(call); new Thread(futureTask).start(); &#125;&#125; 123456789101112#FutureTaskpublic FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125;#Callable@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 线程和进程线程的状态 12345678910111213141516171819public enum State &#123; //新建状态 NEW, //就绪状态 RUNNABLE, //阻塞状态 BLOCKED, //等待状态 WAITING, //超时等待状态 TIMED_WAITING, //终止状态 TERMINATED; &#125; 并发和并行sleep和wait的区别来源不同 wait来自于Object类 1public final native void wait(long timeout) throws InterruptedException; sleep来自于Thread类 1public static native void sleep(long millis) throws InterruptedException; 是否释放锁 sleep不会释放锁，直到时间到了，会自动恢复 wait会释放锁，进入等待队列，待调用notify/notifyAll唤醒指定的线程或者所有线程才会进入锁池，再次获得对象锁才会进入运行状态 使用范围 wait 只能在同步代码块或同步方法使用 sleep 可以在任何地方使用 yield和interruptyield 1public static native void yield(); yield是一个native方法，表示当前线程做出让步，放弃cpu的执行权，让CPU重新选择线程 interrupt 123public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125; interrupt 线程中断操作，意思是打断正在运行状态或者等待状态的线程 如果线程状态是waiting或者timed_waitting,这个时候打断这些线程就会抛出InterruptedException异常，直接让状态到terminated 线程池 ExecutorService是java提供的用于管理线程池的类，该类的作用：控制线程数量和重用线程 常用线程池1. newCachedThreadPool 可缓存线程池，先查看池中有没有以前建立的线程，如果有直接使用，如果没有，就创建一个新的线程加入池中，缓存型池用于执行一些生存期很短的异步型任务。 1ExecutorService executorService = Executors.newCachedThreadPool(); 2. newFixedThreadPool 创建可重复使用的固定个数的线程池 1ExecutorService executorService=Executors.newFixedThreadPool(int n); 3. newScheduledThreadPool 支持定时及周期性任务执行的定长线程池 1ExecutorService executorService = Executors.newScheduledThreadPool(int corePoolsize); 4. newSingleThreadExecutor 创建单线程化的线程池，保证所有的任务按照指定顺序执行 1ExecutorService executorService = Executors.newSingleThreadExecutor(); 提交任务 12executorService.submit(); ---&gt;返回一个Future对象,executorService.execute(); ---&gt; 锁的是谁12synchronized() 锁的是this，就是对象本身static synchronized() 锁的是类模板 按照顺序执行 集合类不安全12345678910111213141516171819/** * java.util.ConcurrentModificationException 并发修改异常 * 解决方案： * 1. List&lt;String&gt; list = new Vector&lt;&gt;(); * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); 写入时复制，底层用的lock锁 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 1234567891011121314151617/** * java.util.ConcurrentModificationException 并发修改异常 * 解决方案： * 1. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); * 2. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); */public class SetTest &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(()-&gt;&#123; set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; HashSet 123456789public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;//add方法public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125;private static final Object PRESENT = new Object();add方法调用map的put方法放入一个元素e也就是key，再放入present作为value,它是一个常量，Map有键和值，HashSet相当于只有键，值都是固定的present 123456789101112131415161718/** * java.util.ConcurrentModificationException 并发修改异常 * 解决方案： * 1. Map&lt;String,String&gt; map=new ConcurrentHashMap&lt;&gt;(); */public class MapTest &#123; public static void main(String[] args) &#123; //默认Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;(16, (float) 0.75); //加载因子，初始化容量 Map&lt;String,String&gt; map=new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(()-&gt;&#123; map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0,5)); System.out.println(map); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; Callable 可以有返回值 可以抛出异常 方法不同call() 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 1234567891011121314151617public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //new Thread(new Runnable()).start(); //new Thread(new FutureTask&lt;V&gt;()).start(); //new Thread(new FutureTask&lt;V&gt;(Callable)).start(); MyThread myThread=new MyThread(); FutureTask futureTask=new FutureTask(myThread); new Thread(futureTask).start(); System.out.println(futureTask.get());//可能会产生阻塞 &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; return 1024; &#125;&#125; 常用的辅助类CountDownLatch减法计数器 1234567891011121314public class CountDownDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); countDownLatch.countDown();//-1 for (int i = 0; i &lt; 6; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"go OUT\"); countDownLatch.countDown(); &#125;).start(); &#125; countDownLatch.await();//等待计数器归0，在往下执行 System.out.println(\"close door\"); &#125;&#125; CyclicBarrier加法计数器 1234567891011121314151617181920public class CyclicBarrierDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-&gt;&#123; System.out.println(\"success\"); &#125;); for (int i = 0; i &lt; 7; i++) &#123; final int temp=i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"go OUT\"+temp); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125;","pubDate":"Wed, 28 Oct 2020 07:29:51 GMT","guid":"https://augus-liuzhi.github.io/2020/10/28/并发编程/","category":""},{"title":"","link":"https://augus-liuzhi.github.io/2020/10/23/MySql/","description":"数据库相关概念 DB: 数据库，保存一组有组织的数据的容器 DBMS : 数据库管理系统，就是数据库管理软件，用来管理DB中的数据 SQL : 结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点 将数据放在表中，再将表放到数据库中 一个数据库可以有多个数据表，表名具有唯一性 表有一些特性 表每列称为一个字段，表中数据按行存储。 Mysql产品的介绍和安装Mysql服务的启动和停止1234567方式1：计算机--&gt;右键管理--&gt;服务和应用程序--&gt;服务--&gt;mysql方式2：管理员身份cmd命令net stop mysqlnet start mysql MySql的登陆和退出1234567win--&gt;cmd登陆mysql -h 主机名 -P 端口号 -u 用户名 -p 密码退出：exit或者ctrl+c Mysql常见命令1234567891011121314151617显示数据库：show databases;进入test数据库：use test;查看数据表：show tables;创建数据表：create table 表名（列名 列类型，列名 列类型，……）;查看当前所在数据库：select database();查看某个数据库中的数据表：show tables from mysql;查看数据表的结构：desc students;查看表的内容 ： select * from 表名；查看当前数据库版本：select version(); Mysql语法规范12345671. 不区分大小写，建议关键字大写，表名、列名小写2. 每条命令用分号结尾3. 每条命令根据需要，可以进行缩进换行4. 注释 单行注释：#注释文字 单行舒适：-- 注释文字 多行注释：/* 注释文字 */ Mysql查询基础查询1234567891011121314151617181920212223242526272829303132333435363738394041#进阶1：基础查询/*语法：select 查询列表 from 表名;查询列表可以是：表中字段、常量值、表达式、函数查询结果是一个虚拟表格*/#打开库USE student;#1. 查询表中的单个字段SELECT NAME FROM student;#2. 查询表中的多个字段SELECT NAME,age,xuehao FROM student;#3. 查询表中所有字段SELECT * FROM student;#4. 查询常量SELECT 1;SELECT &apos;hdsdhsadihis&apos;;#5. 查询表达式SELECT 100*98;#6. 查询函数SELECT VERSION();#7. 起别名/*便于理解区分重名字段*/# 方式1SELECT 100*98 AS 结果;SELECT NAME AS 姓名 FROM student;# 方式2 SELECT NAME 姓名2 FROM student;#8. 去重SELECT DISTINCT chengji FROM student;#9. +号的作用,运算符/*1. 一方为null，结果为null2. 两边都是数值，做加法运算3. 一方数值，一方字符，将字符转换成数值再加，如果转换失败，则就是0+数值*/SELECT CONCAT(NAME,IFNULL(chengji,0)) AS 姓名和成绩 FROM student; 进阶查询123456789101112131415161718192021222324252627282930313233343536373839404142#进阶2：条件查询/*语法： select 查询列表 from 表名 where 筛选条件;分类： 1. 条件表达式筛选 条件运算符：＞ ＜ ＝ ！＝ ＜＞ ＞＝ ＜＝ 2. 逻辑表达式筛选 逻辑运算符：＆＆ ｜｜ ！ and or not 3. 模糊查询 between and like in is null*/#1. 按照条件表达式筛选#查找成绩大于80fen的SELECT * FROM student WHERE chengji&gt;80;#查找年龄不等于20岁的姓名和年龄SELECT NAME,age FROM student WHERE age!=20;SELECT NAME,age FROM student WHERE age&lt;&gt;20;#2. 按照逻辑表达式筛选#查找成绩成绩在60-90之间的姓名和成绩SELECT NAME,chengji FROM student WHERE chengji&gt;60 AND chengji&lt;90;#3. 模糊查询#1. like 一般和通配符搭配使用 %任意多个字符 _任意单个字符#查找姓名中包含字符a的学生信息SELECT * FROM student WHERE NAME LIKE &apos;a%&apos;;#查询第一个字符为w，第3个字符为nSELECT * FROM student WHERE NAME LIKE &apos;w_n_&apos;;#查询姓名中第二个字符为下划线SELECT * FROM student WHERE NAME LIKE &apos;_\\_%&apos;;#\\转译SELECT * FROM student WHERE NAME LIKE &apos;_$_%&apos; ESCAPE &apos;$&apos;;#escape 转译#2. between and#查找成绩在60到90之间,包含60 90，闭区间，不能颠倒顺序SELECT * FROM student WHERE chengji BETWEEN 60 AND 90;#3. in 通俗来讲可以理解为=SELECT * FROM student WHERE chengji IN(60,80,90);#4. is null 查找null值 is not nullSELECT * FROM student WHERE chengji IS NOT NULL;#安全等于 &lt;=&gt; 可以判断null,也可以判断普通数值SELECT * FROM student WHERE chengji&lt;=&gt;NULL;SELECT * FROM student WHERE chengji&lt;=&gt;100; 排序查询12345678910111213141516171819#进阶3：排序查询/*select 列表 from 表名 【where 筛选条件】order by 排序列表1 【asc|desc】,排序列表2【asc|desc】,如果不写默认是升序排序列表可以是单个字段，多个字段，表达式，函数，别名order by 放在查询语句最后面，limit除外！！！*/#1. 按照某一项排序SELECT * FROM student ORDER BY chengji ASC;SELECT * FROM student ORDER BY chengji DESC;#2. 按照筛选条件排序SELECT * FROM student WHERE chengji&gt;60 ORDER BY xuehao;#3. 按照表达式或者别名排序SELECT *,IFNULL(chengji,0)*12 AS 总成绩 FROM student ORDER BY IFNULL(chengji,0)*12 DESC;SELECT *,IFNULL(chengji,0)*12 AS 总成绩 FROM student ORDER BY 总成绩 ASC;#4. 按照姓名的长度显示姓名和成绩SELECT LENGTH(NAME) AS 姓名长度,NAME,chengji FROM student ORDER BY LENGTH(NAME) DESC;#5. 先按照成绩排序，再按照学号排序SELECT * FROM student ORDER BY chengji DESC,xuehao DESC; 常见函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#进阶4：常见函数/*概念：类似java方法，将一组逻辑语句封装在方法体中，对外暴露方法名好处：1. 隐藏了实现细节 2. 提高代码复用性调用：select 函数（实参列表） 【from 表】;特点：函数名,函数功能,分类：1. 单行函数 concat length ifnull 2. 分组函数 做统计使用又称为统计函数【聚合函数】*/#1.字符函数 #length 获取参数值的字符个数SELECT LENGTH(&apos;john&apos;);SELECT LENGTH(&apos;哈哈&apos;);#concat 拼接字符SELECT CONCAT(NAME,chengji) FROM student;#upper(),lower()大小写SELECT UPPER(&apos;sjdj&apos;);SELECT LOWER(&apos;ASD&apos;);#substr、substring#截取指定索引处后面所有字符SELECT SUBSTR(&apos;abcd&apos;,2);#截取从指定索引处指定字符长度的字符SELECT SUBSTR(&apos;abcdefg&apos;,1,3);#姓名中首字母大写，其余字母小写SELECT CONCAT(UPPER(SUBSTR(NAME,1,1)),&apos;_&apos;,LOWER(SUBSTR(NAME,2))) FROM student;#instr 返回子串第一次出现的索引，找不到返回值0SELECT INSTR(&quot;abcdefg&quot;,&apos;efg&apos;);#trim 去前后空格SELECT TRIM(&apos; ggjj &apos;);SELECT TRIM(&apos;a&apos; FROM &apos;aaaaa369aaaaa&apos;);#lpad 左填充指定长度字符 rpad 右填充指定长度SELECT LPAD(&apos;abcdefg&apos;,2,&apos;*&apos;);SELECT RPAD(&apos;asdc&apos;,5,&apos;*&apos;);#replace 替换所有指定字符SELECT REPLACE(&apos;abcdefg&apos;,&apos;g&apos;,&apos;G&apos;);#2. 数学函数#roundSELECT ROUND(1.65);SELECT ROUND(1.657,2);#ceil 向上取整 返回大于等于参数的最小整数#floor 向下取整 返回小于等于参数的最大整数SELECT CEIL(1.00);SELECT FLOOR(2.3);#truncate 截断SELECT TRUNCATE(1.66666,1);#mod 取余SELECT MOD(10,3);SELECT 10%3;#日期函数#now 返回当前系统时间SELECT NOW();#curdate 返回当前系统日期，不反回时间SELECT CURDATE();#cuetime 返回当前时间，不返回日期SELECT CURTIME();#获取指定部分的年，月，日，小时，分钟，秒SELECT YEAR(NOW());SELECT YEAR(NOW() AS 年 ;SELECT MONTH(NOW()) AS 数字月;SELECT MONTHNAME(NOW()) AS 英文月;#str_to_date 将字符转换成指定格式SELECT STR_TO_DATE(&apos;2022-2-17&apos;,&apos;%Y-%m-%d&apos;);#date_format 将日期转换成字符SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;);#4. 其他函数SELECT VERSION();SELECT DATABASE();SELECT USER();#5. 流程控制函数#if函数SELECT IF(10&gt;5,&apos;大&apos;,&apos;小&apos;);#case函数/*用法：case 要判断字段或表达式when常量1 then 语句1； when常量2 then 语句2；else 要显示的值n,或语句；end */#case使用1SELECT IFNULL(chengji ,0) AS 成绩,CASE FLOOR(chengji/10)WHEN 10 THEN &apos;A&apos;WHEN 9 THEN &apos;A&apos;WHEN 8 THEN &apos;B&apos;WHEN 7 THEN &apos;C&apos;ELSE &apos;D&apos;END AS 评定FROM student ORDER BY chengji DESC;#case使用2SELECT IFNULL(chengji,0) AS 成绩,CASEWHEN chengji&gt;90 THEN &apos;A&apos;WHEN chengji&gt;80 THEN &apos;B&apos;ELSE &apos;C&apos;ENDAS 评定FROM student ORDER BY chengji DESC; 分组函数12345678910111213141516171819#分组函数/*功能：用作统计使用，又称为聚合函数或统计函数或分组函数分类：sum 和 avg平均值 参数类型整型 ，忽略null值max min count计算个数 参数任何类型支持，忽略null值可以和distinct搭配，实现去重运算count 函数 计算非null值的个数和分组函数一同查询字段有限制,要求是group by后的字段*/SELECT SUM(chengji) FROM student;SELECT AVG(chengji) FROM student;SELECT MAX(chengji) FROM student;SELECT COUNT(chengji) FROM student;SELECT SUM(chengji) 和,COUNT(chengji) 一共,AVG(chengji)平均值 FROM student;SELECT SUM(DISTINCT chengji),SUM(chengji) FROM student;SELECT COUNT(*) FROM student;SELECT COUNT(chengji) FROM student;SELECT AVG(chengji),chengji FROM student;","pubDate":"Fri, 23 Oct 2020 01:14:12 GMT","guid":"https://augus-liuzhi.github.io/2020/10/23/MySql/","category":""}]}