{"title":"LiuZhi'Blog","description":"my blog","language":"en","link":"https://augus-liuzhi.github.io","pubDate":"Mon, 18 Nov 2019 03:32:46 GMT","lastBuildDate":"Mon, 18 Nov 2019 03:36:12 GMT","generator":"hexo-generator-json-feed","webMaster":"LiuZhi","items":[{"title":"字符串","link":"https://augus-liuzhi.github.io/2019/11/18/字符串/","description":"String类 声明字符串 java中有一对” “号包围的都是字符串 声明字符串语法：String s 注意：声明字符串必须经过初始化才能使用 创建字符串 方法一 String (char a[]) 1234char a[]=&#123;'a','b','c'&#125;;String s=new String(a);等价于String s=new String(\"abc\"); 方法二String(char a[],int offset,int length) 1234char a[]=&#123;'s','t','u','d','e','n','t'&#125;;String s=new String(a,2,4);等价于String s=new String(\"uden\") 方法三 1234String str1,str2;str1=\"we are student\";str2=\"we are student\";str1与str2引用相同的的字符串常量，具有相同的实体。 连接多个字符串 使用+运算符可以将多个字符串连接在一起 123456public static void main(String[] args) &#123; String str1=\"hello\"; String str2=\"world\"; String s=str1+\" \"+str2; System.out.println(s); &#125; 连接其他数据类型 字符串也可以和其他数据类连接，会自动将其他的数据类型转换成字符串 1234567public static void main(String[] args) &#123; String str1=\"10\"; int a=10; char b='a'; System.out.println(a+str1+b); &#125;结果：1010a 其他数据类型和字符串相连接的时候，会自动调用toString()方法，将其转换成字符串。 获取字符串长度 使用String类的length()方法获取声明字符串对象的长度 语法：str.length() 12String s=\"we are student\";int size=s.length(); 空格也算字符串的一位。 字符串查找 indexOf(String s)查找s在字符串第一次出现的位置 lastIndexOf(String s)查找s在字符串中最后一次出现的位置 查找成功，返回当前字符所在字符串的位置，查找失败，返回-1 1234567public static void main(String[] args) &#123; String s=\"we are student\"; System.out.println(s.indexOf(\"e\")); System.out.println(s.lastIndexOf(\"e\")); System.out.println(s.indexOf(\"l\")); System.out.println(s.indexOf('w')); &#125; 获取索引位置的字符 使用charAt()方法可以将指定索引处的字符返回 语法：s.charAt(int index) 12String s=\"we are student\";System.out.println(\"返回第5个位置\"+s.charAt(5)); 获取子字符串 方法一 ：substring(int beginIndex)从当前位置到结束 方法二 ：substring(int beginIndex,int endIndex)从当前开始，到指定结束 123String s=\"we are student\";System.out.println(s.substring(3));System.out.println(s.substring(2,6)); 去除空格 字符串替换 判断字符串的开始与结尾 判断字符串是否相等 按字典比较两个字符串 字母大小写转换 字符串分割 日期和时间的字符串格式化 常规类型格式化 使用正则表达式 字符串生成器","pubDate":"Mon, 18 Nov 2019 03:32:46 GMT","guid":"https://augus-liuzhi.github.io/2019/11/18/字符串/","category":""},{"title":"第2章 java语言编程基础","link":"https://augus-liuzhi.github.io/2019/11/05/第2章 java语言编程基础/","description":"1 标识符、关键字和注释1.1 标识符 标识符由字母、数字、_和$组成，其中第一个字符不能是数字 标识符大小写敏感 标识符没有长度限制，通常不超过15个字符 java关键字、保留字等不能作为用户的自定义标识符使用 1.2 关键字、保留字、注释 关键字 保留字 注释 单行注释 用//标记 块注释 用/和 /来标记 doc注释 用/* 和 /来标记 2 基本数据类型2.1 概述graph LR; 数据类型-->基本数据类型 数据类型-->引用类型 基本数据类型-->数值类型 基本数据类型-->字符类型 基本数据类型-->布尔类型 引用类型-->类 引用类型-->接口 引用类型-->数组 数值类型-->整型 数值类型-->浮点型 graph LR; byte--1字节-->short short--2字节-->int int--4字节-->long long--8字节-->float float--4字节-->double double--8字节-->boolean boolean--1字节-->char char--2字节-->! 2.2 整数类型12int a;long b=10; 2.3 浮点类型1float f=1.2f; 2.4 布尔类型12boolean l=true;boolean t=false; 2.5 字符类型1char c='a'; 2.6 数据类型转换2.6.1 自动转换1byte--&gt;short--&gt;char--&gt;int--&gt;long--&gt;float--&gt;double 2.6.2 强制转换123高——&gt;低double d=2.3;int l=(int)d; 3 运算符与表达式3.1 算术运算符与算数表达式12+ - * / %+ - ++ -- 3.2 关系运算符与关系表达式1&gt; &lt; &gt;= &lt;= == != 3.3 逻辑运算符与逻辑表达式1&amp;&amp; || ##### 3.4 位运算符与位表达式 1~ &amp; | ^ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 3.5 赋值运算符与赋值表达式1%= &amp;= |= ^= &gt;&gt;= &lt;&lt;= &gt;&gt;&gt;= 3.6 条件运算符与条件表达式1表达式1？表达式2：表达式3 3.7 其他运算符123456()括号运算符[]下标运算符instanceof对象运算符，用于测试一个指向的对象是否是指定类或它的子类的一个实例化对象String s=\"abcd\";boolean b=s instanceof String;new 内存分配运算符 3.8 运算符的优先级与结合性1算数--关系--逻辑--赋值 4 控制语句4.1 选择语句4.1.1 单分支if语句12if(明天下雨) 停课； 4.1.2 双分支if-else语句1234if(明天下雨) 停课；else 上课； 4.1.3 多分支if-else语句123456if(grade&gt;90) A;else if(grade&gt;80) B;else if(grade&gt;70) C; 4.1.4 switch语句1234567switch(c)&#123; case 'a':A;break; case 'b':B;break; case 'c':c;break; default:G;&#125;c只能是字符型或者整型 4.2 循环语句4.2.1 不确定循环123456while(条件)&#123;//又称当型循环 代码；&#125;do&#123; 代码块； &#125;while(条件)//又称直到型循环，至少被执行一次 4.2.2 确定循环1234for(i=0;i&lt;10;i++)&#123; 代码；&#125;初始化，判断终止部分迭代部分，可以都是空，分号必须留，是无限循环 5 跳转语句5.1 break语句12switch 中使用循环体中使用，退出当前循环 5.2 continue语句1结束当前循环，继续进行下一次循环 5.3 return语句1return后面句子不执行 6 数组6.1 一维数组６.１.１ 一维数组的声明1int arr[]; ６.１.２ 数组元素的内存分配1arr=new int[50];//给数组分配50个内存空间 ６.１.３ 一维数组的初始化1234默认初始化int arr[]=new int[50];赋值初始化int arr[]=&#123;1,2,3&#125;; ６.１.４ 一维数组的引用６．２ 数组的数组６．３ 数组的排序12345int a[]=&#123;1,3,5,4,9&#125;Arrays.sort(a)for(int x:a)&#123;//声明循环的变量类型必须和数组类型一致 System.out.println(x+\" \");&#125;","pubDate":"Tue, 05 Nov 2019 12:15:37 GMT","guid":"https://augus-liuzhi.github.io/2019/11/05/第2章 java语言编程基础/","category":""},{"title":"第3章 java面向对象基础","link":"https://augus-liuzhi.github.io/2019/10/28/第3章 java面向对象基础/","description":"1 面向对象基础1.1 对象 概念：世间万物皆为对象，具有一定的属性和行为 1.2 类 概念：类是具有相同属性和行为的对象的抽象 1.3 属性 概念：描述对象的状态，在java中就是变量 1.4 行为 概念：描述对象的行为，在java中就是函数 1.5 面向对象编程的三大特点 1.5.1 封装 封装：将对象的属性和行为封装起来，对外的载体就是类【核心思想】 隐藏对象的属性和实现细节，仅对外提供公共访问方式 好处： 将转化提高 便于使用 提高重用性 提高安全性 封装原则 将不需要的对外提供的内容隐藏起来，把属性都隐藏，提供公共方法对其访问。 12345678910111213141516171819public class cardemo &#123; public static void main(String[] args) &#123; car c=new car(); c.setAge(0); System.out.println(c.getAge()); &#125;&#125;class car&#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age&gt;0&amp;&amp;age&lt;100) this.age = age; else System.out.println(\"age 错误！！！！\"); &#125;&#125; 1.5.2 继承 继承：子类有父类的属性和行为，子类也可以定义自己独有的属性和行为 1.5.3 多态 多态： 2 类2.1 成员变量和局部变量 成员变量定义在类中，整个类中都有访问。局部变量定义在函数、语句、局部代码块中，只有在所属区域有效 成员变量存在于堆内存的对象中，局部变量存在于栈内存的对象中 成员变量随着对象的创建而存在，随着对象的消失而消失。局部变量随着所属区域的执行而存在，随着所属区域结束而释放 成员变量都有默认初始值，局部变量必须初始化。 局部变量和成员变量同名，局部变量优先原则 注意：类类型的参数一定指向对象，否则为NULL 匿名对象 ​ 没有名字的对象new car(); 定义对象的简写格式 当对象对方法进行一次调用，可以使用匿名对象 new car().num=5; new car().color=”red”; new car().run(); 匿名对象可以作为实际参数传递 show(new car()); 构造函数 函数名和类名相同 没有返回值 作用: 给对象初始化 创建对象都必须通过构造函数初始化 一个类中如果没有定义过构造函数，那么该类中就会有一个默认无参的构造函数 如果类中指定了构造函数，那么类中默认的构造函数就没有了 构造函数和一般函数的区别 调用时间： 构造函数对象创建时调用，对对象初始化，一般函数，对象创建后，才可以调用 调用次数： 构造函数只调用一次且是自动调用，一般函数可以调用多次且手动调用 123456789101112131415161718192021222324252627282930public class cardemo &#123; public static void main(String[] args) &#123; person p = new person(); p.speak(); person p1 = new person(\"旺旺\"); p1.speak(); person p2 = new person(\"强强\",10); p2.speak(); &#125;&#125;class person &#123; private String name; private int age; person() &#123; name = \"baby\"; age = 1; System.out.println(\"person run\"); &#125; person(String n) &#123; name = n; &#125; person(String n, int a) &#123; name = n; age = a; &#125; void speak() &#123; System.out.println(name + \" \" + age); &#125;&#125; 多个构造函数出现，必须按照重载方式【参数类型，参数个数，参数顺序】对不同的对象进行初始化 2.2 成员方法 权限修饰符 返回值类型 方法名（参数1，参数2，……参数N）{ ​ //方法体（可以为空） ​ //返回值 } 构造方法 特点：1 无返回值 ​ 2 方法名和类名相同 权限修饰符 方法名（）{ //构造方法体 } 如果没有构造方法，系统会自动创建一个，如果有自己写的，系统将不会创建构造无参构造方法 2.3 权限修饰符 private protected public 本类 可见 可见 可见 同包其他类或者子类 不可见 可见 可见 其他包的类或者子类 不可见 不可见 可见 如果没有设置权限修饰符，默认为本包可见，类的权限决定变量和方法的权限 2.4 this关键字 调用成员的变量和成员的方法 当成员变量和局部变量同名时 用this区分 this表示当前对象的引用 this可以在构造函数中调用其它构造函数，但是必须放在当前调用构造函数的第一行，即this函数放置在第一行 2.5 静态变量、常量和方法 用static修饰的成员被所有对象共享 static优于对象存在，因为static的成员随着类的加载就已经存在了 用关键字static修饰的变量，常量，方法称为静态变量，常量，方法 static修饰的成员多了一种调用方式，使用语法：类名.静态类成员 static修饰的数据是共享数据（静态/类变量，静态方法），对象中存储的数据是特有数据（叫成员/实例变量，成员方法） 静态放法中不可以使用this关键字 在静态方法中不可以直接调用非静态方法 局部变量不可以声明static 成员变量和静态变量的区别 1 两个变量的生命周期的时间不一样，成员变量随着对象的创建而存在，随着对象的释放被回收，静态变量随着类的加载而实现，随着类的消失而消失 2 调用方式不同 成员变量只能被对象调用，然而静态变量可以用类名和对象调用【尽量使用类名调用】 3 别名不同 成员变量也叫实例变量 静态变量也叫类变量 4 存储位置不同 成员变量的数据存储在堆内存的对象中，所以也叫对象的特有数据 静态变量存储在方法区的静态区【共享数据区】，所以也叫对象的共享数据 静态的注意事项： 静态方法只能访问静态成员。【访问局限性】 非静态即可以访问静态，又可以访问静态 静态方法中不可以使用this和super关键字 主函数是静态的 主函数： 格式是固定的 被JVM识别和调用 public：权限是最大的 static : 虚拟机调用主函数，不需要对象，直接用类名调用 void : 无返回值 main : 函数名，JVM识别的一个名字 String[] args: 参数列表，是一个数组类型的参数，元素都是字符串【==&gt;new String[0]】 3 对象3.1 对象的创建 语法： Test test=new Test(); Test test=new Test(a); 注意：每创建一个对象，就会调用一次构造方法 3.2 访问对象的属性和行为 类名.行为 类名.属性","pubDate":"Mon, 28 Oct 2019 01:02:24 GMT","guid":"https://augus-liuzhi.github.io/2019/10/28/第3章 java面向对象基础/","category":"--satic关键字 --this关键字"},{"title":"结对项目代码","link":"https://augus-liuzhi.github.io/2019/10/22/结对项目代码/","description":"1.操作数随机12345678class Operand &#123;// 定义随机操作数类 int op1, op2; Operand(int Limits) &#123; op1 = (int) (Math.random() * Limits + 1); op2 = (int) (Math.random() * Limits + 1); &#125;&#125; 2. 加法类123456789class Add extends Operand &#123;// 定义加法类 Add(int Limits) &#123; super(Limits); &#125; void add() &#123; System.out.println(op1 + \"+\" + op2 + \"=\"); &#125;&#125; 3. 减法类123456789class Sub extends Operand &#123;//定义减法类 Sub(int Limits) &#123; super(Limits); &#125; void sub() &#123; System.out.println(op1 + \"-\" + op2 + \"=\"); &#125;&#125; 4. 乘法类123456789class Mul extends Operand &#123;//定义乘法类 Mul(int Limits) &#123; super(Limits); &#125; void mul() &#123; System.out.println(op1 + \"*\" + op2 + \"=\"); &#125;&#125; 5. 除法类123456789class Div extends Operand &#123;//定义除法类 Div(int Limits) &#123; super(Limits); &#125; void div() &#123; System.out.println(op1 + \"/\" + op2 + \"=\"); &#125;&#125; 6. 随机符号运算123456789101112131415161718switch (c) &#123; case 1: Add add = new Add(limits); add.add(); break; case 2: Sub sub = new Sub(limits); sub.sub(); break; case 3: Mul mul = new Mul(limits); mul.mul(); break; case 4: Div div = new Div(limits); div.div(); break; &#125; 7. 添加需求1234567891011while(true) &#123; try &#123; Scanner input=new Scanner(System.in); limits=input.nextInt(); break; &#125; catch(Exception e)&#123; System.out.println(\"捕获错误：\"+ e); System.out.println(\"请重新输入范围：\"); &#125; &#125;","pubDate":"Tue, 22 Oct 2019 09:50:52 GMT","guid":"https://augus-liuzhi.github.io/2019/10/22/结对项目代码/","category":""},{"title":"java接口","link":"https://augus-liuzhi.github.io/2019/10/17/java接口/","description":"1. 接口定义 当一个抽象类的所有方法是抽象方法的时候，这时可以将该抽象类用另一种形式和定义来表示，那就是接口 interface【接口和抽象类似，必须全部覆盖接口类的所有抽象方法】 定义接口关键字：interface 123456interface demo &#123; abstract void show(); abstract void show1();&#125; 对于接口中常见的成员，这些成员都有固定修饰符 全局常量：public static final 抽象方法：public abstract void show(); 结论：接口的成员都是公共权限 2. 接口的实现 类与接口之间的关系是实现，类与类之间是继承关系 接口不能实例化，只能由实现类覆盖接口类的所有方法，实现类才可以实例化 1234567891011121314151617181920212223242526272829public class Implementtext &#123; public static void main(String[] args) &#123; demoimpl d = new demoimpl(); System.out.println(d.num); System.out.println(demo.num);//静态类名调用 System.out.println(demoimpl.num);//静态类名调用 d.show(); d.show1(); &#125;&#125;interface demo &#123; public static final int num = 10;//按照格式写 public abstract void show();//按照格式写 public abstract void show1();//按照格式写&#125;class demoimpl implements demo &#123; public void show() &#123; System.out.println(\"show\"); &#125; public void show1() &#123; System.out.println(\"show1\"); &#125;&#125; java不支持多继承，会出现不确定调用，进行多继承改良，采用多实现 多实现：一个类可以实现多个接口 123456789101112131415161718interface A &#123; public abstract int add(int a, int b);&#125;interface B &#123; public abstract void show();&#125;class Text implements A, B &#123; public void show() &#123; System.out.println(\"show方法执行\"); &#125; public int add(int a, int b) &#123; return a + b + 3; &#125;&#125; 一个类继承另一类的时候还可以实现多个接口 接口的出现避免单继承的局限性 123456789101112131415161718192021222324252627282930interface gg &#123;//接口gg public void show();&#125;interface mm &#123;//接口mm public void see();&#125;interface Person extends gg, mm &#123;// 接口和接口之间是继承关系，而且还是多继承 public void fun();&#125;class Q implements Person &#123;//类Q有3个方法 @Override public void show() &#123; &#125; @Override public void see() &#123; &#125; @Override public void fun() &#123; &#125;&#125; 接口和抽象类的区别 相同点：都是向上抽取来的 不同点： ​ 抽象类需要被继承，而且单继承，接口需要被实现，可以多实现 ​ 抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法，但是接口中只能 定义抽象方法必须有子类去实现 ​ 抽象类的继承是 is a 关系，定义体系内共性内容，接口的实现是like a关系，定义的体系额外功能 用一个例子来说明 1234567891011121314151617181920212223242526272829303132333435363738abstract class dog &#123;//定义犬类 String name;//有名字 int age;//有年龄 void eat() &#123;//能吃 System.out.println(\"can eat\"); &#125; abstract void sleep();//能睡，不同狗睡的地方不一样&#125;interface fun_seek &#123;//定义额外功能接口 public abstract void seekroad();//认路&#125;interface fun_look //定义额外功能接口 public abstract void lookfor();//查毒&#125;class eyedog extends dog implements fun_seek &#123;//定义导盲犬继承犬类的共性，并添加认路的功能 void sleep() &#123;//重写抽象类睡觉的方式 System.out.println(\"在主人家睡觉\"); &#125; public void seekroad() &#123;//重写添加的认路功能 System.out.println(\"俺认识路\"); &#125;&#125;class lookdog extends dog implements fun_look &#123;//定义缉毒犬继承犬类共性，并添加找毒的功能 void sleep() //重写抽象类睡觉的方式 System.out.println(\"在警察局睡觉\"); &#125; public void lookfor() &#123;//重写添加找毒的功能 System.out.println(\"俺可以查毒\"); &#125;&#125;","pubDate":"Thu, 17 Oct 2019 10:46:14 GMT","guid":"https://augus-liuzhi.github.io/2019/10/17/java接口/","category":""},{"title":"super和final关键字","link":"https://augus-liuzhi.github.io/2019/10/15/super和final关键字/","description":"1. super关键字 调用构造方法 调用隐藏变量 调用重写方法 注意：super调用的都是父类 super使用代码 1234567891011121314151617181920212223242526272829303132333435class A &#123; int num = 10; A() &#123; System.out.println(\"父类无参构造方法执行了\"); &#125; A(int x) &#123; System.out.println(\"父类有参构造方法执行了\"); &#125; void show() &#123; System.out.println(\"父类show方法\"); &#125;&#125;class B extends A &#123; B() &#123; super();// 调用父类无参构造方法 System.out.println(\"隐藏变量已经调用:\"+super.num);// 调用隐藏变量 System.out.println(\"B子类的构造方法执行了\"); &#125; void show() &#123; super.show();// 调用父类被重写的方法 System.out.println(\"子类show方法\"); &#125;&#125;class C extends A &#123; C() &#123; super(4);// 调用父类中的有参构造方法 System.out.println(\"C子类的构造方法执行了\"); &#125;&#125; 2. final关键字继承的弊端：打破封装性 final关键字可以修饰类、方法、变量 2.1 final修饰类123final class A &#123;&#125; final修饰的类不能被继承，即不能有子类 2.2 final修饰方法123final void show() &#123; &#125; final修饰的方法不允许被子类重写 2.3 final变量final修饰的变量为常量，常量一般同时使用时final和static修饰，只能被赋值一次（常量大写） 1static final int a=10; 3. 抽象类3.1 抽象定义 抽象：模糊，不具体，看不懂 12345678910111213141516171819abstract class Animal &#123;// 定义抽象动物类 abstract void eat();// 定义抽象方法 void sleep() &#123;//定义实例方法 System.out.println(\"can sleep\"); &#125;&#125;class Person extends Animal &#123; void eat() &#123; System.out.println(\"用筷子拿着吃\"); &#125;&#125;class Bird extends Animal &#123; void eat() &#123; System.out.println(\"用嘴叼着吃\"); &#125;&#125; 3.2 抽象特点方法只有声明没有实现时，该方法就是抽象方法，被abstract修饰，抽象方法必须定义在抽象类中。 抽象类不可以被实例化【调用抽象方法没有意义】 抽象类的子类，必须重写抽象类的所有抽象方法才可以实例化，否则，子类还是抽象类 3.3 抽象细节 抽象类有构造函数，给子类对象进行初始化 抽象类可以不定义抽象方法【一般这种类主要是不让创建对象】 抽象关键字不可以和哪些关键字共存【private不行，static不行，final不行】 抽象类和一般类的异同 ​ 相同：描述事物，都在内部定了成员 ​ 不同点： ​ 1 一般类中有足够的信息用来描述事物，抽象类描述不足 ​ 2 一般类中，不可以定义抽象方法，但是抽象类中可以定义，也可以定义非抽象 ​ 3 一般类类可以被实例化，抽象类不可以被实例化 抽象类一定是父类【子类覆盖其方法后才可以对子类实例化】","pubDate":"Tue, 15 Oct 2019 14:14:28 GMT","guid":"https://augus-liuzhi.github.io/2019/10/15/super和final关键字/","category":""},{"title":"Java面向对象——继承","link":"https://augus-liuzhi.github.io/2019/10/15/Java继承/","description":"1. 继承的概述 继承就是子类继承父类的变量和方法，下面用代码解释一下： 1234567891011121314151617class Student &#123;// 定义学生类 String name; int age; void study() &#123; System.out.println(name + \"studay good\" + age); &#125;&#125;class Work &#123;// 定义工人类 String name; int age; void work() &#123; System.out.println(name + \"work good\" + age); &#125;&#125; 从上述例子中可以看到，学生类和工人类都有共同的特征，为了实现代码复用性，进行抽取，java中抽取用类表示将共有的的行为或特征进行抽取，然后原来的来类也要可以用，我们就需要用原来类继承我们抽取的类，用extends关键字进行调用，如： 12345678910111213141516class Student extends Person &#123;// 定义学生类 void study() &#123; System.out.println(name + \"studay good\" + age); &#125;&#125;class Work extends Person &#123;// 定义工人类 void work() &#123; System.out.println(name + \"work good\" + age); &#125;&#125;class Person &#123;// 定义我们抽取的类 String name; int age;&#125; 通常称Person（被继承的类）类为父类（也叫操类，基类），称Work和Student（继承类）称为子类。 2. 继承的优点 提高代码复用性 让类与类产生关系，给多态提供了前提 java支持单继承，不支持多继承，对C++多继承进行改良 单继承：一个子类只能有一个直接父类 1234567891011class A &#123;&#125;class B &#123;&#125;class C extends A &#123;&#125; 或者 1234567891011class A &#123;&#125;class B &#123;&#125;class C extends B &#123;&#125; 多继承：一个子类能有多个直接父类(为什么不能多继承)【不直接支持，会产生调用的不确定性】 123456789101112131415class A &#123; void show() &#123; System.out.println(a); &#125;&#125;class B &#123; void show() &#123; System.out.println(b); &#125;&#125;class C extends A,B &#123;&#125; 当我们new c();调用show方法，调用的是A的还是B的？为了区分java对此进行了改良，不用多继承，用接口 java支持多层（多重继承）=&gt;传递性 1234567891011class A &#123; &#125;class B extends A &#123; &#125;class C extends B &#123;&#125; 3. 类的继承原则 单继承 继承具有传递性 继承不能循环 除Object类，所有类都有父类 4. 继承的使用当要使用一个继承体系时，如何使用 ? 查看该体系中顶层类，了解该体系的基本功能。 创建该体系中最子类的对象，完成功能的使用。 什么时候写继承？ 当类存在所属关系，就定义继承，A属于B,则A继承B 5. 继承中的成员变量当本类局部和成员变量名相同时用this区分 当子父类中成员变量相同时用super区分 this和super的用法很相似 this：代表一个本类对象的引用 super：代表一个父类空间 1234567891011class A &#123; int num = 5;&#125;class B extends A &#123; int num = 10; void show() &#123; System.out.println(this.num + \"……\" + super.num);//调用子类和父类的成员变量 &#125;&#125; 注意：子类不能直接访问父类的私有成员 6. 继承中的成员方法1234567891011121314151617181920212223class A &#123; int num = 5; void show1() &#123; System.out.println(num); &#125;&#125;class B extends A &#123; int num = 10; void show2() &#123; System.out.println(num); &#125;&#125;public class Extendstext &#123; public static void main(String[] args) &#123; B b = new B(); b.show1(); b.show2(); &#125;&#125; 当子父类中函数一样，将会运行子类的函数，称为覆盖操作 12345678910111213141516171819202122class A &#123; int num = 5; void show() &#123; System.out.println(num); &#125;&#125;class B extends A &#123; int num = 10; void show() &#123; System.out.println(num); &#125;&#125;public class Extendstext &#123; public static void main(String[] args) &#123; B b = new B(); b.show(); &#125;&#125; 6.1 函数的两个特性 重载：同一个类 覆盖：子类中，覆盖也叫重写 6.2 注意事项 子类的方法覆盖父类方法时，子类的权限必须大于父类的权限 静态只能覆盖静态，或被静态覆盖 6.3 什么时候使用覆盖操作当对一个类进行子类扩展时，子类需要保留父类的功能声明，但要定义子类中功能的特有内容时，就用覆盖操作完成。(修改方法，添加功能)如： 12345678910111213141516171819202122232425class Phone &#123;// 定义一个手机类 void call() &#123;// 通话功能 &#125; void show() &#123;// 展示功能 System.out.println(\"number\"); &#125;&#125;class newphone extends Phone &#123; void show() &#123;// 展示功能重写 System.out.println(\"name\"); System.out.println(\"jpg\"); System.out.println(\"number\"); &#125;&#125;或者class newphone extends Phone &#123; void show() &#123;// 展示功能重写 System.out.println(\"name\"); System.out.println(\"jpg\"); super.show();//调用父类show方法 &#125;&#125; 7. 继承中的构造函数在子类构造对象时，访问子类构造函数时，父类也运行，在子类的构造函数中，有一个默认的隐士语句，super();调用父类中空参数的构造函数，无覆盖，无继承 无参数 123456789101112class fu &#123; fu() &#123; System.out.println(\"fu run\"); &#125;&#125;class zi extends fu &#123; zi() &#123; super();//隐士自带的调用父类空参数构造函数 System.out.println(\"zi run\"); &#125;&#125; 有参数 123456789101112class fu &#123; fu(int x) &#123; System.out.println(\"fu run\"); &#125;&#125;class zi extends fu &#123; zi() &#123; super(4);//隐士自带的调用父类空参数构造函数 System.out.println(\"zi run\"); &#125;&#125; 子类的实例化过程，子类中的每个构造函数都会访问父类中空参数的构造函数 结果：AC AD 123456789101112131415161718192021222324public class Extendstext &#123; public static void main(String[] args) &#123; new zi(); new zi(6); &#125;&#125;class fu &#123; fu()&#123; System.out.println(\"A\"); &#125; fu(int x) &#123; System.out.println(\"B\"); &#125;&#125;class zi extends fu &#123; zi() &#123; System.out.println(\"C\"); &#125; zi(int x)&#123; System.out.println(\"D\"); &#125;&#125; 结果：BD 123456789101112131415161718192021222324public class Extendstext &#123; public static void main(String[] args) &#123; new zi(6); &#125;&#125;class fu &#123; fu()&#123; System.out.println(\"A\"); &#125; fu(int x) &#123; System.out.println(\"B\"); &#125;&#125;class zi extends fu &#123; zi() &#123; System.out.println(\"C\"); &#125; zi(int x)&#123; super(x);//覆盖隐式super(); System.out.println(\"D\"); &#125;&#125; 为什么自子类实例化的时候，会调用父类构造方法？ 子类继承父类，所以子类有父类的属性，在使用父类内容前，要先看父类如何对自己的内容进行初始化，所以子类构造函数初始化的时候，必须调用父类构造函数，所以在子类的构造函数默认加了super(); 如果父类中没有定义无参构造函数或者说是父类中定义了有参，没有定义无参，那么必须用super();来指定调用父类的构造函数 如果子类的构造函数中使用了this();调用本类的构造函数，那么super();就没有了，因为super和this只能定义在第一行，所以只能有一个，但是可以保证的是，子类中肯定会有其他构造方法来访问父类的构造函数。 注意：super();语句必须要定义在子类构造函数的第一行，因为父类的初始化要先完成","pubDate":"Tue, 15 Oct 2019 12:08:31 GMT","guid":"https://augus-liuzhi.github.io/2019/10/15/Java继承/","category":""},{"title":"Java计算器编程","link":"https://augus-liuzhi.github.io/2019/10/01/Java计算器编程/","description":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.IOException;import java.util.Scanner;public class Jisuanqi &#123; public static void main(String[] args) throws IOException &#123; opreation op1 = new opreation(); opreation op2 = new opreation(); Scanner read = new Scanner(System.in); System.out.println(\"请输入第一个数：\"); op1.a = read.nextInt(); System.out.println(\"请输入运算符：\"); char ch = (char) System.in.read(); System.out.println(\"请输入第二个数：\"); op2.b = read.nextInt(); char c=ch; switch (c) &#123; case '+': add ad = new add(); ad.add(op1.a, op2.b); break; case '-': sub su = new sub(); su.sub(op1.a, op2.b); break; case '*': mul mu = new mul(); mu.mul(op1.a, op2.b); break; case '/': div di = new div(); di.div(op1.a, op2.b); break; &#125; &#125;&#125;class opreation&#123; //定义抽象操作类 int a,b,c; void add()&#123; &#125; void sub()&#123; &#125; void mul()&#123;&#125; void div()&#123; &#125;&#125;class add extends opreation&#123;//定义加法类 public void add(int a,int b)&#123; c=a+b; System.out.println(a+\"+\"+b+\"=\"+c); &#125;&#125;class sub extends opreation&#123;//定义减法类 public void sub(int a,int b)&#123; c=a-b; System.out.println(a+\"-\"+b+\"=\"+c); &#125;&#125;class mul extends opreation&#123;//定义乘法类 public void mul(int a,int b)&#123; c=a*b; System.out.println(a+\"*\"+b+\"=\"+c); &#125;&#125;class div extends opreation&#123;//定义除法类 public void div(int a,int b)&#123; if(b==0) System.out.println(\"除数不能为0\"); double c=a/b; System.out.println(a+\"/\"+b+\"=\"+c); &#125;&#125;","pubDate":"Tue, 01 Oct 2019 09:16:56 GMT","guid":"https://augus-liuzhi.github.io/2019/10/01/Java计算器编程/","category":"--Java编程"},{"title":"第1章 java语言概述","link":"https://augus-liuzhi.github.io/2019/09/23/第1章 java语言概述/","description":"1.1 java简介java是一种高级的面向对象程序设计语言，可以在任何计算机、系统和支持java硬件的设备上运行 1.1.1 java语言的历史 曾用名：OAK Sun公司（命名JAVA）—被收购—&gt;Oracle公司 是一种解释型语言（java可以看成一种编译+解释的语言，在后面特点中细说） 1.1.2 javay语言的特点 简单 java源于c++,语法简洁，取消指针，多重继承等复杂，实现垃圾自动回收 面向对象 所有元素通过类和对象访问 安全 强类型语言 不支持指针操作 提供异常处理机制 解释性 java代码编译后，不生成机器语言，先生成字节码，再借助java解释器，对编译的后的字节码进行解释执行 java克服传统的解释型语言，先进行编译，再解释，有编译型语言的效率高的优点，也有解释型语言平台无关的优点 平台无关 和平台没有关系，只要保证该平台有java解释器就可以运行java字节码文件 多线程 java环境本身的多线程 java语言内置多线程控制 动态性 动态调整程序，不影响客户端的使用 开源性 免费，开放JDK源代码 1.1.3 java应用领域 [x] 桌面应用系统开发 [x] 嵌入式系统开发 [x] 电子商务应用 [x] 企业级应用开发 [x] 交互式系统开发 [x] 多媒体系统开发 [x] 分布式系统开发 [x] web应用系统开发 1.1.4 java的版本 Java SE 主要用于桌面程序的开发 Java EE 主要开发企业级分布式网络应用程序 Java ME 主要是嵌入式系统开发 1.2 java开发环境的搭建 1.2.1下载JDK https://www.oracle.com/java/technologies/jdk12-downloads.html 1.2.2 双击运行点下一步 1.2.3 默认路径，不用更改，继续下一步 1.2.4 关闭即可 1.2.5 环境配置 我的电脑——属性——高级系统设置——高级——环境变量 1.2.6 添加一个系统变量 变量名：JAVA_HOME 路径：C:\\Program Files\\Java\\jdk-12.0.2 1.2.7 在Path变量中再添加一条 %JAVA_HOME%\\bin; 注意： 1）分号【英文下的】 2）12版本默认无jre,不需要jre的变量，也不需要classpath 1.2.8 测试 Cmd下输入 java -version 出现版本，安装成功 1.3 Java开发过程 源文件（.java文件）–&gt;Java编译器：javac–&gt;字节码文件：.class–&gt;java 主类名–&gt;解释执行字节码文件 1.4 java编程风格 Allman风格：各占一行 12345for(int i=0;i&lt;n;i++)&#123;&#125; Kernighan风格：省一行 123for(int i=0;i&lt;n;i++)&#123; &#125; 1.5 第一个Java程序 12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(\"hello,world\"); &#125;&#125; 用记事本写好文件，然后以Hellojava.java保存，打开控制台，先用javac 编译成 .class文件结尾的字节码文件，再用java去执行 1.6 知识拓展 计算机不能理解高级语言，也不能执行高级语言，只识别机器语言（01代码，二进制），用高级语言写的程序，要想让计算机运行，必须翻译成机器语言，翻译方法有两种 1. 编译 2. 解释 因此高级语言分编译型语言和解释型语言 编译型语言：用专用的的编译器，针对特定的平台（如linux,windows等）执行成可以被该平台识别的的机器语言然后加以包装生成可执行的程序如.exe文件，这个.exe下次执行可以脱离开发环境，在该平台运行，运行效率高。【源代码参与一次】 解释型语言：用专用的解释器，解释成特定平台的机器语言，然后在该特定平台上执行，解释型语言每次运行都需要解释器解释成相应平台的机器语言，然后再次执行，所以效率低，但是只要任何平台提供相应的解释器，就可以在任何平台运行，方便程序的移植。【每次运行都需要源代码参与】 jre(java runtime environment,java运行时环境) 由JVM和Java API组成,主要负责java的运行 解释型语言：用专用的解释器，解释成特定平台的机器语言，然后在该特定平台上执行，解释型语言每次运行都需要解释器解释成相应平台的机器语言，然后再次执行，所以效率低，但是只要任何平台提供相应的解释器，就可以在任何平台运行，方便程序的移植。【每次运行都需要源代码参与】 jre(java runtime environment,java运行时环境) 由JVM和Java API组成,主要负责java的运行 JDK(java development kit,java开发工具集)包含jre包含java程序开发的所需要的编译，调试等工具，还包含jdk源码","pubDate":"Mon, 23 Sep 2019 11:58:38 GMT","guid":"https://augus-liuzhi.github.io/2019/09/23/第1章 java语言概述/","category":"-java"},{"title":"软件工程第三次作业——关于软件质量保障初探","link":"https://augus-liuzhi.github.io/2019/09/22/软件质量保障/","description":"Q1: 对教材与参考资料阅读后关于软件质量保障你的体会是什么？ A: 首先了解一下什么是软件质量，根据IEEE认为符合用户以及利益相关者的需求，那么软件的质量又从程序质量和软件工程质量来看，软件质量又从软件功能的质量来体现，软件工程的又体现在，可见性，风险控制，成本，指标情况等，简单来说出来就是软件质量满足需求，还要满足盈利中造出足够好的软件,那什么是软件质量保障就是我们所说的QA,软件质量保障的工作无异于就是测试，但是这些还是不够的，读了质量保障以后说一下体会吧，虽然是专人专责，但是不意味着 某个模块出了问题，但是我没有责任，我就不管，项目毕竟是整体的，只要是项目的问题，我们就应该付出责任，也不应该盲目相信专业人士，应该根据我们的具体情况来，制定明确的责任人承担责任，采用高质量的测试用例 Q2: 如果你是一个项目的QA，那么你认为你的工作职责范围是什么? A: 从项目需求阶段、设计阶段、研发过程、产品测试、验收几乎项目的整个生命周期都参与，需求设计阶段要审查设计时候合理，是否能满足客户的真正需求。是否符合客户群体的使用习惯，操作是否简单易学等等。数据库结构设计、系统架构、功能页面等是否能按照需求实现。另外，还要督促研发进度，要定好项目进度，并督促其完成。每个让都有惰性，没有人监督总会有延迟。产品出来了，QA还要检测质量，其实就是测试。通常QA手下有一组测试人员，负责产品测试。产品经过测试、修改，形成最终产品。此时产品可以交给客户了。产品到了客户那里，没有一个客户会一言不发欣然接受。总是提出这样那样的要求，这时候QA还要细心倾听客户的要求，耐心的给予讲解说明，汇总所有需要修改的点，反馈给研发人员（项目经理或研发经理）并确认其按照客户要求完成修改 总结： qa应该懂开发，一个不懂开发的qa只能做流水线测试，而有些bug往往是测试不出来的。 qa必须了解需求项目中，qa的参与从需求开始。一个不了解需求的qa必然不是一名合格的qa. qa必须了解项目的上下游的结构一个不了解上游的qa, 必然无法确定dev对上游的调用是否可靠；一个不了解下游的qa, 必然无法确定项目的实现是否符合下游的调用场景。 qa为整个项目的质量负责qa在项目中不是为找bug而存在的。 Q3：如果你是一个项目经理，那么你认为这你的项目中需要专职的QA么？还是只需有Test即可？如果一旦出现问题，你如何界定由谁担责？ A：读了《我们需要专职的QA》后，一开始我也不敢说只需要QA或者只需要Test,我认为如果对于专职QA来说，他们只懂得用高级的工具进行流水线似的测试，但是不懂开发和原理，那么专职的QA对开发来说那就是一种累赘，不仅测试会生出许多的bug,甚至不是bug也会处理成bug让开发来进行处理，这就大大阻碍的工程的进度，还会在人际交往上产生隔阂，并且QA没有什么责任来承担，就像文中所说，项目即将上线了，出现了内存bug，本应该两个月之前应该告诉开发，却迟迟晚了两个月，如果这个时候，要是再有不太愿意上心的开发人员，那这个项目，我感觉质量啥的根本不用说什么保障了，在这个实例中，我感觉这个QA就是打酱油的，没有存在的价值，但是如果一个上心又有能力的QA，那会不会有就不太一样了呢，比如，促进项目的发展，节省项目开发成本，节省测试时间，按照我个人的观点来看，我感觉专职的QA我们不需要，我们只需要Test就可以了，让test每天跟进开发人员的脚步，而不是和以前一样只是，自己做自己的测试，完全不需要和开发人员进行协商，让开发和test各司其职，对项目共同负责，对项目责任进行划分，首先让开发首先进行自我测试，并且要注释明确，对于BUG进行等级划分，不能出现太多小的bug让测试来做吧，Test在进行测试的时候,如果在某个模块出现bug太多，如果说这个模块在以后的项目中，出现问题那么就由这个开发来负责，如果bug等级高，数量少并且没有被开发发现，后续过程中，test也没有发现，那这个责任由test负责，无论是谁负责，在项目中都应该尽职尽责，保证项目上线不会出问题。","pubDate":"Sun, 22 Sep 2019 14:00:24 GMT","guid":"https://augus-liuzhi.github.io/2019/09/22/软件质量保障/","category":"-软件质量保证 -QA _QA工作职责 -QA和Test"},{"title":"Java算法题","link":"https://augus-liuzhi.github.io/2019/09/21/Java算法题/","description":"题目11234567891011121314151617181920/* 数列： 2/1 3/2 5/3 8/5 13/8 21/13………… * 思路： 斐波那契数列（黄金分割数列），从第三项开始，前两项之和等于下一项 * 本题：分母+分子=下一项分子 分子=下一项分母 */public class Fibonacci_number &#123; public static void main(String[] args) &#123; int numerator = 2; // 定义初始分子; int denominator = 1; // 定义初始分母； int n = 0, sum; // 定义n控制 n项 sum为当前第n项值 float sums = 0f; // sums为前n项和 while (n &lt; 20) &#123; sum = (numerator / denominator); numerator = (denominator + numerator); denominator = numerator; sums += sum; n++; &#125; System.out.println(\"前20项数列之和为：\" + sums); &#125;&#125; 题目212345678910111213141516/* 完数（又名完美数）一个数等于除它本身之外的因子之和，就是完数 * 题目：求1000以内的完数 */public class Perfect_number &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt; 1000; i++) &#123;// 遍历1000以内的数 int sum = 0;// 定义因子之和 for (int j = 1; j &lt; i; j++) &#123;// j是因子，j&lt;i则j不包含本身i if (i % j == 0) sum = sum + j;// 因子累加 &#125; if (sum == i)// 判断完数 System.out.println(i); &#125; &#125;&#125; 题目3123456789101112131415161718192021222324252627/* 题目：将一个正整数分解质因数 如90=2*3*3*5 * 程序分析（1）对n进行分解质数，找一个最小质数k，如果n==k,则结束 * （2）当n&gt;k时，如果n能被k整除，则k是一个质因数，输出，并将这个n/k这个正整数进行质因数分解， * 把n/k赋值给n，继续执行第一步 * （3） 如果不能被整除，继续进行k+1判断能否被整除 */import java.util.Scanner;public class Prime &#123; public static void main(String[] args) &#123; Scanner read=new Scanner(System.in); System.out.println(\"请输入要分解的正整数：\"); int n = read.nextInt();//获取输入的数字n System.out.print(n + \"=\"); for (int k = 2; k &lt;= n; k++) &#123; while (n != k) &#123;//判断n是否等于k if (n % k == 0) &#123;//能整除就是因数，输出 System.out.print(k + \"*\");//输出，*控制格式 n = n / k; &#125; else &#123; //不能被整除就跳出while break; &#125; &#125; &#125; System.out.println(n); &#125;&#125; 题目412345678910111213141516171819202122/* 题目：用条件运算符嵌套完成此题：学习成绩&gt;90 用A表示 * 60-89之间用B表示 小于60用C表示 */import java.util.Scanner;public class IfElse &#123; public static void main(String[] args) &#123; Scanner read = new Scanner(System.in); System.out.println(\"请输入-成绩：\"); int a = read.nextInt(); if (a &gt;= 90) &#123; System.out.println(\"成绩：A\"); &#125; else &#123; if (a &gt;= 60 &amp;&amp; a &lt; 90) &#123; System.out.println(\"成绩：B\"); &#125; else &#123; if (a &lt; 60) &#123; System.out.println(\"成绩：C\"); &#125; &#125; &#125; &#125;&#125; 题目512345678910111213141516171819202122232425262728/* 求最小公倍数算法：两个整数相乘除以最大公约数 * 求最大公约数：辗转相除法：a%b=c 只要c不为0 a=b * b=c继续除，知道c=0,输出此时的被除数，就是最大公约数 */import java.util.Scanner;public class Gcd &#123; public static void main(String[] args) &#123; Scanner read=new Scanner(System.in); System.out.println(\"请输入第一个数：\"); int a=read.nextInt();//定义接收第一个数 int d=a;//d用于求小公倍数 System.out.println(\"请输入第二个数：\"); int b=read.nextInt();//定义接收第二个数 int e=b;//e用于求小公倍数 int c=a%b;//求余判断最大公约数 int f=b;//如果第一次就被整除，则直接接收b while(c!=0) &#123;//辗转相除 a=b; b=c; c=a%b; f=b; &#125; System.out.println(\"最大公约数是：\"+f); System.out.println(\"最小公倍数是：\"+((d*e)/f)); &#125;&#125; 题目612345678910111213141516171819202122232425262728/* 题目： * 数字1-4能组成多少个不重复且互不相同的数字 * 思路：定义三个1-4的数组，然后用三个循环嵌套，进行遍历 * 输出，如果出现相同的或者重复的进行判断筛选 */public class SanWeiShu &#123; public static void main(String[] args) &#123; int a[]= &#123;1,2,3,4&#125;; int b[]= &#123;1,2,3,4&#125;; int c[]= &#123;1,2,3,4&#125;; int count=0; for(int i:a) &#123;//三层循环可以控制出现不重复的 for(int j:b) &#123; for(int t:c) &#123; if(i==j||j==t||i==t) &#123;//判断不要相同的 continue; &#125; else &#123; count++; System.out.print(i+\" \"+j+\" \"+t); System.out.println(); &#125; &#125; &#125; &#125; System.out.println(\"不重复的数字有\"+count+\"个\"); &#125;&#125; 题目7123456789101112131415161718192021222324252627/* 题目：输入一个数，求它是几位数，并且逆序输出 * 思路： * 先将int转为String * 然后根据String的长度建立一个空int[] * 再用一个循环，分别赋String中对应位char转为int的值给每一个int[]中元素 * 然后循环遍历逆序输出数组 */import java.util.Scanner;public class Reverse &#123; public static void main(String[] args) &#123; Scanner read = new Scanner(System.in); System.out.println(\"请输入一个不多于五位数的整数：\"); int a = read.nextInt();//键盘接收一个数字 String str = String.valueOf(a);//将int变成string System.out.println(\"你输入的是：\" + str); int arr[] = new int[str.length()]; System.out.println(\"数字的位数是：\" + str.length() + \"位\");//string的长度就是数字的位数 for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); arr[i] = Integer.parseInt(str.charAt(i) + \"\");//将字符串转换成一个整数，赋值给数组 &#125; System.out.print(\"数字的逆序输出是：\"); for (int i = arr.length - 1; i &gt;= 0; i--) &#123;//逆序输出 System.out.print(arr[i] + \" \"); &#125; &#125;&#125; 题目812345678910111213141516171819202122232425/* 题目：判断一个五位数是不是回文 * 思路：数字转字符串，字符串转字符，字符转数组 * 判断第一位和最后一位是否相等，判断第二位和倒数第二位是否相等 */import java.util.Scanner;public class Palindrome &#123; public static void main(String[] args) &#123; Scanner read = new Scanner(System.in); System.out.println(\"请输入一个五位数的整数：\"); int a = read.nextInt();//键盘接收一个数字 String str = String.valueOf(a);//将int变成string System.out.print(\"你输入的是：\" + str+\" \"); int arr[] = new int[str.length()]; for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); arr[i] = Integer.parseInt(str.charAt(i) + \"\");//将字符串转换成一个整数，赋值给数组 &#125; if((arr[0]==arr[4])&amp;&amp;(arr[1]==arr[3])) &#123;//判断 System.out.print(\"是回文\"); &#125; else &#123; System.out.print(\"不是回文\"); &#125; &#125;&#125; 题目91234567891011121314151617/* 题目：求一个3*3矩阵对角元素之和 * 思路：二维数组来写3*3矩阵 */public class Matrix &#123; public static void main(String[] args) &#123; int a[][]= &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; int sum=0; for(int i=0;i&lt;a.length;i++) &#123; for(int j=0;j&lt;a.length;j++) &#123; if(i==j||(j==a.length-i-1)) &#123;//判断对角元素 sum+=a[i][j];//对角元素的累加 &#125; &#125; &#125; System.out.println(\"对角线之和：\"+sum); &#125;&#125; 题目10(一)12345678910111213141516171819202122232425262728293031323334353637/* 题目： N个人人围成一圈，从1-3报数，凡是报到3的就会剔除，问最后剩下的是几号？ * 思路：将N个人改成布尔类型，然后通过for循环，给每个人赋值给true，再用一个计数器 * t，凡是累加到3（相当于报数到3）然后就将此时的a[i]赋值给false,知道最后剩下只有一个数的时候 * 那么这个数的下标值加1就是所求 */import java.util.Scanner;public class Josephus &#123; public static void main(String[] args) &#123; Scanner read=new Scanner(System.in); System.out.println(\"请输入人数：\"); int n = read.nextInt();//键盘接收人数的个数 boolean a[] = new boolean[n];//将人数赋值给布尔类型 for (int i = 0; i &lt; a.length; i++) &#123; a[i] = true;//将每个人赋值给true &#125; int t = 0; int len = a.length; while (len &gt;1) &#123;//当只剩下一个true时就跳出循环 for (int i = 0; i &lt; a.length; i++) &#123; if (a[i]) &#123; t++;//累加器，判断报数到3 if (t == 3) &#123;//报数到3时就赋值给false t = 0; a[i] = false; len--; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i]) &#123; System.out.println(i+1);//再次循环遍历，输出剩下的一个true &#125; &#125; &#125;&#125; 题目10(二)12345678910public class yuese &#123; public static void main(String[] args) &#123; System.out.println(cycle(10,3)); &#125; public static int cycle(int people, int num) &#123; int i, r = 0; for (i = 2; i &lt;= people; i++) r = (r + num) % i; return r + 1; &#125;&#125; 题目1112345678910111213141516171819202122/* 题目：求1-50之间的素数 * 思路：两个函数 * 主函数控制数字范围 * prime函数判断素数 */public class isprime &#123; public static void main(String[] args) &#123; for(int i=2;i&lt;=50;i++) &#123;//控制数字范围 if(prime(i)) &#123;//调用prime System.out.println(i+\"是素数\"); &#125; &#125; &#125; static boolean prime(int x) &#123; for(int i=2;i&lt;=Math.sqrt(x);i++) &#123;//（1）在一般领域，对正整数n，如果用2到 之间的所有整数去除，均无法整除，则n为质数。 if(x%i==0) &#123;//能被其他数整除，就不是素数 return false; //（2）质数大于等于2 不能被它本身和1以外的数整除 &#125; &#125; return true; &#125;&#125; 题目12123456789101112131415/* 题目：小球反弹。每次弹起高度是下降的1/2 * 用循环给h赋值，求出循环第十次的高度 * 用sum做高度累加 */public class Free &#123; public static void main(String[] args) &#123; double h=100,sum=0; for(int i=1;i&lt;=10;i++) &#123; sum+=h;//累加经过路程 h=h/2;//将上一次高度赋值给新高度 &#125; System.out.println(\"经过\"+sum+\"米\"+\" \"+\"第十次反弹\"+h); &#125;&#125;","pubDate":"Sat, 21 Sep 2019 11:45:32 GMT","guid":"https://augus-liuzhi.github.io/2019/09/21/Java算法题/","category":"-java算法"},{"title":"java自动生成四则运算+源码","link":"https://augus-liuzhi.github.io/2019/09/20/Java自动生成四则运算/","description":"1.需求分析： 为了对学生的算数进行锻炼，家长每天给孩子出题成为一个难题，需要做出一个程序，每天生成一定数量且不重复的题目，分解家长们的压力。 2. 功能设计: 2.1 基本功能： 自动生成10道100以内的2个操作数的四则运算算式== （+ - * /）==，要求运算结果也在100以内——&gt;实现 剔除重复算式。 2 + 3 = 和 2 + 3 = 是重复算式 2 + 3 = 和 3 + 2 = 不属于重复算式——&gt;实现 题目数量可定制——&gt;实现 相关参数可控——&gt;实现 是否包含乘法和除法 操作数数值范围可控（如操作数 在100以内 还是1000以内） 操作数是否含负数 生成的运算题存储到外部文件result.txt中——-&gt;实现 2.2 拓展功能： 1. 自动生成答案 2. 添加学号，并为每个学号生成不同的试题 3. 设计实现： 使用构造函数PrintStream Scanner ，PrintStream ps = new PrintStream(&quot;d:/result.txt&quot;); System.setOut(ps);调用此函数，可以将所有System.out.println();输出语句，打印到i我们创建的文件夹中 Scanner t=new Scanner(System.in); 控制我们从键盘输入 Math.random();产生随机不重复函数，我做了以下测试 12345678910111213141516171819202122&gt; 1 /*&gt; 2 * 验证random会不会产生相同的随机数&gt; 3 * 做个10万次循环看看，发现结果为0&gt; 4 *java不像c,c会大概率产生相同的随机数，甚至会下次运行可能会和上次&gt; 5 * 产生的随机数是一样的，因此用C写得初始化一个时间种子，才能尽可能的保证随机数不相同&gt; 6 *java的random函数10万次运行都很难出现一次相同的随机数，所有random不产生重复函数&gt; 7 */&gt; 8 public class text_002&#123;&gt; 9 public static void main(String args[])&#123;&gt; 10 int count = 0;&gt; 11 double first = 0;&gt; 12 double second = 0; &gt; 13 for(int i=0; i&lt;99999; i++)&#123;&gt; 14 first = Math.random();&gt; 15 second = Math.random();&gt; 16 if (first == second)&gt; 17 count ++;&gt; 18 &#125;&gt; 19 System.out.print(count);&gt; 20 &#125;&gt; 21 &#125;&gt; 4. 测试运行： 5. 代码解释第一个操作数的选择123456789101112131415//第一个操作数的选择 2 int a=(int)(Math.random()*tf+1); 3 4 if(zf==1) &#123;//有负数 5 int p=(int) (Math.random()*2); 6 switch(p) &#123; 7 case 0:a=a*(-1);//取负数 8 System.out.print(a);break; 9 case 1:10 System.out.print(a);break;11 &#125;12 &#125;13 if(zf==0) &#123;//没有负数14 System.out.print(a);15 &#125; 运算符号的选择12345678910111213141516171819 1 System.out.println(\"请选择是否包含*或者/：2:否 4:是 \"); 2 int fu=t.nextInt(); 3 if(fu==2) &#123;//选择两个字符‘+’‘-’ 4 int k=(int)(Math.random()*2); 5 switch(k) &#123;//随机选择运算符 6 case 0:System.out.print(\"+\"); 7 break; 8 case 1:System.out.print(\"-\"); 9 break; 10 &#125;11 if(fu==4) &#123;//四个字符的‘+’‘-’‘*’‘/’12 int k=(int)(Math.random()*4+1);13 switch(k) &#123;//随机选择运算符14 case 1:System.out.print(\"+\");break;15 case 2:System.out.print(\"-\");break;16 case 3:System.out.print(\"*\");break;17 case 4:System.out.print(\"/\");break;18 &#125; 等号右侧结果 1234567891011121314151617 1 //等号 2 3 System.out.print(\"=\"); 4 //运算结果 5 if(k==1) &#123; 6 c=a+b;System.out.println(c); 7 &#125; 8 if(k==2) &#123; 9 c=a-b;System.out.println(c);10 &#125;11 if(k==3) &#123;12 c=a*b;System.out.println(c);13 &#125;14 if(k==4) &#123;15 c=a/b;System.out.println(c);16 &#125; 6. 总结 7. psp 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.io.FileNotFoundException;import java.io.InputStream;import java.io.PrintStream;import java.util.Scanner;public class text_005 &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(\"d:/result.txt\"); int c; Scanner t=new Scanner(System.in); System.out.print(\"请输入题目个数：\"); int tg=t.nextInt(); //控制题目个数 System.out.print(\"请输入操作数的范围（如 100，1000等）:\"); int tf=t.nextInt(); //控制题目范围 System.out.println(\"请选择是否有负数：1:有 0:没有\"); int zf=t.nextInt(); //控制正负数 System.out.println(\"请选择是否包含*或者/：2:否 4:是 \"); int fu=t.nextInt(); //控制符号 System.setOut(ps); //添加打印学号 //for(int j=0;j&lt;2;j++) &#123; //System.out.println(2019000+j); for(int i=0;i&lt;tg;i++) &#123;//循环控制题目个数 //第一个操作数的选择 int a=(int)(Math.random()*tf+1); if(zf==1) &#123;//有负数 int p=(int) (Math.random()*2); switch(p) &#123; case 0:a=a*(-1);//取负数 System.out.print(a);break; case 1: System.out.print(a);break; &#125; &#125; if(zf==0) &#123;//没有负数 System.out.print(a); &#125; if(fu==2) &#123;//选择两个字符‘+’‘-’ int k=(int)(Math.random()*2); switch(k) &#123;//随机选择运算符 case 0:System.out.print(\"+\"); break; case 1:System.out.print(\"-\"); break; &#125; int b=(int)(Math.random()*tf+1); if(zf==1) &#123;//有负数 int p=(int) (Math.random()*2); switch(p) &#123; case 0:b=b*(-1);//取负数 System.out.print(b);break; case 1: System.out.print(b);break; &#125; &#125; if(zf==0) &#123;//没有负数 System.out.print(b); &#125; System.out.println(\"=\"); /* //运算结果 if(k==0) &#123;c=a+b;System.out.println(c);&#125; if(k==1)&#123;c=a-b; System.out.println(c);&#125; */ &#125; if(fu==4) &#123;//四个字符的‘+’‘-’‘*’‘/’ int k=(int)(Math.random()*4+1); switch(k) &#123;//随机选择运算符 case 1:System.out.print(\"+\");break; case 2:System.out.print(\"-\");break; case 3:System.out.print(\"*\");break; case 4:System.out.print(\"/\");break; &#125; //第二个操作数的选择 int b=(int) (Math.random()*tf+1); if(zf==1) &#123;//有负数 int p=(int) (Math.random()*2); switch(p) &#123; case 0:b=b*(-1);//取负数 System.out.print(b);break; case 1: System.out.print(b);break; &#125; &#125; if(zf==0) &#123;//没有负数 System.out.print(b); &#125; //等号 System.out.println(\"=\"); /* //运算结果 if(k==1) &#123; c=a+b;System.out.println(c); &#125; if(k==2) &#123; c=a-b;System.out.println(c); &#125; if(k==3) &#123; c=a*b;System.out.println(c); &#125; if(k==4) &#123; c=a/b;System.out.println(c); &#125;*/ &#125; &#125; //学号那个循环的截止&#125;&#125;&#125;","pubDate":"Fri, 20 Sep 2019 15:01:42 GMT","guid":"https://augus-liuzhi.github.io/2019/09/20/Java自动生成四则运算/","category":"-java算法 -四则运算"},{"title":"2019软件工程第一次作业","link":"https://augus-liuzhi.github.io/2019/09/20/构建之法第一章/","description":"1.计算机专业术语及名词解释 软件=程序+软件工程 程序=数据结构+算法 程序：源程序，一行行代码 软件构建 1. cc和link命令 2. 软件架构：一系列抽象模式，指导大型软件各个方面的设计 3. 软件设计与实现 4. 各种文件和数据之间描述文件依赖，编译，链接 软件质量 1. 源代码管理（配置管理）：配置运行的操作系统及程序版本等 2. 质量保证：保证高质量软件、流程进行开发 3. 软件测试：验证的过程 软件开发 1. 需求分析：对用户的需求【靠谱、可实现】 2. 设计：软件架构 3. 实现：写数据和算法 4. 测试：软件测试 5. 发布: 发布软件 软件生命周期 1. 程序理解：懂已有程序，了解程序设计 2. 软件维护（服务运营）：打补丁，维护服务，修复问题 3. 软件项目管理：生命周期负责人 用户体验：使用者的体验 国际化和本地化：处理不同语言，不同地区用户对界面和功能的需求 商业模式 职业道德规范 软件企业=软件+商业模式 程序开发的不同阶段 1. 写程序练习数据结构由与算法 2. 用JAVAScript ASP.NET Ruby写写网站 3. 钻研新技术，应用新技术在软件行业创新 4. 银行软件系统，互联网搜索行业，电子商务系，windows操作系统 软件开发特性（难题） 1. 复杂性 2. 不可见行性 3. 易变形 4. 服从性 5. 非连续性 ​ 计算机科学偏理论领域 1. 计算理论 2. 信息和编码理论 3. 算法和数据结构 4. 形式化方法 5. 程序设计语言 计算机科学偏实践领域 1. 计算机体系结构 2. 并行计算和分布式系统 3. 实时系统和嵌入式系统 4. 操作系统 5. 计算机网路 6. 科学计算机 7. 安全和密码学 8. 人工智能 9. 计算机图形学 10. 数据库和大规模数据处理 11. 万维网 12. 自然语言处理和语音 13. 人机交互 14. 软件工程 生命周期（软件需求、软件设计、软件构建、软件测试、软件维护） 专门领域 （软件配置管理、软件工程管理、软件工程过程、软件工程模型和方法、软件质量） 理论基础（计算基础、数学基础、工程基础） 软件缺陷 bug 足够好的软件 1. 用户满意度 2. 可靠性 3. 软件流程的质量 4. 可维护性 2.构建之法五个问题 1 p15 ，足够好的软件中，如果一个项目在规定时间之内，无法完成或者bug很多，应该怎么解决，谁来承担后果，会有怎样的后果？ 2 P42， 对于个人能力的衡量和发展，企业如何衡量一个人的能力，个人发展又怎样的晋升制度？*3 P130 关于成员授权和信任问题。如果有能力干活的人中途离开了或者在开发过程中这个人遇到技术难题，长时间未解决，其他成员对这个人产生能力质疑时，如何解决这个问题？由谁来主导这个问题的解决？ 4 P136， 对于投资质量这一节中，如何保证企业所投资的这个软件是一个好软件【盈利的软件】，从用户需求者角度想，另外还有其他的哪些方面？ 5 P184 ，关于竞争对手的产品，如何使我们制作的软件产品，比竞争对手的产品更好的发展？如何让更多的用户选择我们的产品？如何让我们的产品更有竞争力 3.软件分类及特点 Games： 王者荣耀、和平精英 Shopping：淘宝、京东、拼多多、1688、咸鱼 Pay:支付宝、云闪付、微信、京东金融 Learning：慕课网、墨墨背单词、可可英语、网易公开课、中国大学mooc 短视频：抖音、西瓜视频、今日头条、飞猪 点餐：美团、美团外卖、饿了么、口碑、KFC 特点： 1. 像饿了么，美团新用户立减15或者20，可以几分钱吃一顿饭所以下载了，都是盈利软件，对商家进行抽成，不仅赚取用户现金，和其他企业进行广告推广盈利等。2. 通过应用商店进行下载，当时大一，使用起来感觉非常符合我们3. 去年因为服务器bug,饿了么对于当时那个时段无法登陆的用户进行了10元无门槛对用户补偿，强制更新，没有取消键，进入页面，只有更新页面。4. 竞争通过对用户的新注册账号的福利，普通用户还有会员进行推广。 ​","pubDate":"Fri, 20 Sep 2019 15:01:42 GMT","guid":"https://augus-liuzhi.github.io/2019/09/20/构建之法第一章/","category":"-构建之法"},{"title":"如何用Markdown写flow流程图","link":"https://augus-liuzhi.github.io/2019/09/20/Flow流程图/","description":"Flow流程图工具：Typora 1. 流程图各个框框代表的含义1.1 开始和结束 1.2 输入输出 1.3 判断和处理 2. 模块关键字 start 程序开始 end 程序结束 opreation 程序处理块 subroutine 子程序块 condition 条件判断 inputoutput 表示程序的输入输出 right 、left 表示箭头在当前模块的起点（默认向下,多默认和右） yes 、no 表示condition判断分支 3. 模块用法 模块标识=&gt;模块关键字：内容 模块标识任意起名，最好知名解意，起一个标识的作用 内容就是框框里的文字 注意：模块关键字和内容之间有一个冒号，并且要在冒号后，必须要有一个空格 4. 模块连接方法 用-&gt;来连接,符号两侧不用空格 5. 应用实例 5.1 开始和结束模块12345代码：flowchatst=&gt;start: 开始e=&gt;end: 结束st-&gt;e 5.2 开始和程序处理块（下）1234代码start=&gt;start: 开始operation=&gt;operation: int i=1start-&gt;operation 5.3 开始和程序处理块（右）1234代码start=&gt;start: 开始operation=&gt;operation: int i=1start(right)-&gt;operation 5.4 操作和判断12345678代码con=&gt;condition: for(int i=1;i&lt;n;i++)op1=&gt;operation: int n=10;op2=&gt;operation: a++;op3=&gt;operation: a--;op1-&gt;concon(yes)-&gt;op2con(no)-&gt;op3 5.5 完整流程112345678910代码st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 操作sub=&gt;subroutine: 子程序cond=&gt;condition: 判断io=&gt;inputoutput: 输出st(right)-&gt;op-&gt;condcond(yes)-&gt;io(right)-&gt;econd(no)-&gt;sub(right)-&gt;op 5.6 完整流程2123456789代码st=&gt;start: 开始e=&gt;end: 结束op=&gt;end: 操作cond=&gt;condition: 判断st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 注意：如果使用Typora,选中代码，然后再选择语言哪里，直接输入flow即可，如果用其他编辑器，应当输入相应的语法flow` ,如csdn。博客园的markdown不支持、不支持、不支持流程图。st=>start: 开始 e=>end: 结束 st->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);in01=>inputoutput: 输入 out01=>inputoutput: 输出 in01(right)->out01{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);con02=>condition: 判断 op02=>operation: 操作 op02->con02{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-2-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-2-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-2\", options);st=>start: 开始 e=>end: 结束 st->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-3-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-3-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-3\", options);start=>start: 开始 operation=>operation: int i=1 start->operation{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-4-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-4-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-4\", options);start=>start: 开始 operation=>operation: int i=1 start(right)->operation{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-5-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-5-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-5\", options);con=>condition: for(int i=1;ioperation: int n=10; op2=>operation: a++; op3=>operation: a--; op1->con con(yes)->op2 con(no)->op3{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-6-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-6-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-6\", options);st=>start: 开始 e=>end: 结束 op=>operation: 操作 sub=>subroutine: 子程序 cond=>condition: 判断 io=>inputoutput: 输出 st(right)->op->cond cond(yes)->io(right)->e cond(no)->sub(right)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-7-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-7-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-7\", options);st=>start: 开始 e=>end: 结束 op=>end: 操作 cond=>condition: 判断 st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-8-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-8-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-8\", options);","pubDate":"Fri, 20 Sep 2019 15:01:42 GMT","guid":"https://augus-liuzhi.github.io/2019/09/20/Flow流程图/","category":"-markdown -流程图"}]}